<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>..\node_modules\angular-ui-router\lib\angular-1.1.5\angular-scenario.js - SmartDoc</title>
  
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.min.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-smart">
 <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container-fluid">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
               <a class="navbar-brand mainlogo" href="https://github.com/zhh77/smartdoc">
             
            <img alt="SmartDoc" src="../assets/css/logo.png" title="SmartDoc">
            
                SmartDoc
          </a>
            </div>
            <div id="navbar" class="navbar-collapse collapse">
                 <ul class="nav navbar-nav">
                    
                    <li><a href="https://github.com/zhh77/smartdoc">Home</a>
                    </li>
                    
                    <li><a href="/">Document</a>
                    </li>
                    
                    <li><a href="https://github.com/zhh77/smartdoc">About</a>
                    </li>
                    
                </ul>
               <div class="navbar-form navbar-right filterAPi" autocomplete="off">
                <input type="text" id='txtSearchAPI' class="form-control search-query" placeholder="Search for API" />
                 <ul id="filterList" class="filterItems dropdown-menu" role="menu"></ul>
                </div>
            </div>
        </div>
    </nav>
    <div id="sidebar">
    <h3>Modules/Classes</h3>
        <div id="api-tabview-filter">
            <input id='txtSearch' type="search" class="form-control" placeholder="Type to filter Modules/Classes">
        </div>
        <dl id="sidebar_list">
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/273.html">273</a>
                </dt>
                <dd>
                    <ul>
                   
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/alienjs.html">alienjs</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/window.require.html">window.require</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/Countdown.html">Countdown</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/Date.html">Date</a>
                </dt>
                <dd>
                    <ul>
                   
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/jquery.html">jquery</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/jquery.transitionEnd.html">jquery.transitionEnd</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.support.transition.html">jquery.support.transition</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.animationEnd.html">jquery.animationEnd</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/jquery-ui.html">jquery-ui</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/jquery.ajaxPanel.html">jquery.ajaxPanel</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.dialog.html">jquery.dialog</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/Array.html">Array</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.browserLowVersion.html">jquery.browserLowVersion</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.confirm.html">jquery.confirm</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.alert.html">jquery.alert</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/ng.html">ng</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/EventEmitter Manages event registering and emitting..html">EventEmitter Manages event registering and emitting.</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/ngMock.html">ngMock</a>
                </dt>
                <dd>
                    <ul>
                   
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/ngMockE2E.html">ngMockE2E</a>
                </dt>
                <dd>
                    <ul>
                   
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/ui.html">ui</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/AjaxPanel.html">AjaxPanel</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/Date.Dialog.html">Date.Dialog</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/WebUploader.html">WebUploader</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/Base.html">Base</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/Mediator.html">Mediator</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/options.Uploader.html">options.Uploader</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/File.File.html">File.File</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/File.Queue.html">File.Queue</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/Uploader.html">Uploader</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/window.html">window</a>
                </dt>
                <dd>
                    <ul>
                   
                    </ul>
                </dd>
             
        </dl>
</div>
   
    <div class="stdoc-content">
        <!--     <form id="options-form" class="form-inline pull-right">
        Show:
        <label for="api-show-inherited" class="checkbox">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected" class="checkbox">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private" class="checkbox">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated" class="checkbox">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </form>

 -->
        <div class="apidocs">
            <div id="docs-main">
                <div class="content">
                    <div class="page-header">
    <h1>..\node_modules\angular-ui-router\lib\angular-1.1.5\angular-scenario.js <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums" id='src_code'>
/*!
 * jQuery JavaScript Library v1.8.2
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: Thu Sep 20 2012 21:13:05 GMT-0400 (Eastern Daylight Time)
 */
(function( window, undefined ) {
&#x27;use strict&#x27;;
var
	// A central reference to the root jQuery(document)
	rootjQuery,

	// The deferred used on DOM ready
	readyList,

	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,
	location = window.location,
	navigator = window.navigator,

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// Save a reference to some core methods
	core_push = Array.prototype.push,
	core_slice = Array.prototype.slice,
	core_indexOf = Array.prototype.indexOf,
	core_toString = Object.prototype.toString,
	core_hasOwn = Object.prototype.hasOwnProperty,
	core_trim = String.prototype.trim,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor &#x27;enhanced&#x27;
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Used for matching numbers
	core_pnum = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,

	// Used for detecting and trimming whitespace
	core_rnotwhite = /\S/,
	core_rspace = /\s+/,

	// Make sure we trim BOM and NBSP (here&#x27;s looking at you, Safari 5.0 and IE)
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// A simple way to check for HTML strings
	// Prioritize #id over &lt;tag&gt; to avoid XSS via location.hash (#9521)
	rquickExpr = /^(?:[^#&lt;]*(&lt;[\w\W]+&gt;)[^&gt;]*$|#([\w\-]*)$)/,

	// Match a standalone tag
	rsingleTag = /^&lt;(\w+)\s*\/?&gt;(?:&lt;\/\1&gt;|)$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
	rvalidescape = /\\(?:[&quot;\\\/bfnrt]|u[\da-fA-F]{4})/g,
	rvalidtokens = /&quot;[^&quot;\\\r\n]*&quot;|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return ( letter + &quot;&quot; ).toUpperCase();
	},

	// The ready event handler and self cleanup method
	DOMContentLoaded = function() {
		if ( document.addEventListener ) {
			document.removeEventListener( &quot;DOMContentLoaded&quot;, DOMContentLoaded, false );
			jQuery.ready();
		} else if ( document.readyState === &quot;complete&quot; ) {
			// we&#x27;re here because readyState === &quot;complete&quot; in oldIE
			// which is good enough for us to call the dom ready!
			document.detachEvent( &quot;onreadystatechange&quot;, DOMContentLoaded );
			jQuery.ready();
		}
	},

	// [[Class]] -&gt; type pairs
	class2type = {};

jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;

		// Handle $(&quot;&quot;), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === &quot;string&quot; ) {
			if ( selector.charAt(0) === &quot;&lt;&quot; &amp;&amp; selector.charAt( selector.length - 1 ) === &quot;&gt;&quot; &amp;&amp; selector.length &gt;= 3 ) {
				// Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match &amp;&amp; (match[1] || !context) ) {

				// HANDLE: $(html) -&gt; $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;
					doc = ( context &amp;&amp; context.nodeType ? context.ownerDocument || context : document );

					// scripts is true for back-compat
					selector = jQuery.parseHTML( match[1], doc, true );
					if ( rsingleTag.test( match[1] ) &amp;&amp; jQuery.isPlainObject( context ) ) {
						this.attr.call( selector, context, true );
					}

					return jQuery.merge( this, selector );

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem &amp;&amp; elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: &quot;&quot;,

	// The current version of jQuery being used
	jquery: &quot;1.8.2&quot;,

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return core_slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a &#x27;clean&#x27; array
			this.toArray() :

			// Return just the object
			( num &lt; 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === &quot;find&quot; ) {
			ret.selector = this.selector + ( this.selector ? &quot; &quot; : &quot;&quot; ) + selector;
		} else if ( name ) {
			ret.selector = this.selector + &quot;.&quot; + name + &quot;(&quot; + selector + &quot;)&quot;;
		}

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Add the callback
		jQuery.ready.promise().done( fn );

		return this;
	},

	eq: function( i ) {
		i = +i;
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( core_slice.apply( this, arguments ),
			&quot;slice&quot;, core_slice.call(arguments).join(&quot;,&quot;) );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array&#x27;s method, not like a jQuery method.
	push: core_push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === &quot;boolean&quot; ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== &quot;object&quot; &amp;&amp; !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i &lt; length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we&#x27;re merging plain objects or arrays
				if ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src &amp;&amp; jQuery.isArray(src) ? src : [];

					} else {
						clone = src &amp;&amp; jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don&#x27;t bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep &amp;&amp; window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we&#x27;re already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( !document.body ) {
			return setTimeout( jQuery.ready, 1 );
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true &amp;&amp; --jQuery.readyWait &gt; 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.trigger ) {
			jQuery( document ).trigger(&quot;ready&quot;).off(&quot;ready&quot;);
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren&#x27;t supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === &quot;function&quot;;
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === &quot;array&quot;;
	},

	isWindow: function( obj ) {
		return obj != null &amp;&amp; obj == obj.window;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) &amp;&amp; isFinite( obj );
	},

	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ core_toString.call(obj) ] || &quot;object&quot;;
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don&#x27;t pass through, as well
		if ( !obj || jQuery.type(obj) !== &quot;object&quot; || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &amp;&amp;
				!core_hasOwn.call(obj, &quot;constructor&quot;) &amp;&amp;
				!core_hasOwn.call(obj.constructor.prototype, &quot;isPrototypeOf&quot;) ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for ( key in obj ) {}

		return key === undefined || core_hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	// data: string of html
	// context (optional): If specified, the fragment will be created in this context, defaults to document
	// scripts (optional): If true, will include scripts passed in the html string
	parseHTML: function( data, context, scripts ) {
		var parsed;
		if ( !data || typeof data !== &quot;string&quot; ) {
			return null;
		}
		if ( typeof context === &quot;boolean&quot; ) {
			scripts = context;
			context = 0;
		}
		context = context || document;

		// Single tag
		if ( (parsed = rsingleTag.exec( data )) ) {
			return [ context.createElement( parsed[1] ) ];
		}

		parsed = jQuery.buildFragment( [ data ], context, scripts ? null : [] );
		return jQuery.merge( [],
			(parsed.cacheable ? jQuery.clone( parsed.fragment ) : parsed.fragment).childNodes );
	},

	parseJSON: function( data ) {
		if ( !data || typeof data !== &quot;string&quot;) {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can&#x27;t handle it)
		data = jQuery.trim( data );

		// Attempt to parse using the native JSON parser first
		if ( window.JSON &amp;&amp; window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test( data.replace( rvalidescape, &quot;@&quot; )
			.replace( rvalidtokens, &quot;]&quot; )
			.replace( rvalidbraces, &quot;&quot;)) ) {

			return ( new Function( &quot;return &quot; + data ) )();

		}
		jQuery.error( &quot;Invalid JSON: &quot; + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		var xml, tmp;
		if ( !data || typeof data !== &quot;string&quot; ) {
			return null;
		}
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , &quot;text/xml&quot; );
			} else { // IE
				xml = new ActiveXObject( &quot;Microsoft.XMLDOM&quot; );
				xml.async = &quot;false&quot;;
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( &quot;parsererror&quot; ).length ) {
			jQuery.error( &quot;Invalid XML: &quot; + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data &amp;&amp; core_rnotwhite.test( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ &quot;eval&quot; ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, &quot;ms-&quot; ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var name,
			i = 0,
			length = obj.length,
			isObj = length === undefined || jQuery.isFunction( obj );

		if ( args ) {
			if ( isObj ) {
				for ( name in obj ) {
					if ( callback.apply( obj[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i &lt; length; ) {
					if ( callback.apply( obj[ i++ ], args ) === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isObj ) {
				for ( name in obj ) {
					if ( callback.call( obj[ name ], name, obj[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i &lt; length; ) {
					if ( callback.call( obj[ i ], i, obj[ i++ ] ) === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Use native String.trim function wherever possible
	trim: core_trim &amp;&amp; !core_trim.call(&quot;\uFEFF\xA0&quot;) ?
		function( text ) {
			return text == null ?
				&quot;&quot; :
				core_trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				&quot;&quot; :
				( text + &quot;&quot; ).replace( rtrim, &quot;&quot; );
		},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var type,
			ret = results || [];

		if ( arr != null ) {
			// The window, strings (and functions) also have &#x27;length&#x27;
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
			type = jQuery.type( arr );

			if ( arr.length == null || type === &quot;string&quot; || type === &quot;function&quot; || type === &quot;regexp&quot; || jQuery.isWindow( arr ) ) {
				core_push.call( ret, arr );
			} else {
				jQuery.merge( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		var len;

		if ( arr ) {
			if ( core_indexOf ) {
				return core_indexOf.call( arr, elem, i );
			}

			len = arr.length;
			i = i ? i &lt; 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i &lt; len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in arr &amp;&amp; arr[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var l = second.length,
			i = first.length,
			j = 0;

		if ( typeof l === &quot;number&quot; ) {
			for ( ; j &lt; l; j++ ) {
				first[ i++ ] = second[ j ];
			}

		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var retVal,
			ret = [],
			i = 0,
			length = elems.length;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i &lt; length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value, key,
			ret = [],
			i = 0,
			length = elems.length,
			// jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined &amp;&amp; typeof length === &quot;number&quot; &amp;&amp; ( ( length &gt; 0 &amp;&amp; elems[ 0 ] &amp;&amp; elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i &lt; length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( key in elems ) {
				value = callback( elems[ key ], key, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return ret.concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === &quot;string&quot; ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = core_slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context, args.concat( core_slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it&#x27;s a function
	access: function( elems, fn, key, value, chainable, emptyGet, pass ) {
		var exec,
			bulk = key == null,
			i = 0,
			length = elems.length;

		// Sets many values
		if ( key &amp;&amp; typeof key === &quot;object&quot; ) {
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], 1, emptyGet, value );
			}
			chainable = 1;

		// Sets one value
		} else if ( value !== undefined ) {
			// Optionally, function values get executed if exec is true
			exec = pass === undefined &amp;&amp; jQuery.isFunction( value );

			if ( bulk ) {
				// Bulk operations only iterate when executing function values
				if ( exec ) {
					exec = fn;
					fn = function( elem, key, value ) {
						return exec.call( jQuery( elem ), value );
					};

				// Otherwise they run against the entire set
				} else {
					fn.call( elems, value );
					fn = null;
				}
			}

			if ( fn ) {
				for (; i &lt; length; i++ ) {
					fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
				}
			}

			chainable = 1;
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				length ? fn( elems[0], key ) : emptyGet;
	},

	now: function() {
		return ( new Date() ).getTime();
	}
});

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState &quot;interactive&quot; here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === &quot;complete&quot; ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready, 1 );

		// Standards-based browsers support DOMContentLoaded
		} else if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( &quot;DOMContentLoaded&quot;, DOMContentLoaded, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( &quot;load&quot;, jQuery.ready, false );

		// If IE event model is used
		} else {
			// Ensure firing before onload, maybe late but safe also for iframes
			document.attachEvent( &quot;onreadystatechange&quot;, DOMContentLoaded );

			// A fallback to window.onload, that will always work
			window.attachEvent( &quot;onload&quot;, jQuery.ready );

			// If IE and not a frame
			// continually check to see if the document is ready
			var top = false;

			try {
				top = window.frameElement == null &amp;&amp; document.documentElement;
			} catch(e) {}

			if ( top &amp;&amp; top.doScroll ) {
				(function doScrollCheck() {
					if ( !jQuery.isReady ) {

						try {
							// Use the trick by Diego Perini
							// http://javascript.nwbox.com/IEContentLoaded/
							top.doScroll(&quot;left&quot;);
						} catch(e) {
							return setTimeout( doScrollCheck, 50 );
						}

						// and execute any waiting functions
						jQuery.ready();
					}
				})();
			}
		}
	}
	return readyList.promise( obj );
};

// Populate the class2type map
jQuery.each(&quot;Boolean Number String Function Array Date RegExp Object&quot;.split(&quot; &quot;), function(i, name) {
	class2type[ &quot;[object &quot; + name + &quot;]&quot; ] = name.toLowerCase();
});

// All jQuery objects should point back to these
rootjQuery = jQuery(document);
// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.split( core_rspace ), function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * &quot;fired&quot; multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest &quot;memorized&quot;
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === &quot;string&quot; ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once &amp;&amp; [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory &amp;&amp; data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false &amp;&amp; options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === &quot;function&quot; &amp;&amp; ( !options.unique || !self.has( arg ) ) ) {
								list.push( arg );
							} else if ( arg &amp;&amp; arg.length &amp;&amp; type !== &quot;string&quot; ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we&#x27;re not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while( ( index = jQuery.inArray( arg, list, index ) ) &gt; -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index &lt;= firingLength ) {
									firingLength--;
								}
								if ( index &lt;= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Control if a given callback is in the list
			has: function( fn ) {
				return jQuery.inArray( fn, list ) &gt; -1;
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				args = args || [];
				args = [ context, args.slice ? args.slice() : args ];
				if ( list &amp;&amp; ( !fired || stack ) ) {
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};
jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ &quot;resolve&quot;, &quot;done&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;resolved&quot; ],
				[ &quot;reject&quot;, &quot;fail&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;rejected&quot; ],
				[ &quot;notify&quot;, &quot;progress&quot;, jQuery.Callbacks(&quot;memory&quot;) ]
			],
			state = &quot;pending&quot;,
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var action = tuple[ 0 ],
								fn = fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ]( jQuery.isFunction( fn ) ?
								function() {
									var returned = fn.apply( this, arguments );
									if ( returned &amp;&amp; jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.done( newDefer.resolve )
											.fail( newDefer.reject )
											.progress( newDefer.notify );
									} else {
										newDefer[ action + &quot;With&quot; ]( this === deferred ? newDefer : this, [ returned ] );
									}
								} :
								newDefer[ action ]
							);
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ] = list.fire
			deferred[ tuple[0] ] = list.fire;
			deferred[ tuple[0] + &quot;With&quot; ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = core_slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate &amp;&amp; jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length &gt; 1 ? core_slice.call( arguments ) : value;
					if( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length &gt; 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i &lt; length; i++ ) {
				if ( resolveValues[ i ] &amp;&amp; jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we&#x27;re not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});
jQuery.support = (function() {

	var support,
		all,
		a,
		select,
		opt,
		input,
		fragment,
		eventName,
		i,
		isSupported,
		clickFn,
		div = document.createElement(&quot;div&quot;);

	// Preliminary tests
	div.setAttribute( &quot;className&quot;, &quot;t&quot; );
	div.innerHTML = &quot;  &lt;link/&gt;&lt;table&gt;&lt;/table&gt;&lt;a href=&#x27;/a&#x27;&gt;a&lt;/a&gt;&lt;input type=&#x27;checkbox&#x27;/&gt;&quot;;

	all = div.getElementsByTagName(&quot;*&quot;);
	a = div.getElementsByTagName(&quot;a&quot;)[ 0 ];
	a.style.cssText = &quot;top:1px;float:left;opacity:.5&quot;;

	// Can&#x27;t get basic test support
	if ( !all || !all.length ) {
		return {};
	}

	// First batch of supports tests
	select = document.createElement(&quot;select&quot;);
	opt = select.appendChild( document.createElement(&quot;option&quot;) );
	input = div.getElementsByTagName(&quot;input&quot;)[ 0 ];

	support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: ( div.firstChild.nodeType === 3 ),

		// Make sure that tbody elements aren&#x27;t automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName(&quot;tbody&quot;).length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName(&quot;link&quot;).length,

		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		style: /top/.test( a.getAttribute(&quot;style&quot;) ),

		// Make sure that URLs aren&#x27;t manipulated
		// (IE normalizes it by default)
		hrefNormalized: ( a.getAttribute(&quot;href&quot;) === &quot;/a&quot; ),

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.5/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Make sure that if no value is specified for a checkbox
		// that it defaults to &quot;on&quot;.
		// (WebKit defaults to &quot;&quot; instead)
		checkOn: ( input.value === &quot;on&quot; ),

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it&#x27;s in an optgroup)
		optSelected: opt.selected,

		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		getSetAttribute: div.className !== &quot;t&quot;,

		// Tests for enctype support on a form(#6743)
		enctype: !!document.createElement(&quot;form&quot;).enctype,

		// Makes sure cloning an html5 element does not cause problems
		// Where outerHTML is undefined, this still works
		html5Clone: document.createElement(&quot;nav&quot;).cloneNode( true ).outerHTML !== &quot;&lt;:nav&gt;&lt;/:nav&gt;&quot;,

		// jQuery.support.boxModel DEPRECATED in 1.8 since we don&#x27;t support Quirks Mode
		boxModel: ( document.compatMode === &quot;CSS1Compat&quot; ),

		// Will be defined later
		submitBubbles: true,
		changeBubbles: true,
		focusinBubbles: false,
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true,
		boxSizingReliable: true,
		pixelPosition: false
	};

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren&#x27;t marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Test to see if it&#x27;s possible to delete an expando from an element
	// Fails in Internet Explorer
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	if ( !div.addEventListener &amp;&amp; div.attachEvent &amp;&amp; div.fireEvent ) {
		div.attachEvent( &quot;onclick&quot;, clickFn = function() {
			// Cloning a node shouldn&#x27;t copy over any
			// bound event handlers (IE does this)
			support.noCloneEvent = false;
		});
		div.cloneNode( true ).fireEvent(&quot;onclick&quot;);
		div.detachEvent( &quot;onclick&quot;, clickFn );
	}

	// Check if a radio maintains its value
	// after being appended to the DOM
	input = document.createElement(&quot;input&quot;);
	input.value = &quot;t&quot;;
	input.setAttribute( &quot;type&quot;, &quot;radio&quot; );
	support.radioValue = input.value === &quot;t&quot;;

	input.setAttribute( &quot;checked&quot;, &quot;checked&quot; );

	// #11217 - WebKit loses check when the name is after the checked attribute
	input.setAttribute( &quot;name&quot;, &quot;t&quot; );

	div.appendChild( input );
	fragment = document.createDocumentFragment();
	fragment.appendChild( div.lastChild );

	// WebKit doesn&#x27;t clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	fragment.removeChild( input );
	fragment.appendChild( div );

	// Technique from Juriy Zaytsev
	// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
	// We only care about the case where non-standard event systems
	// are used, namely in IE. Short-circuiting here helps us to
	// avoid an eval call (in setAttribute) which can cause CSP
	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
	if ( div.attachEvent ) {
		for ( i in {
			submit: true,
			change: true,
			focusin: true
		}) {
			eventName = &quot;on&quot; + i;
			isSupported = ( eventName in div );
			if ( !isSupported ) {
				div.setAttribute( eventName, &quot;return;&quot; );
				isSupported = ( typeof div[ eventName ] === &quot;function&quot; );
			}
			support[ i + &quot;Bubbles&quot; ] = isSupported;
		}
	}

	// Run tests that need a body at doc ready
	jQuery(function() {
		var container, div, tds, marginDiv,
			divReset = &quot;padding:0;margin:0;border:0;display:block;overflow:hidden;&quot;,
			body = document.getElementsByTagName(&quot;body&quot;)[0];

		if ( !body ) {
			// Return for frameset docs that don&#x27;t have a body
			return;
		}

		container = document.createElement(&quot;div&quot;);
		container.style.cssText = &quot;visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px&quot;;
		body.insertBefore( container, body.firstChild );

		// Construct the test element
		div = document.createElement(&quot;div&quot;);
		container.appendChild( div );

		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		// (only IE 8 fails this test)
		div.innerHTML = &quot;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;t&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&quot;;
		tds = div.getElementsByTagName(&quot;td&quot;);
		tds[ 0 ].style.cssText = &quot;padding:0;margin:0;border:0;display:none&quot;;
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = &quot;&quot;;
		tds[ 1 ].style.display = &quot;none&quot;;

		// Check if empty table cells still have offsetWidth/Height
		// (IE &lt;= 8 fail this test)
		support.reliableHiddenOffsets = isSupported &amp;&amp; ( tds[ 0 ].offsetHeight === 0 );

		// Check box-sizing and margin behavior
		div.innerHTML = &quot;&quot;;
		div.style.cssText = &quot;box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;&quot;;
		support.boxSizing = ( div.offsetWidth === 4 );
		support.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== 1 );

		// NOTE: To any future maintainer, we&#x27;ve window.getComputedStyle
		// because jsdom on node.js will break without it.
		if ( window.getComputedStyle ) {
			support.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== &quot;1%&quot;;
			support.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: &quot;4px&quot; } ).width === &quot;4px&quot;;

			// Check if div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container. For more
			// info see bug #3333
			// Fails in WebKit before Feb 2011 nightlies
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			marginDiv = document.createElement(&quot;div&quot;);
			marginDiv.style.cssText = div.style.cssText = divReset;
			marginDiv.style.marginRight = marginDiv.style.width = &quot;0&quot;;
			div.style.width = &quot;1px&quot;;
			div.appendChild( marginDiv );
			support.reliableMarginRight =
				!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );
		}

		if ( typeof div.style.zoom !== &quot;undefined&quot; ) {
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to &#x27;inline&#x27; and giving
			// them layout
			// (IE &lt; 8 does this)
			div.innerHTML = &quot;&quot;;
			div.style.cssText = divReset + &quot;width:1px;padding:1px;display:inline;zoom:1&quot;;
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );

			// Check if elements with layout shrink-wrap their children
			// (IE 6 does this)
			div.style.display = &quot;block&quot;;
			div.style.overflow = &quot;visible&quot;;
			div.innerHTML = &quot;&lt;div&gt;&lt;/div&gt;&quot;;
			div.firstChild.style.width = &quot;5px&quot;;
			support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );

			container.style.zoom = 1;
		}

		// Null elements to avoid leaks in IE
		body.removeChild( container );
		container = div = tds = marginDiv = null;
	});

	// Null elements to avoid leaks in IE
	fragment.removeChild( div );
	all = a = select = opt = input = fragment = div = null;

	return support;
})();
var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
	rmultiDash = /([A-Z])/g;

jQuery.extend({
	cache: {},

	deletedIds: [],

	// Remove at next major release (1.9/2.0)
	uuid: 0,

	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: &quot;jQuery&quot; + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, &quot;&quot; ),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		&quot;embed&quot;: true,
		// Ban all objects except for Flash (which handle expandos)
		&quot;object&quot;: &quot;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&quot;,
		&quot;applet&quot;: true
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem &amp;&amp; !isEmptyDataObject( elem );
	},

	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === &quot;string&quot;,

			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can&#x27;t GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ internalKey ] : elem[ internalKey ] &amp;&amp; internalKey;

		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || !cache[id] || (!pvt &amp;&amp; !cache[id].data)) &amp;&amp; getByName &amp;&amp; data === undefined ) {
			return;
		}

		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				elem[ internalKey ] = id = jQuery.deletedIds.pop() || jQuery.guid++;
			} else {
				id = internalKey;
			}
		}

		if ( !cache[ id ] ) {
			cache[ id ] = {};

			// Avoids exposing jQuery metadata on plain JS objects when the object
			// is serialized using JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}

		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === &quot;object&quot; || typeof name === &quot;function&quot; ) {
			if ( pvt ) {
				cache[ id ] = jQuery.extend( cache[ id ], name );
			} else {
				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
			}
		}

		thisCache = cache[ id ];

		// jQuery data() is stored in a separate object inside the object&#x27;s internal data
		// cache in order to avoid key collisions between internal data and user-defined
		// data.
		if ( !pvt ) {
			if ( !thisCache.data ) {
				thisCache.data = {};
			}

			thisCache = thisCache.data;
		}

		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}

		// Check for both converted-to-camel and non-converted data property names
		// If a data property was specified
		if ( getByName ) {

			// First Try to find as-is property data
			ret = thisCache[ name ];

			// Test for null|undefined property data
			if ( ret == null ) {

				// Try to find the camelCased property
				ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}

		return ret;
	},

	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, i, l,

			isNode = elem.nodeType,

			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,
			id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}

		if ( name ) {

			thisCache = pvt ? cache[ id ] : cache[ id ].data;

			if ( thisCache ) {

				// Support array or space separated string names for data keys
				if ( !jQuery.isArray( name ) ) {

					// try the string as a key before any manipulation
					if ( name in thisCache ) {
						name = [ name ];
					} else {

						// split the camel cased version by spaces unless a key with the spaces exists
						name = jQuery.camelCase( name );
						if ( name in thisCache ) {
							name = [ name ];
						} else {
							name = name.split(&quot; &quot;);
						}
					}
				}

				for ( i = 0, l = name.length; i &lt; l; i++ ) {
					delete thisCache[ name[i] ];
				}

				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
					return;
				}
			}
		}

		// See jQuery.data for more information
		if ( !pvt ) {
			delete cache[ id ].data;

			// Don&#x27;t destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject( cache[ id ] ) ) {
				return;
			}
		}

		// Destroy the cache
		if ( isNode ) {
			jQuery.cleanData( [ elem ], true );

		// Use delete when supported for expandos or &#x60;cache&#x60; is not a window per isWindow (#10080)
		} else if ( jQuery.support.deleteExpando || cache != cache.window ) {
			delete cache[ id ];

		// When all else fails, null
		} else {
			cache[ id ] = null;
		}
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		var noData = elem.nodeName &amp;&amp; jQuery.noData[ elem.nodeName.toLowerCase() ];

		// nodes accept data unless otherwise specified; rejection can be conditional
		return !noData || noData !== true &amp;&amp; elem.getAttribute(&quot;classid&quot;) === noData;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var parts, part, attr, name, l,
			elem = this[0],
			i = 0,
			data = null;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 &amp;&amp; !jQuery._data( elem, &quot;parsedAttrs&quot; ) ) {
					attr = elem.attributes;
					for ( l = attr.length; i &lt; l; i++ ) {
						name = attr[i].name;

						if ( !name.indexOf( &quot;data-&quot; ) ) {
							name = jQuery.camelCase( name.substring(5) );

							dataAttr( elem, name, data[ name ] );
						}
					}
					jQuery._data( elem, &quot;parsedAttrs&quot;, true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === &quot;object&quot; ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		parts = key.split( &quot;.&quot;, 2 );
		parts[1] = parts[1] ? &quot;.&quot; + parts[1] : &quot;&quot;;
		part = parts[1] + &quot;!&quot;;

		return jQuery.access( this, function( value ) {

			if ( value === undefined ) {
				data = this.triggerHandler( &quot;getData&quot; + part, [ parts[0] ] );

				// Try to fetch any internally stored data first
				if ( data === undefined &amp;&amp; elem ) {
					data = jQuery.data( elem, key );
					data = dataAttr( elem, key, data );
				}

				return data === undefined &amp;&amp; parts[1] ?
					this.data( parts[0] ) :
					data;
			}

			parts[1] = value;
			this.each(function() {
				var self = jQuery( this );

				self.triggerHandler( &quot;setData&quot; + part, parts );
				jQuery.data( this, key, value );
				self.triggerHandler( &quot;changeData&quot; + part, parts );
			});
		}, null, value, arguments.length &gt; 1, null, false );
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined &amp;&amp; elem.nodeType === 1 ) {

		var name = &quot;data-&quot; + key.replace( rmultiDash, &quot;-$1&quot; ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === &quot;string&quot; ) {
			try {
				data = data === &quot;true&quot; ? true :
				data === &quot;false&quot; ? false :
				data === &quot;null&quot; ? null :
				// Only convert to a number if it doesn&#x27;t change the string
				+data + &quot;&quot; === data ? +data :
				rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn&#x27;t changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	var name;
	for ( name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === &quot;data&quot; &amp;&amp; jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== &quot;toJSON&quot; ) {
			return false;
		}
	}

	return true;
}
jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || &quot;fx&quot; ) + &quot;queue&quot;;
			queue = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray(data) ) {
					queue = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || &quot;fx&quot;;

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === &quot;inprogress&quot; ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === &quot;fx&quot; ) {
				queue.unshift( &quot;inprogress&quot; );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength &amp;&amp; hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + &quot;queueHooks&quot;;
		return jQuery._data( elem, key ) || jQuery._data( elem, key, {
			empty: jQuery.Callbacks(&quot;once memory&quot;).add(function() {
				jQuery.removeData( elem, type + &quot;queue&quot;, true );
				jQuery.removeData( elem, key, true );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== &quot;string&quot; ) {
			data = type;
			type = &quot;fx&quot;;
			setter--;
		}

		if ( arguments.length &lt; setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === &quot;fx&quot; &amp;&amp; queue[0] !== &quot;inprogress&quot; ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || &quot;fx&quot;;

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || &quot;fx&quot;, [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== &quot;string&quot; ) {
			obj = type;
			type = undefined;
		}
		type = type || &quot;fx&quot;;

		while( i-- ) {
			tmp = jQuery._data( elements[ i ], type + &quot;queueHooks&quot; );
			if ( tmp &amp;&amp; tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var nodeHook, boolHook, fixSpecified,
	rclass = /[\t\r\n]/g,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea|)$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, jQuery.attr, name, value, arguments.length &gt; 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, jQuery.prop, name, value, arguments.length &gt; 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classNames, i, l, elem,
			setClass, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call(this, j, this.className) );
			});
		}

		if ( value &amp;&amp; typeof value === &quot;string&quot; ) {
			classNames = value.split( core_rspace );

			for ( i = 0, l = this.length; i &lt; l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 ) {
					if ( !elem.className &amp;&amp; classNames.length === 1 ) {
						elem.className = value;

					} else {
						setClass = &quot; &quot; + elem.className + &quot; &quot;;

						for ( c = 0, cl = classNames.length; c &lt; cl; c++ ) {
							if ( setClass.indexOf( &quot; &quot; + classNames[ c ] + &quot; &quot; ) &lt; 0 ) {
								setClass += classNames[ c ] + &quot; &quot;;
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var removes, className, elem, c, cl, i, l;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call(this, j, this.className) );
			});
		}
		if ( (value &amp;&amp; typeof value === &quot;string&quot;) || value === undefined ) {
			removes = ( value || &quot;&quot; ).split( core_rspace );

			for ( i = 0, l = this.length; i &lt; l; i++ ) {
				elem = this[ i ];
				if ( elem.nodeType === 1 &amp;&amp; elem.className ) {

					className = (&quot; &quot; + elem.className + &quot; &quot;).replace( rclass, &quot; &quot; );

					// loop over each item in the removal list
					for ( c = 0, cl = removes.length; c &lt; cl; c++ ) {
						// Remove until there is nothing to remove,
						while ( className.indexOf(&quot; &quot; + removes[ c ] + &quot; &quot;) &gt;= 0 ) {
							className = className.replace( &quot; &quot; + removes[ c ] + &quot; &quot; , &quot; &quot; );
						}
					}
					elem.className = value ? jQuery.trim( className ) : &quot;&quot;;
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === &quot;boolean&quot;;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === &quot;string&quot; ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( core_rspace );

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? &quot;addClass&quot; : &quot;removeClass&quot; ]( className );
				}

			} else if ( type === &quot;undefined&quot; || type === &quot;boolean&quot; ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, &quot;__className__&quot;, this.className );
				}

				// toggle whole className
				this.className = this.className || value === false ? &quot;&quot; : jQuery._data( this, &quot;__className__&quot; ) || &quot;&quot;;
			}
		});
	},

	hasClass: function( selector ) {
		var className = &quot; &quot; + selector + &quot; &quot;,
			i = 0,
			l = this.length;
		for ( ; i &lt; l; i++ ) {
			if ( this[i].nodeType === 1 &amp;&amp; (&quot; &quot; + this[i].className + &quot; &quot;).replace(rclass, &quot; &quot;).indexOf( className ) &gt;= 0 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; (ret = hooks.get( elem, &quot;value&quot; )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === &quot;string&quot; ?
					// handle most common string cases
					ret.replace(rreturn, &quot;&quot;) :
					// handle cases where value is null/undef or number
					ret == null ? &quot;&quot; : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val,
				self = jQuery(this);

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}

			// Treat null/undefined as &quot;&quot;; convert numbers to string
			if ( val == null ) {
				val = &quot;&quot;;
			} else if ( typeof val === &quot;number&quot; ) {
				val += &quot;&quot;;
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? &quot;&quot; : value + &quot;&quot;;
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !(&quot;set&quot; in hooks) || hooks.set( this, val, &quot;value&quot; ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// attributes.value is undefined in Blackberry 4.7 but
				// uses .value. See #6932
				var val = elem.attributes.value;
				return !val || val.specified ? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, i, max, option,
					index = elem.selectedIndex,
					values = [],
					options = elem.options,
					one = elem.type === &quot;select-one&quot;;

				// Nothing was selected
				if ( index &lt; 0 ) {
					return null;
				}

				// Loop through all the selected options
				i = one ? index : 0;
				max = one ? index + 1 : options.length;
				for ( ; i &lt; max; i++ ) {
					option = options[ i ];

					// Don&#x27;t return options that are disabled or in a disabled optgroup
					if ( option.selected &amp;&amp; (jQuery.support.optDisabled ? !option.disabled : option.getAttribute(&quot;disabled&quot;) === null) &amp;&amp;
							(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, &quot;optgroup&quot; )) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don&#x27;t need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				// Fixes Bug #2551 -- select.val() broken in IE after form.reset()
				if ( one &amp;&amp; !values.length &amp;&amp; options.length ) {
					return jQuery( options[ index ] ).val();
				}

				return values;
			},

			set: function( elem, value ) {
				var values = jQuery.makeArray( value );

				jQuery(elem).find(&quot;option&quot;).each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) &gt;= 0;
				});

				if ( !values.length ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	// Unused in 1.8, left in so attrFn-stabbers won&#x27;t die; remove in 1.9
	attrFn: {},

	attr: function( elem, name, value, pass ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don&#x27;t get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( pass &amp;&amp; jQuery.isFunction( jQuery.fn[ name ] ) ) {
			return jQuery( elem )[ name ]( value );
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === &quot;undefined&quot; ) {
			return jQuery.prop( elem, name, value );
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( notxml ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;

			} else if ( hooks &amp;&amp; &quot;set&quot; in hooks &amp;&amp; notxml &amp;&amp; (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + &quot;&quot; );
				return value;
			}

		} else if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; notxml &amp;&amp; (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {

			ret = elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return ret === null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var propName, attrNames, name, isBool,
			i = 0;

		if ( value &amp;&amp; elem.nodeType === 1 ) {

			attrNames = value.split( core_rspace );

			for ( ; i &lt; attrNames.length; i++ ) {
				name = attrNames[ i ];

				if ( name ) {
					propName = jQuery.propFix[ name ] || name;
					isBool = rboolean.test( name );

					// See #9699 for explanation of this approach (setting first, then removal)
					// Do not do this for boolean attributes (see #10870)
					if ( !isBool ) {
						jQuery.attr( elem, name, &quot;&quot; );
					}
					elem.removeAttribute( getSetAttribute ? name : propName );

					// Set corresponding property to false for boolean attributes
					if ( isBool &amp;&amp; propName in elem ) {
						elem[ propName ] = false;
					}
				}
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				// We can&#x27;t allow the type property to be changed (since it causes problems in IE)
				if ( rtype.test( elem.nodeName ) &amp;&amp; elem.parentNode ) {
					jQuery.error( &quot;type property can&#x27;t be changed&quot; );
				} else if ( !jQuery.support.radioValue &amp;&amp; value === &quot;radio&quot; &amp;&amp; jQuery.nodeName(elem, &quot;input&quot;) ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to it&#x27;s default in case type is set after value
					// This is for element creation
					var val = elem.value;
					elem.setAttribute( &quot;type&quot;, value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		},
		// Use the value property for back compat
		// Use the nodeHook for button elements in IE6/7 (#1954)
		value: {
			get: function( elem, name ) {
				if ( nodeHook &amp;&amp; jQuery.nodeName( elem, &quot;button&quot; ) ) {
					return nodeHook.get( elem, name );
				}
				return name in elem ?
					elem.value :
					null;
			},
			set: function( elem, value, name ) {
				if ( nodeHook &amp;&amp; jQuery.nodeName( elem, &quot;button&quot; ) ) {
					return nodeHook.set( elem, value, name );
				}
				// Does not return so that setAttribute is also used
				elem.value = value;
			}
		}
	},

	propFix: {
		tabindex: &quot;tabIndex&quot;,
		readonly: &quot;readOnly&quot;,
		&quot;for&quot;: &quot;htmlFor&quot;,
		&quot;class&quot;: &quot;className&quot;,
		maxlength: &quot;maxLength&quot;,
		cellspacing: &quot;cellSpacing&quot;,
		cellpadding: &quot;cellPadding&quot;,
		rowspan: &quot;rowSpan&quot;,
		colspan: &quot;colSpan&quot;,
		usemap: &quot;useMap&quot;,
		frameborder: &quot;frameBorder&quot;,
		contenteditable: &quot;contentEditable&quot;
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don&#x27;t get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks &amp;&amp; &quot;set&quot; in hooks &amp;&amp; (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				return ( elem[ name ] = value );
			}

		} else {
			if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn&#x27;t always return the correct value when it hasn&#x27;t been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				var attributeNode = elem.getAttributeNode(&quot;tabindex&quot;);

				return attributeNode &amp;&amp; attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) &amp;&amp; elem.href ?
						0 :
						undefined;
			}
		}
	}
});

// Hook for boolean attributes
boolHook = {
	get: function( elem, name ) {
		// Align boolean attributes with corresponding properties
		// Fall back to attribute presence where some booleans are not supported
		var attrNode,
			property = jQuery.prop( elem, name );
		return property === true || typeof property !== &quot;boolean&quot; &amp;&amp; ( attrNode = elem.getAttributeNode(name) ) &amp;&amp; attrNode.nodeValue !== false ?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		var propName;
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			// value is true since we know at this point it&#x27;s type boolean and not false
			// Set boolean attributes to the same name and set the DOM property
			propName = jQuery.propFix[ name ] || name;
			if ( propName in elem ) {
				// Only set the IDL specifically if it already exists on the element
				elem[ propName ] = true;
			}

			elem.setAttribute( name, name.toLowerCase() );
		}
		return name;
	}
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	fixSpecified = {
		name: true,
		id: true,
		coords: true
	};

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret;
			ret = elem.getAttributeNode( name );
			return ret &amp;&amp; ( fixSpecified[ name ] ? ret.value !== &quot;&quot; : ret.specified ) ?
				ret.value :
				undefined;
		},
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				ret = document.createAttribute( name );
				elem.setAttributeNode( ret );
			}
			return ( ret.value = value + &quot;&quot; );
		}
	};

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ &quot;width&quot;, &quot;height&quot; ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			set: function( elem, value ) {
				if ( value === &quot;&quot; ) {
					elem.setAttribute( name, &quot;auto&quot; );
					return value;
				}
			}
		});
	});

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		get: nodeHook.get,
		set: function( elem, value, name ) {
			if ( value === &quot;&quot; ) {
				value = &quot;false&quot;;
			}
			nodeHook.set( elem, value, name );
		}
	};
}


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
	jQuery.each([ &quot;href&quot;, &quot;src&quot;, &quot;width&quot;, &quot;height&quot; ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret === null ? undefined : ret;
			}
		});
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Normalize to lowercase since IE uppercases css property names
			return elem.style.cssText.toLowerCase() || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = value + &quot;&quot; );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent&#x27;s selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	});
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = &quot;encoding&quot;;
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
	jQuery.each([ &quot;radio&quot;, &quot;checkbox&quot; ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
				// Handle the case where in Webkit &quot;&quot; is returned instead of &quot;on&quot; if a value isn&#x27;t specified
				return elem.getAttribute(&quot;value&quot;) === null ? &quot;on&quot; : elem.value;
			}
		};
	});
}
jQuery.each([ &quot;radio&quot;, &quot;checkbox&quot; ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) &gt;= 0 );
			}
		}
	});
});
var rformElems = /^(?:textarea|input|select)$/i,
	rtypenamespace = /^([^\.]*|)(?:\.(.+)|)$/,
	rhoverHack = /(?:^|\s)hover(\.\S+|)\b/,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	hoverHack = function( events ) {
		return jQuery.event.special.hover ? events : events.replace( rhoverHack, &quot;mouseenter$1 mouseleave$1&quot; );
	};

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards&#x27; addEvent library for many of the ideas.
 */
jQuery.event = {

	add: function( elem, types, handler, data, selector ) {

		var elemData, eventHandle, events,
			t, tns, type, namespaces, handleObj,
			handleObjIn, handlers, special;

		// Don&#x27;t attach events to noData or text/comment nodes (allow plain objects tho)
		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element&#x27;s event structure and main handler, if this is the first
		events = elemData.events;
		if ( !events ) {
			elemData.events = events = {};
		}
		eventHandle = elemData.handle;
		if ( !eventHandle ) {
			elemData.handle = eventHandle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== &quot;undefined&quot; &amp;&amp; (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		// jQuery(...).bind(&quot;mouseover mouseout&quot;, fn);
		types = jQuery.trim( hoverHack(types) ).split( &quot; &quot; );
		for ( t = 0; t &lt; types.length; t++ ) {

			tns = rtypenamespace.exec( types[t] ) || [];
			type = tns[1];
			namespaces = ( tns[2] || &quot;&quot; ).split( &quot;.&quot; ).sort();

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: tns[1],
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector &amp;&amp; jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(&quot;.&quot;)
			}, handleObjIn );

			// Init the event handler queue if we&#x27;re the first
			handlers = events[ type ];
			if ( !handlers ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( &quot;on&quot; + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element&#x27;s handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	global: {},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var t, tns, type, origType, namespaces, origCount,
			j, events, special, eventType, handleObj,
			elemData = jQuery.hasData( elem ) &amp;&amp; jQuery._data( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = jQuery.trim( hoverHack( types || &quot;&quot; ) ).split(&quot; &quot;);
		for ( t = 0; t &lt; types.length; t++ ) {
			tns = rtypenamespace.exec( types[t] ) || [];
			type = origType = tns[1];
			namespaces = tns[2];

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector? special.delegateType : special.bindType ) || type;
			eventType = events[ type ] || [];
			origCount = eventType.length;
			namespaces = namespaces ? new RegExp(&quot;(^|\\.)&quot; + namespaces.split(&quot;.&quot;).sort().join(&quot;\\.(?:.*\\.|)&quot;) + &quot;(\\.|$)&quot;) : null;

			// Remove matching events
			for ( j = 0; j &lt; eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &amp;&amp;
					 ( !handler || handler.guid === handleObj.guid ) &amp;&amp;
					 ( !namespaces || namespaces.test( handleObj.namespace ) ) &amp;&amp;
					 ( !selector || selector === handleObj.selector || selector === &quot;**&quot; &amp;&amp; handleObj.selector ) ) {
					eventType.splice( j--, 1 );

					if ( handleObj.selector ) {
						eventType.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( eventType.length === 0 &amp;&amp; origCount !== eventType.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it&#x27;s no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery.removeData( elem, &quot;events&quot;, true );
		}
	},

	// Events that are safe to short-circuit if no handlers are attached.
	// Native DOM events should not be added, they may have inline handlers.
	customEvent: {
		&quot;getData&quot;: true,
		&quot;setData&quot;: true,
		&quot;changeData&quot;: true
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		// Don&#x27;t do events on text and comment nodes
		if ( elem &amp;&amp; (elem.nodeType === 3 || elem.nodeType === 8) ) {
			return;
		}

		// Event object or event type
		var cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType,
			type = event.type || event,
			namespaces = [];

		// focus/blur morphs to focusin/out; ensure we&#x27;re not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( &quot;!&quot; ) &gt;= 0 ) {
			// Exclusive events trigger only for the exact event (no namespaces)
			type = type.slice(0, -1);
			exclusive = true;
		}

		if ( type.indexOf( &quot;.&quot; ) &gt;= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(&quot;.&quot;);
			type = namespaces.shift();
			namespaces.sort();
		}

		if ( (!elem || jQuery.event.customEvent[ type ]) &amp;&amp; !jQuery.event.global[ type ] ) {
			// No jQuery handlers for this event type, and it can&#x27;t have inline handlers
			return;
		}

		// Caller can pass in an Event, Object, or just an event type string
		event = typeof event === &quot;object&quot; ?
			// jQuery.Event object
			event[ jQuery.expando ] ? event :
			// Object literal
			new jQuery.Event( type, event ) :
			// Just the event type (string)
			new jQuery.Event( type );

		event.type = type;
		event.isTrigger = true;
		event.exclusive = exclusive;
		event.namespace = namespaces.join( &quot;.&quot; );
		event.namespace_re = event.namespace? new RegExp(&quot;(^|\\.)&quot; + namespaces.join(&quot;\\.(?:.*\\.|)&quot;) + &quot;(\\.|$)&quot;) : null;
		ontype = type.indexOf( &quot;:&quot; ) &lt; 0 ? &quot;on&quot; + type : &quot;&quot;;

		// Handle a global trigger
		if ( !elem ) {

			// TODO: Stop taunting the data cache; remove global events and always attach to document
			cache = jQuery.cache;
			for ( i in cache ) {
				if ( cache[ i ].events &amp;&amp; cache[ i ].events[ type ] ) {
					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
				}
			}
			return;
		}

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data != null ? jQuery.makeArray( data ) : [];
		data.unshift( event );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( special.trigger &amp;&amp; special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		eventPath = [[ elem, special.bindType || type ]];
		if ( !onlyHandlers &amp;&amp; !special.noBubble &amp;&amp; !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
			for ( old = elem; cur; cur = cur.parentNode ) {
				eventPath.push([ cur, bubbleType ]);
				old = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( old === (elem.ownerDocument || document) ) {
				eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
			}
		}

		// Fire handlers on the event path
		for ( i = 0; i &lt; eventPath.length &amp;&amp; !event.isPropagationStopped(); i++ ) {

			cur = eventPath[i][0];
			event.type = eventPath[i][1];

			handle = ( jQuery._data( cur, &quot;events&quot; ) || {} )[ event.type ] &amp;&amp; jQuery._data( cur, &quot;handle&quot; );
			if ( handle ) {
				handle.apply( cur, data );
			}
			// Note that this is a bare JS function and not a jQuery handler
			handle = ontype &amp;&amp; cur[ ontype ];
			if ( handle &amp;&amp; jQuery.acceptData( cur ) &amp;&amp; handle.apply &amp;&amp; handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers &amp;&amp; !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &amp;&amp;
				!(type === &quot;click&quot; &amp;&amp; jQuery.nodeName( elem, &quot;a&quot; )) &amp;&amp; jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can&#x27;t use an .isFunction() check here because IE6/7 fails that test.
				// Don&#x27;t do default actions on window, that&#x27;s where global variables be (#6170)
				// IE&lt;9 dies on focus/blur to hidden element (#1486)
				if ( ontype &amp;&amp; elem[ type ] &amp;&amp; ((type !== &quot;focus&quot; &amp;&amp; type !== &quot;blur&quot;) || event.target.offsetWidth !== 0) &amp;&amp; !jQuery.isWindow( elem ) ) {

					// Don&#x27;t re-trigger an onFOO event when we call its FOO() method
					old = elem[ ontype ];

					if ( old ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( old ) {
						elem[ ontype ] = old;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event || window.event );

		var i, j, cur, ret, selMatch, matched, matches, handleObj, sel, related,
			handlers = ( (jQuery._data( this, &quot;events&quot; ) || {} )[ event.type ] || []),
			delegateCount = handlers.delegateCount,
			args = core_slice.call( arguments ),
			run_all = !event.exclusive &amp;&amp; !event.namespace,
			special = jQuery.event.special[ event.type ] || {},
			handlerQueue = [];

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch &amp;&amp; special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers that should run if there are delegated events
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount &amp;&amp; !(event.button &amp;&amp; event.type === &quot;click&quot;) ) {

			for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {

				// Don&#x27;t process clicks (ONLY) on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== &quot;click&quot; ) {
					selMatch = {};
					matches = [];
					for ( i = 0; i &lt; delegateCount; i++ ) {
						handleObj = handlers[ i ];
						sel = handleObj.selector;

						if ( selMatch[ sel ] === undefined ) {
							selMatch[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) &gt;= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( selMatch[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, matches: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( handlers.length &gt; delegateCount ) {
			handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
		}

		// Run delegates first; they may want to stop propagation beneath us
		for ( i = 0; i &lt; handlerQueue.length &amp;&amp; !event.isPropagationStopped(); i++ ) {
			matched = handlerQueue[ i ];
			event.currentTarget = matched.elem;

			for ( j = 0; j &lt; matched.matches.length &amp;&amp; !event.isImmediatePropagationStopped(); j++ ) {
				handleObj = matched.matches[ j ];

				// Triggered event must either 1) be non-exclusive and have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( run_all || (!event.namespace &amp;&amp; !handleObj.namespace) || event.namespace_re &amp;&amp; event.namespace_re.test( handleObj.namespace ) ) {

					event.data = handleObj.data;
					event.handleObj = handleObj;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
	props: &quot;attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which&quot;.split(&quot; &quot;),

	fixHooks: {},

	keyHooks: {
		props: &quot;char charCode key keyCode&quot;.split(&quot; &quot;),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: &quot;button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement&quot;.split(&quot; &quot;),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null &amp;&amp; original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc &amp;&amp; doc.scrollLeft || body &amp;&amp; body.scrollLeft || 0 ) - ( doc &amp;&amp; doc.clientLeft || body &amp;&amp; body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc &amp;&amp; doc.scrollTop  || body &amp;&amp; body.scrollTop  || 0 ) - ( doc &amp;&amp; doc.clientTop  || body &amp;&amp; body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget &amp;&amp; fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don&#x27;t use it
			if ( !event.which &amp;&amp; button !== undefined ) {
				event.which = ( button &amp; 1 ? 1 : ( button &amp; 2 ? 3 : ( button &amp; 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop,
			originalEvent = event,
			fixHook = jQuery.event.fixHooks[ event.type ] || {},
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = jQuery.Event( originalEvent );

		for ( i = copy.length; i; ) {
			prop = copy[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary (#1925, IE 6/7/8 &amp; Safari2)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Target should not be a text node (#504, Safari)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// For mouse/key events, metaKey==false if it&#x27;s undefined (#3368, #11328; IE6/7/8)
		event.metaKey = !!event.metaKey;

		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},

		focus: {
			delegateType: &quot;focusin&quot;
		},
		blur: {
			delegateType: &quot;focusout&quot;
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				// We only want to do this special case on windows
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor&#x27;s stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{ type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

// Some plugins are using, but it&#x27;s undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
jQuery.event.handle = jQuery.event.dispatch;

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		var name = &quot;on&quot; + type;

		if ( elem.detachEvent ) {

			// #8545, #7054, preventing memory leaks for custom events in IE6-8 
			// detachEvent needed property on element, by name of that event, to properly expose it to GC
			if ( typeof elem[ name ] === &quot;undefined&quot; ) {
				elem[ name ] = null;
			}

			elem.detachEvent( name, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the &#x27;new&#x27; keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src &amp;&amp; src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault &amp;&amp; src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn&#x27;t have one
	this.timeStamp = src &amp;&amp; src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}

		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// otherwise set the returnValue property of the original event to false (IE)
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: &quot;mouseover&quot;,
	mouseleave: &quot;mouseout&quot;
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj,
				selector = handleObj.selector;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target &amp;&amp; !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, &quot;form&quot; ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, &quot;click._submit keypress._submit&quot;, function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, &quot;input&quot; ) || jQuery.nodeName( elem, &quot;button&quot; ) ? elem.form : undefined;
				if ( form &amp;&amp; !jQuery._data( form, &quot;_submit_attached&quot; ) ) {
					jQuery.event.add( form, &quot;submit._submit&quot;, function( event ) {
						event._submit_bubble = true;
					});
					jQuery._data( form, &quot;_submit_attached&quot;, true );
				}
			});
			// return undefined since we don&#x27;t need an event listener
		},

		postDispatch: function( event ) {
			// If form was submitted by the user, bubble the event up the tree
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode &amp;&amp; !event.isTrigger ) {
					jQuery.event.simulate( &quot;submit&quot;, this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, &quot;form&quot; ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, &quot;._submit&quot; );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn&#x27;t fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === &quot;checkbox&quot; || this.type === &quot;radio&quot; ) {
					jQuery.event.add( this, &quot;propertychange._change&quot;, function( event ) {
						if ( event.originalEvent.propertyName === &quot;checked&quot; ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, &quot;click._change&quot;, function( event ) {
						if ( this._just_changed &amp;&amp; !event.isTrigger ) {
							this._just_changed = false;
						}
						// Allow triggered, simulated change events (#11500)
						jQuery.event.simulate( &quot;change&quot;, this, event, true );
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, &quot;beforeactivate._change&quot;, function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) &amp;&amp; !jQuery._data( elem, &quot;_change_attached&quot; ) ) {
					jQuery.event.add( elem, &quot;change._change&quot;, function( event ) {
						if ( this.parentNode &amp;&amp; !event.isSimulated &amp;&amp; !event.isTrigger ) {
							jQuery.event.simulate( &quot;change&quot;, this.parentNode, event, true );
						}
					});
					jQuery._data( elem, &quot;_change_attached&quot;, true );
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== &quot;radio&quot; &amp;&amp; elem.type !== &quot;checkbox&quot;) ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, &quot;._change&quot; );

			return !rformElems.test( this.nodeName );
		}
	};
}

// Create &quot;bubbling&quot; focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: &quot;focusin&quot;, blur: &quot;focusout&quot; }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === &quot;object&quot; ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== &quot;string&quot; ) { // &amp;&amp; selector != null
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null &amp;&amp; fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === &quot;string&quot; ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types &amp;&amp; types.preventDefault &amp;&amp; types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + &quot;.&quot; + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === &quot;object&quot; ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === &quot;function&quot; ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	live: function( types, data, fn ) {
		jQuery( this.context ).on( types, this.selector, data, fn );
		return this;
	},
	die: function( types, fn ) {
		jQuery( this.context ).off( types, this.selector || &quot;**&quot;, fn );
		return this;
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, &quot;**&quot; ) : this.off( types, selector || &quot;**&quot;, fn );
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			return jQuery.event.trigger( type, data, this[0], true );
		}
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function( event ) {
				// Figure out which function to execute
				var lastToggle = ( jQuery._data( this, &quot;lastToggle&quot; + fn.guid ) || 0 ) % i;
				jQuery._data( this, &quot;lastToggle&quot; + fn.guid, lastToggle + 1 );

				// Make sure that clicks stop
				event.preventDefault();

				// and execute the function
				return args[ lastToggle ].apply( this, arguments ) || false;
			};

		// link all the functions, so any of them can unbind this click handler
		toggler.guid = guid;
		while ( i &lt; args.length ) {
			args[ i++ ].guid = guid;
		}

		return this.click( toggler );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

jQuery.each( (&quot;blur focus focusin focusout load resize scroll unload click dblclick &quot; +
	&quot;mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave &quot; +
	&quot;change select submit keydown keypress keyup error contextmenu&quot;).split(&quot; &quot;), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length &gt; 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};

	if ( rkeyEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
	}

	if ( rmouseEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
	}
});
/*!
 * Sizzle CSS Selector Engine
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license
 * http://sizzlejs.com/
 */
(function( window, undefined ) {

var cachedruns,
	assertGetIdNotName,
	Expr,
	getText,
	isXML,
	contains,
	compile,
	sortOrder,
	hasDuplicate,
	outermostContext,

	baseHasDuplicate = true,
	strundefined = &quot;undefined&quot;,

	expando = ( &quot;sizcache&quot; + Math.random() ).replace( &quot;.&quot;, &quot;&quot; ),

	Token = String,
	document = window.document,
	docElem = document.documentElement,
	dirruns = 0,
	done = 0,
	pop = [].pop,
	push = [].push,
	slice = [].slice,
	// Use a stripped-down indexOf if a native one is unavailable
	indexOf = [].indexOf || function( elem ) {
		var i = 0,
			len = this.length;
		for ( ; i &lt; len; i++ ) {
			if ( this[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	// Augment a function for special use by Sizzle
	markFunction = function( fn, value ) {
		fn[ expando ] = value == null || value;
		return fn;
	},

	createCache = function() {
		var cache = {},
			keys = [];

		return markFunction(function( key, value ) {
			// Only keep the most recent entries
			if ( keys.push( key ) &gt; Expr.cacheLength ) {
				delete cache[ keys.shift() ];
			}

			return (cache[ key ] = value);
		}, cache );
	},

	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),

	// Regex

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = &quot;[\\x20\\t\\r\\n\\f]&quot;,
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = &quot;(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+&quot;,

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier (http://www.w3.org/TR/css3-selectors/#attribute-selectors)
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( &quot;w&quot;, &quot;w#&quot; ),

	// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
	operators = &quot;([*^$|!~]?=)&quot;,
	attributes = &quot;\\[&quot; + whitespace + &quot;*(&quot; + characterEncoding + &quot;)&quot; + whitespace +
		&quot;*(?:&quot; + operators + whitespace + &quot;*(?:([&#x27;\&quot;])((?:\\\\.|[^\\\\])*?)\\3|(&quot; + identifier + &quot;)|)|)&quot; + whitespace + &quot;*\\]&quot;,

	// Prefer arguments not in parens/brackets,
	//   then attribute selectors and non-pseudos (denoted by :),
	//   then anything else
	// These preferences are here to reduce the number of selectors
	//   needing tokenize in the PSEUDO preFilter
	pseudos = &quot;:(&quot; + characterEncoding + &quot;)(?:\\((?:([&#x27;\&quot;])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:&quot; + attributes + &quot;)|[^:]|\\\\.)*|.*))\\)|)&quot;,

	// For matchExpr.POS and matchExpr.needsContext
	pos = &quot;:(even|odd|eq|gt|lt|nth|first|last)(?:\\(&quot; + whitespace +
		&quot;*((?:-\\d)?\\d*)&quot; + whitespace + &quot;*\\)|)(?=[^-]|$)&quot;,

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp( &quot;^&quot; + whitespace + &quot;+|((?:^|[^\\\\])(?:\\\\.)*)&quot; + whitespace + &quot;+$&quot;, &quot;g&quot; ),

	rcomma = new RegExp( &quot;^&quot; + whitespace + &quot;*,&quot; + whitespace + &quot;*&quot; ),
	rcombinators = new RegExp( &quot;^&quot; + whitespace + &quot;*([\\x20\\t\\r\\n\\f&gt;+~])&quot; + whitespace + &quot;*&quot; ),
	rpseudo = new RegExp( pseudos ),

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,

	rnot = /^:not/,
	rsibling = /[\x20\t\r\n\f]*[+~]/,
	rendsWithNot = /:not\($/,

	rheader = /h\d/i,
	rinputs = /input|select|textarea|button/i,

	rbackslash = /\\(?!\\)/g,

	matchExpr = {
		&quot;ID&quot;: new RegExp( &quot;^#(&quot; + characterEncoding + &quot;)&quot; ),
		&quot;CLASS&quot;: new RegExp( &quot;^\\.(&quot; + characterEncoding + &quot;)&quot; ),
		&quot;NAME&quot;: new RegExp( &quot;^\\[name=[&#x27;\&quot;]?(&quot; + characterEncoding + &quot;)[&#x27;\&quot;]?\\]&quot; ),
		&quot;TAG&quot;: new RegExp( &quot;^(&quot; + characterEncoding.replace( &quot;w&quot;, &quot;w*&quot; ) + &quot;)&quot; ),
		&quot;ATTR&quot;: new RegExp( &quot;^&quot; + attributes ),
		&quot;PSEUDO&quot;: new RegExp( &quot;^&quot; + pseudos ),
		&quot;POS&quot;: new RegExp( pos, &quot;i&quot; ),
		&quot;CHILD&quot;: new RegExp( &quot;^:(only|nth|first|last)-child(?:\\(&quot; + whitespace +
			&quot;*(even|odd|(([+-]|)(\\d*)n|)&quot; + whitespace + &quot;*(?:([+-]|)&quot; + whitespace +
			&quot;*(\\d+)|))&quot; + whitespace + &quot;*\\)|)&quot;, &quot;i&quot; ),
		// For use in libraries implementing .is()
		&quot;needsContext&quot;: new RegExp( &quot;^&quot; + whitespace + &quot;*[&gt;+~]|&quot; + pos, &quot;i&quot; )
	},

	// Support

	// Used for testing something on an element
	assert = function( fn ) {
		var div = document.createElement(&quot;div&quot;);

		try {
			return fn( div );
		} catch (e) {
			return false;
		} finally {
			// release memory in IE
			div = null;
		}
	},

	// Check if getElementsByTagName(&quot;*&quot;) returns only elements
	assertTagNameNoComments = assert(function( div ) {
		div.appendChild( document.createComment(&quot;&quot;) );
		return !div.getElementsByTagName(&quot;*&quot;).length;
	}),

	// Check if getAttribute returns normalized href attributes
	assertHrefNotNormalized = assert(function( div ) {
		div.innerHTML = &quot;&lt;a href=&#x27;#&#x27;&gt;&lt;/a&gt;&quot;;
		return div.firstChild &amp;&amp; typeof div.firstChild.getAttribute !== strundefined &amp;&amp;
			div.firstChild.getAttribute(&quot;href&quot;) === &quot;#&quot;;
	}),

	// Check if attributes should be retrieved by attribute nodes
	assertAttributes = assert(function( div ) {
		div.innerHTML = &quot;&lt;select&gt;&lt;/select&gt;&quot;;
		var type = typeof div.lastChild.getAttribute(&quot;multiple&quot;);
		// IE8 returns a string for some attributes even when not present
		return type !== &quot;boolean&quot; &amp;&amp; type !== &quot;string&quot;;
	}),

	// Check if getElementsByClassName can be trusted
	assertUsableClassName = assert(function( div ) {
		// Opera can&#x27;t find a second classname (in 9.6)
		div.innerHTML = &quot;&lt;div class=&#x27;hidden e&#x27;&gt;&lt;/div&gt;&lt;div class=&#x27;hidden&#x27;&gt;&lt;/div&gt;&quot;;
		if ( !div.getElementsByClassName || !div.getElementsByClassName(&quot;e&quot;).length ) {
			return false;
		}

		// Safari 3.2 caches class attributes and doesn&#x27;t catch changes
		div.lastChild.className = &quot;e&quot;;
		return div.getElementsByClassName(&quot;e&quot;).length === 2;
	}),

	// Check if getElementById returns elements by name
	// Check if getElementsByName privileges form controls or returns elements by ID
	assertUsableName = assert(function( div ) {
		// Inject content
		div.id = expando + 0;
		div.innerHTML = &quot;&lt;a name=&#x27;&quot; + expando + &quot;&#x27;&gt;&lt;/a&gt;&lt;div name=&#x27;&quot; + expando + &quot;&#x27;&gt;&lt;/div&gt;&quot;;
		docElem.insertBefore( div, docElem.firstChild );

		// Test
		var pass = document.getElementsByName &amp;&amp;
			// buggy browsers will return fewer than the correct 2
			document.getElementsByName( expando ).length === 2 +
			// buggy browsers will return more than the correct 0
			document.getElementsByName( expando + 0 ).length;
		assertGetIdNotName = !document.getElementById( expando );

		// Cleanup
		docElem.removeChild( div );

		return pass;
	});

// If slice is not available, provide a backup
try {
	slice.call( docElem.childNodes, 0 )[0].nodeType;
} catch ( e ) {
	slice = function( i ) {
		var elem,
			results = [];
		for ( ; (elem = this[i]); i++ ) {
			results.push( elem );
		}
		return results;
	};
}

function Sizzle( selector, context, results, seed ) {
	results = results || [];
	context = context || document;
	var match, elem, xml, m,
		nodeType = context.nodeType;

	if ( !selector || typeof selector !== &quot;string&quot; ) {
		return results;
	}

	if ( nodeType !== 1 &amp;&amp; nodeType !== 9 ) {
		return [];
	}

	xml = isXML( context );

	if ( !xml &amp;&amp; !seed ) {
		if ( (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle(&quot;#ID&quot;)
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem &amp;&amp; elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument &amp;&amp; (elem = context.ownerDocument.getElementById( m )) &amp;&amp;
						contains( context, elem ) &amp;&amp; elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle(&quot;TAG&quot;)
			} else if ( match[2] ) {
				push.apply( results, slice.call(context.getElementsByTagName( selector ), 0) );
				return results;

			// Speed-up: Sizzle(&quot;.CLASS&quot;)
			} else if ( (m = match[3]) &amp;&amp; assertUsableClassName &amp;&amp; context.getElementsByClassName ) {
				push.apply( results, slice.call(context.getElementsByClassName( m ), 0) );
				return results;
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, &quot;$1&quot; ), context, results, seed, xml );
}

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	return Sizzle( expr, null, null, [ elem ] ).length &gt; 0;
};

// Returns a function to use in pseudos for input types
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === &quot;input&quot; &amp;&amp; elem.type === type;
	};
}

// Returns a function to use in pseudos for buttons
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === &quot;input&quot; || name === &quot;button&quot;) &amp;&amp; elem.type === type;
	};
}

// Returns a function to use in pseudos for positionals
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = &quot;&quot;,
		i = 0,
		nodeType = elem.nodeType;

	if ( nodeType ) {
		if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (see #11153)
			if ( typeof elem.textContent === &quot;string&quot; ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes
	} else {

		// If no nodeType, this is expected to be an array
		for ( ; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	}
	return ret;
};

isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn&#x27;t yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem &amp;&amp; (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== &quot;HTML&quot; : false;
};

// Element contains another
contains = Sizzle.contains = docElem.contains ?
	function( a, b ) {
		var adown = a.nodeType === 9 ? a.documentElement : a,
			bup = b &amp;&amp; b.parentNode;
		return a === bup || !!( bup &amp;&amp; bup.nodeType === 1 &amp;&amp; adown.contains &amp;&amp; adown.contains(bup) );
	} :
	docElem.compareDocumentPosition ?
	function( a, b ) {
		return b &amp;&amp; !!( a.compareDocumentPosition( b ) &amp; 16 );
	} :
	function( a, b ) {
		while ( (b = b.parentNode) ) {
			if ( b === a ) {
				return true;
			}
		}
		return false;
	};

Sizzle.attr = function( elem, name ) {
	var val,
		xml = isXML( elem );

	if ( !xml ) {
		name = name.toLowerCase();
	}
	if ( (val = Expr.attrHandle[ name ]) ) {
		return val( elem );
	}
	if ( xml || assertAttributes ) {
		return elem.getAttribute( name );
	}
	val = elem.getAttributeNode( name );
	return val ?
		typeof elem[ name ] === &quot;boolean&quot; ?
			elem[ name ] ? name : null :
			val.specified ? val.value : null :
		null;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	// IE6/7 return a modified href
	attrHandle: assertHrefNotNormalized ?
		{} :
		{
			&quot;href&quot;: function( elem ) {
				return elem.getAttribute( &quot;href&quot;, 2 );
			},
			&quot;type&quot;: function( elem ) {
				return elem.getAttribute(&quot;type&quot;);
			}
		},

	find: {
		&quot;ID&quot;: assertGetIdNotName ?
			function( id, context, xml ) {
				if ( typeof context.getElementById !== strundefined &amp;&amp; !xml ) {
					var m = context.getElementById( id );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					return m &amp;&amp; m.parentNode ? [m] : [];
				}
			} :
			function( id, context, xml ) {
				if ( typeof context.getElementById !== strundefined &amp;&amp; !xml ) {
					var m = context.getElementById( id );

					return m ?
						m.id === id || typeof m.getAttributeNode !== strundefined &amp;&amp; m.getAttributeNode(&quot;id&quot;).value === id ?
							[m] :
							undefined :
						[];
				}
			},

		&quot;TAG&quot;: assertTagNameNoComments ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== strundefined ) {
					return context.getElementsByTagName( tag );
				}
			} :
			function( tag, context ) {
				var results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === &quot;*&quot; ) {
					var elem,
						tmp = [],
						i = 0;

					for ( ; (elem = results[i]); i++ ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			},

		&quot;NAME&quot;: assertUsableName &amp;&amp; function( tag, context ) {
			if ( typeof context.getElementsByName !== strundefined ) {
				return context.getElementsByName( name );
			}
		},

		&quot;CLASS&quot;: assertUsableClassName &amp;&amp; function( className, context, xml ) {
			if ( typeof context.getElementsByClassName !== strundefined &amp;&amp; !xml ) {
				return context.getElementsByClassName( className );
			}
		}
	},

	relative: {
		&quot;&gt;&quot;: { dir: &quot;parentNode&quot;, first: true },
		&quot; &quot;: { dir: &quot;parentNode&quot; },
		&quot;+&quot;: { dir: &quot;previousSibling&quot;, first: true },
		&quot;~&quot;: { dir: &quot;previousSibling&quot; }
	},

	preFilter: {
		&quot;ATTR&quot;: function( match ) {
			match[1] = match[1].replace( rbackslash, &quot;&quot; );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[4] || match[5] || &quot;&quot; ).replace( rbackslash, &quot;&quot; );

			if ( match[2] === &quot;~=&quot; ) {
				match[3] = &quot; &quot; + match[3] + &quot; &quot;;
			}

			return match.slice( 0, 4 );
		},

		&quot;CHILD&quot;: function( match ) {
			/* matches from matchExpr[&quot;CHILD&quot;]
				1 type (only|nth|...)
				2 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				3 xn-component of xn+y argument ([+-]?\d*n|)
				4 sign of xn-component
				5 x of xn-component
				6 sign of y-component
				7 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1] === &quot;nth&quot; ) {
				// nth-child requires argument
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[3] = +( match[3] ? match[4] + (match[5] || 1) : 2 * ( match[2] === &quot;even&quot; || match[2] === &quot;odd&quot; ) );
				match[4] = +( ( match[6] + match[7] ) || match[2] === &quot;odd&quot; );

			// other types prohibit arguments
			} else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		&quot;PSEUDO&quot;: function( match ) {
			var unquoted, excess;
			if ( matchExpr[&quot;CHILD&quot;].test( match[0] ) ) {
				return null;
			}

			if ( match[3] ) {
				match[2] = match[3];
			} else if ( (unquoted = match[4]) ) {
				// Only check arguments that contain a pseudo
				if ( rpseudo.test(unquoted) &amp;&amp;
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &amp;&amp;
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( &quot;)&quot;, unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					unquoted = unquoted.slice( 0, excess );
					match[0] = match[0].slice( 0, excess );
				}
				match[2] = unquoted;
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {
		&quot;ID&quot;: assertGetIdNotName ?
			function( id ) {
				id = id.replace( rbackslash, &quot;&quot; );
				return function( elem ) {
					return elem.getAttribute(&quot;id&quot;) === id;
				};
			} :
			function( id ) {
				id = id.replace( rbackslash, &quot;&quot; );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== strundefined &amp;&amp; elem.getAttributeNode(&quot;id&quot;);
					return node &amp;&amp; node.value === id;
				};
			},

		&quot;TAG&quot;: function( nodeName ) {
			if ( nodeName === &quot;*&quot; ) {
				return function() { return true; };
			}
			nodeName = nodeName.replace( rbackslash, &quot;&quot; ).toLowerCase();

			return function( elem ) {
				return elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === nodeName;
			};
		},

		&quot;CLASS&quot;: function( className ) {
			var pattern = classCache[ expando ][ className ];
			if ( !pattern ) {
				pattern = classCache( className, new RegExp(&quot;(^|&quot; + whitespace + &quot;)&quot; + className + &quot;(&quot; + whitespace + &quot;|$)&quot;) );
			}
			return function( elem ) {
				return pattern.test( elem.className || (typeof elem.getAttribute !== strundefined &amp;&amp; elem.getAttribute(&quot;class&quot;)) || &quot;&quot; );
			};
		},

		&quot;ATTR&quot;: function( name, operator, check ) {
			return function( elem, context ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === &quot;!=&quot;;
				}
				if ( !operator ) {
					return true;
				}

				result += &quot;&quot;;

				return operator === &quot;=&quot; ? result === check :
					operator === &quot;!=&quot; ? result !== check :
					operator === &quot;^=&quot; ? check &amp;&amp; result.indexOf( check ) === 0 :
					operator === &quot;*=&quot; ? check &amp;&amp; result.indexOf( check ) &gt; -1 :
					operator === &quot;$=&quot; ? check &amp;&amp; result.substr( result.length - check.length ) === check :
					operator === &quot;~=&quot; ? ( &quot; &quot; + result + &quot; &quot; ).indexOf( check ) &gt; -1 :
					operator === &quot;|=&quot; ? result === check || result.substr( 0, check.length + 1 ) === check + &quot;-&quot; :
					false;
			};
		},

		&quot;CHILD&quot;: function( type, argument, first, last ) {

			if ( type === &quot;nth&quot; ) {
				return function( elem ) {
					var node, diff,
						parent = elem.parentNode;

					if ( first === 1 &amp;&amp; last === 0 ) {
						return true;
					}

					if ( parent ) {
						diff = 0;
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								diff++;
								if ( elem === node ) {
									break;
								}
							}
						}
					}

					// Incorporate the offset (or cast to NaN), then check against cycle size
					diff -= last;
					return diff === first || ( diff % first === 0 &amp;&amp; diff / first &gt;= 0 );
				};
			}

			return function( elem ) {
				var node = elem;

				switch ( type ) {
					case &quot;only&quot;:
					case &quot;first&quot;:
						while ( (node = node.previousSibling) ) {
							if ( node.nodeType === 1 ) {
								return false;
							}
						}

						if ( type === &quot;first&quot; ) {
							return true;
						}

						node = elem;

						/* falls through */
					case &quot;last&quot;:
						while ( (node = node.nextSibling) ) {
							if ( node.nodeType === 1 ) {
								return false;
							}
						}

						return true;
				}
			};
		},

		&quot;PSEUDO&quot;: function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( &quot;unsupported pseudo: &quot; + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length &gt; 1 ) {
				args = [ pseudo, pseudo, &quot;&quot;, argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		&quot;not&quot;: markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, &quot;$1&quot; ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by &#x60;matcher&#x60;
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					return !results.pop();
				};
		}),

		&quot;has&quot;: markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length &gt; 0;
			};
		}),

		&quot;contains&quot;: markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) &gt; -1;
			};
		}),

		&quot;enabled&quot;: function( elem ) {
			return elem.disabled === false;
		},

		&quot;disabled&quot;: function( elem ) {
			return elem.disabled === true;
		},

		&quot;checked&quot;: function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === &quot;input&quot; &amp;&amp; !!elem.checked) || (nodeName === &quot;option&quot; &amp;&amp; !!elem.selected);
		},

		&quot;selected&quot;: function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		&quot;parent&quot;: function( elem ) {
			return !Expr.pseudos[&quot;empty&quot;]( elem );
		},

		&quot;empty&quot;: function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
			//   not comment, processing instructions, or others
			// Thanks to Diego Perini for the nodeName shortcut
			//   Greater than &quot;@&quot; means alpha characters (specifically not starting with &quot;#&quot; or &quot;?&quot;)
			var nodeType;
			elem = elem.firstChild;
			while ( elem ) {
				if ( elem.nodeName &gt; &quot;@&quot; || (nodeType = elem.nodeType) === 3 || nodeType === 4 ) {
					return false;
				}
				elem = elem.nextSibling;
			}
			return true;
		},

		&quot;header&quot;: function( elem ) {
			return rheader.test( elem.nodeName );
		},

		&quot;text&quot;: function( elem ) {
			var type, attr;
			// IE6 and 7 will map elem.type to &#x27;text&#x27; for new HTML5 types (search, etc)
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === &quot;input&quot; &amp;&amp;
				(type = elem.type) === &quot;text&quot; &amp;&amp;
				( (attr = elem.getAttribute(&quot;type&quot;)) == null || attr.toLowerCase() === type );
		},

		// Input types
		&quot;radio&quot;: createInputPseudo(&quot;radio&quot;),
		&quot;checkbox&quot;: createInputPseudo(&quot;checkbox&quot;),
		&quot;file&quot;: createInputPseudo(&quot;file&quot;),
		&quot;password&quot;: createInputPseudo(&quot;password&quot;),
		&quot;image&quot;: createInputPseudo(&quot;image&quot;),

		&quot;submit&quot;: createButtonPseudo(&quot;submit&quot;),
		&quot;reset&quot;: createButtonPseudo(&quot;reset&quot;),

		&quot;button&quot;: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === &quot;input&quot; &amp;&amp; elem.type === &quot;button&quot; || name === &quot;button&quot;;
		},

		&quot;input&quot;: function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		&quot;focus&quot;: function( elem ) {
			var doc = elem.ownerDocument;
			return elem === doc.activeElement &amp;&amp; (!doc.hasFocus || doc.hasFocus()) &amp;&amp; !!(elem.type || elem.href);
		},

		&quot;active&quot;: function( elem ) {
			return elem === elem.ownerDocument.activeElement;
		},

		// Positional types
		&quot;first&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ 0 ];
		}),

		&quot;last&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ length - 1 ];
		}),

		&quot;eq&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument &lt; 0 ? argument + length : argument ];
		}),

		&quot;even&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
			for ( var i = 0; i &lt; length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		&quot;odd&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
			for ( var i = 1; i &lt; length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		&quot;lt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
			for ( var i = argument &lt; 0 ? argument + length : argument; --i &gt;= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		&quot;gt&quot;: createPositionalPseudo(function( matchIndexes, length, argument ) {
			for ( var i = argument &lt; 0 ? argument + length : argument; ++i &lt; length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

function siblingCheck( a, b, ret ) {
	if ( a === b ) {
		return ret;
	}

	var cur = a.nextSibling;

	while ( cur ) {
		if ( cur === b ) {
			return -1;
		}

		cur = cur.nextSibling;
	}

	return 1;
}

sortOrder = docElem.compareDocumentPosition ?
	function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		return ( !a.compareDocumentPosition || !b.compareDocumentPosition ?
			a.compareDocumentPosition :
			a.compareDocumentPosition(b) &amp; 4
		) ? -1 : 1;
	} :
	function( a, b ) {
		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Fallback to using sourceIndex (in IE) if it&#x27;s available on both nodes
		} else if ( a.sourceIndex &amp;&amp; b.sourceIndex ) {
			return a.sourceIndex - b.sourceIndex;
		}

		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// If the nodes are siblings (or identical) we can do a quick check
		if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they&#x27;re somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i &lt; al &amp;&amp; i &lt; bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

// Always assume the presence of duplicates if sort doesn&#x27;t
// pass them to our comparison function (as in Google Chrome).
[0, 0].sort( sortOrder );
baseHasDuplicate = !hasDuplicate;

// Document sorting and removing duplicates
Sizzle.uniqueSort = function( results ) {
	var elem,
		i = 1;

	hasDuplicate = baseHasDuplicate;
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		for ( ; (elem = results[i]); i++ ) {
			if ( elem === results[ i - 1 ] ) {
				results.splice( i--, 1 );
			}
		}
	}

	return results;
};

Sizzle.error = function( msg ) {
	throw new Error( &quot;Syntax error, unrecognized expression: &quot; + msg );
};

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type, soFar, groups, preFilters,
		cached = tokenCache[ expando ][ selector ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				soFar = soFar.slice( match[0].length );
			}
			groups.push( tokens = [] );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			tokens.push( matched = new Token( match.shift() ) );
			soFar = soFar.slice( matched.length );

			// Cast descendant combinators to space
			matched.type = match[0].replace( rtrim, &quot; &quot; );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) &amp;&amp; (!preFilters[ type ] ||
				// The last two arguments here are (context, xml) for backCompat
				(match = preFilters[ type ]( match, document, true ))) ) {

				tokens.push( matched = new Token( match.shift() ) );
				soFar = soFar.slice( matched.length );
				matched.type = type;
				matched.matches = match;
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we&#x27;re just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base &amp;&amp; combinator.dir === &quot;parentNode&quot;,
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( checkNonElements || elem.nodeType === 1  ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			// We can&#x27;t set arbitrary data on XML nodes, so they don&#x27;t benefit from dir caching
			if ( !xml ) {
				var cache,
					dirkey = dirruns + &quot; &quot; + doneName + &quot; &quot;,
					cachedkey = dirkey + cachedruns;
				while ( (elem = elem[ dir ]) ) {
					if ( checkNonElements || elem.nodeType === 1 ) {
						if ( (cache = elem[ expando ]) === cachedkey ) {
							return elem.sizset;
						} else if ( typeof cache === &quot;string&quot; &amp;&amp; cache.indexOf(dirkey) === 0 ) {
							if ( elem.sizset ) {
								return elem;
							}
						} else {
							elem[ expando ] = cachedkey;
							if ( matcher( elem, context, xml ) ) {
								elem.sizset = true;
								return elem;
							}
							elem.sizset = false;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( checkNonElements || elem.nodeType === 1 ) {
						if ( matcher( elem, context, xml ) ) {
							return elem;
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length &gt; 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i &lt; len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter &amp;&amp; !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder &amp;&amp; !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		// Positional selectors apply to seed elements, so it is invalid to follow them with relative ones
		if ( seed &amp;&amp; postFinder ) {
			return;
		}

		var i, elem, postFilterIn,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || &quot;*&quot;, context.nodeType ? [ context ] : context, [], seed ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter &amp;&amp; ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			postFilterIn = condense( matcherOut, postMap );
			postFilter( postFilterIn, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = postFilterIn.length;
			while ( i-- ) {
				if ( (elem = postFilterIn[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		// Keep seed and results synchronized
		if ( seed ) {
			// Ignore postFinder because it can&#x27;t coexist with seed
			i = preFilter &amp;&amp; matcherOut.length;
			while ( i-- ) {
				if ( (elem = matcherOut[i]) ) {
					seed[ preMap[i] ] = !(results[ preMap[i] ] = elem);
				}
			}
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[&quot; &quot;],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) &gt; -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			return ( !leadingRelative &amp;&amp; ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
		} ];

	for ( ; i &lt; len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			// The concatenated values are (context, xml) for backCompat
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j &lt; len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i &gt; 1 &amp;&amp; elementMatcher( matchers ),
					i &gt; 1 &amp;&amp; tokens.slice( 0, i - 1 ).join(&quot;&quot;).replace( rtrim, &quot;$1&quot; ),
					matcher,
					i &lt; j &amp;&amp; matcherFromTokens( tokens.slice( i, j ) ),
					j &lt; len &amp;&amp; matcherFromTokens( (tokens = tokens.slice( j )) ),
					j &lt; len &amp;&amp; tokens.join(&quot;&quot;)
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length &gt; 0,
		byElement = elementMatchers.length &gt; 0,
		superMatcher = function( seed, context, xml, results, expandContext ) {
			var elem, j, matcher,
				setMatched = [],
				matchedCount = 0,
				i = &quot;0&quot;,
				unmatched = seed &amp;&amp; [],
				outermost = expandContext != null,
				contextBackup = outermostContext,
				// We must always have either seed elements or context
				elems = seed || byElement &amp;&amp; Expr.find[&quot;TAG&quot;]( &quot;*&quot;, expandContext &amp;&amp; context.parentNode || context ),
				// Nested matchers should use non-integer dirruns
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.E);

			if ( outermost ) {
				outermostContext = context !== document &amp;&amp; context;
				cachedruns = superMatcher.el;
			}

			// Add elements passing elementMatchers directly to results
			for ( ; (elem = elems[i]) != null; i++ ) {
				if ( byElement &amp;&amp; elem ) {
					for ( j = 0; (matcher = elementMatchers[j]); j++ ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
						cachedruns = ++superMatcher.el;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher &amp;&amp; elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet &amp;&amp; i !== matchedCount ) {
				for ( j = 0; (matcher = setMatchers[j]); j++ ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount &gt; 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost &amp;&amp; !seed &amp;&amp; setMatched.length &gt; 0 &amp;&amp;
					( matchedCount + setMatchers.length ) &gt; 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	superMatcher.el = 0;
	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ expando ][ selector ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !group ) {
			group = tokenize( selector );
		}
		i = group.length;
		while ( i-- ) {
			cached = matcherFromTokens( group[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	}
	return cached;
};

function multipleContexts( selector, contexts, results, seed ) {
	var i = 0,
		len = contexts.length;
	for ( ; i &lt; len; i++ ) {
		Sizzle( selector, contexts[i], results, seed );
	}
	return results;
}

function select( selector, context, results, seed, xml ) {
	var i, tokens, token, type, find,
		match = tokenize( selector ),
		j = match.length;

	if ( !seed ) {
		// Try to minimize operations if there is only one group
		if ( match.length === 1 ) {

			// Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length &gt; 2 &amp;&amp; (token = tokens[0]).type === &quot;ID&quot; &amp;&amp;
					context.nodeType === 9 &amp;&amp; !xml &amp;&amp;
					Expr.relative[ tokens[1].type ] ) {

				context = Expr.find[&quot;ID&quot;]( token.matches[0].replace( rbackslash, &quot;&quot; ), context, xml )[0];
				if ( !context ) {
					return results;
				}

				selector = selector.slice( tokens.shift().length );
			}

			// Fetch a seed set for right-to-left matching
			for ( i = matchExpr[&quot;POS&quot;].test( selector ) ? -1 : tokens.length - 1; i &gt;= 0; i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( rbackslash, &quot;&quot; ),
						rsibling.test( tokens[0].type ) &amp;&amp; context.parentNode || context,
						xml
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length &amp;&amp; tokens.join(&quot;&quot;);
						if ( !selector ) {
							push.apply( results, slice.call( seed, 0 ) );
							return results;
						}

						break;
					}
				}
			}
		}
	}

	// Compile and execute a filtering function
	// Provide &#x60;match&#x60; to avoid retokenization if we modified the selector above
	compile( selector, match )(
		seed,
		context,
		xml,
		results,
		rsibling.test( selector )
	);
	return results;
}

if ( document.querySelectorAll ) {
	(function() {
		var disconnectedMatch,
			oldSelect = select,
			rescape = /&#x27;|\\/g,
			rattributeQuotes = /\=[\x20\t\r\n\f]*([^&#x27;&quot;\]]*)[\x20\t\r\n\f]*\]/g,

			// qSa(:focus) reports false when true (Chrome 21),
			// A support test would require too much code (would include document ready)
			rbuggyQSA = [&quot;:focus&quot;],

			// matchesSelector(:focus) reports false when true (Chrome 21),
			// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
			// A support test would require too much code (would include document ready)
			// just skip matchesSelector for :active
			rbuggyMatches = [ &quot;:active&quot;, &quot;:focus&quot; ],
			matches = docElem.matchesSelector ||
				docElem.mozMatchesSelector ||
				docElem.webkitMatchesSelector ||
				docElem.oMatchesSelector ||
				docElem.msMatchesSelector;

		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE&#x27;s treatment of not explictly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			div.innerHTML = &quot;&lt;select&gt;&lt;option selected=&#x27;&#x27;&gt;&lt;/option&gt;&lt;/select&gt;&quot;;

			// IE8 - Some boolean attributes are not treated correctly
			if ( !div.querySelectorAll(&quot;[selected]&quot;).length ) {
				rbuggyQSA.push( &quot;\\[&quot; + whitespace + &quot;*(?:checked|disabled|ismap|multiple|readonly|selected|value)&quot; );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here (do not put tests after this one)
			if ( !div.querySelectorAll(&quot;:checked&quot;).length ) {
				rbuggyQSA.push(&quot;:checked&quot;);
			}
		});

		assert(function( div ) {

			// Opera 10-12/IE9 - ^= $= *= and empty values
			// Should not select anything
			div.innerHTML = &quot;&lt;p test=&#x27;&#x27;&gt;&lt;/p&gt;&quot;;
			if ( div.querySelectorAll(&quot;[test^=&#x27;&#x27;]&quot;).length ) {
				rbuggyQSA.push( &quot;[*^$]=&quot; + whitespace + &quot;*(?:\&quot;\&quot;|&#x27;&#x27;)&quot; );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here (do not put tests after this one)
			div.innerHTML = &quot;&lt;input type=&#x27;hidden&#x27;/&gt;&quot;;
			if ( !div.querySelectorAll(&quot;:enabled&quot;).length ) {
				rbuggyQSA.push(&quot;:enabled&quot;, &quot;:disabled&quot;);
			}
		});

		// rbuggyQSA always contains :focus, so no need for a length check
		rbuggyQSA = /* rbuggyQSA.length &amp;&amp; */ new RegExp( rbuggyQSA.join(&quot;|&quot;) );

		select = function( selector, context, results, seed, xml ) {
			// Only use querySelectorAll when not filtering,
			// when this is not xml,
			// and when no QSA bugs apply
			if ( !seed &amp;&amp; !xml &amp;&amp; (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
				var groups, i,
					old = true,
					nid = expando,
					newContext = context,
					newSelector = context.nodeType === 9 &amp;&amp; selector;

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn&#x27;t work on object elements
				if ( context.nodeType === 1 &amp;&amp; context.nodeName.toLowerCase() !== &quot;object&quot; ) {
					groups = tokenize( selector );

					if ( (old = context.getAttribute(&quot;id&quot;)) ) {
						nid = old.replace( rescape, &quot;\\$&amp;&quot; );
					} else {
						context.setAttribute( &quot;id&quot;, nid );
					}
					nid = &quot;[id=&#x27;&quot; + nid + &quot;&#x27;] &quot;;

					i = groups.length;
					while ( i-- ) {
						groups[i] = nid + groups[i].join(&quot;&quot;);
					}
					newContext = rsibling.test( selector ) &amp;&amp; context.parentNode || context;
					newSelector = groups.join(&quot;,&quot;);
				}

				if ( newSelector ) {
					try {
						push.apply( results, slice.call( newContext.querySelectorAll(
							newSelector
						), 0 ) );
						return results;
					} catch(qsaError) {
					} finally {
						if ( !old ) {
							context.removeAttribute(&quot;id&quot;);
						}
					}
				}
			}

			return oldSelect( selector, context, results, seed, xml );
		};

		if ( matches ) {
			assert(function( div ) {
				// Check to see if it&#x27;s possible to do matchesSelector
				// on a disconnected node (IE 9)
				disconnectedMatch = matches.call( div, &quot;div&quot; );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				try {
					matches.call( div, &quot;[test!=&#x27;&#x27;]:sizzle&quot; );
					rbuggyMatches.push( &quot;!=&quot;, pseudos );
				} catch ( e ) {}
			});

			// rbuggyMatches always contains :active and :focus, so no need for a length check
			rbuggyMatches = /* rbuggyMatches.length &amp;&amp; */ new RegExp( rbuggyMatches.join(&quot;|&quot;) );

			Sizzle.matchesSelector = function( elem, expr ) {
				// Make sure that attribute selectors are quoted
				expr = expr.replace( rattributeQuotes, &quot;=&#x27;$1&#x27;]&quot; );

				// rbuggyMatches always contains :active, so no need for an existence check
				if ( !isXML( elem ) &amp;&amp; !rbuggyMatches.test( expr ) &amp;&amp; (!rbuggyQSA || !rbuggyQSA.test( expr )) ) {
					try {
						var ret = matches.call( elem, expr );

						// IE 9&#x27;s matchesSelector returns false on disconnected nodes
						if ( ret || disconnectedMatch ||
								// As well, disconnected nodes are said to be in a document
								// fragment in IE 9
								elem.document &amp;&amp; elem.document.nodeType !== 11 ) {
							return ret;
						}
					} catch(e) {}
				}

				return Sizzle( expr, null, null, [ elem ] ).length &gt; 0;
			};
		}
	})();
}

// Deprecated
Expr.pseudos[&quot;nth&quot;] = Expr.pseudos[&quot;eq&quot;];

// Back-compat
function setFilters() {}
Expr.filters = setFilters.prototype = Expr.pseudos;
Expr.setFilters = new setFilters();

// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[&quot;:&quot;] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})( window );
var runtil = /Until$/,
	rparentsprev = /^(?:parents|prev(?:Until|All))/,
	isSimple = /^.[^:#\[\.,]*$/,
	rneedsContext = jQuery.expr.match.needsContext,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var i, l, length, n, r, ret,
			self = this;

		if ( typeof selector !== &quot;string&quot; ) {
			return jQuery( selector ).filter(function() {
				for ( i = 0, l = self.length; i &lt; l; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			});
		}

		ret = this.pushStack( &quot;&quot;, &quot;find&quot;, selector );

		for ( i = 0, l = this.length; i &lt; l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i &gt; 0 ) {
				// Make sure that the results are unique
				for ( n = length; n &lt; ret.length; n++ ) {
					for ( r = 0; r &lt; length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var i,
			targets = jQuery( target, this ),
			len = targets.length;

		return this.filter(function() {
			for ( i = 0; i &lt; len; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), &quot;not&quot;, selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), &quot;filter&quot;, selector );
	},

	is: function( selector ) {
		return !!selector &amp;&amp; (
			typeof selector === &quot;string&quot; ?
				// If this is a positional/relative selector, check membership in the returned set
				// so $(&quot;p:first&quot;).is(&quot;p:last&quot;) won&#x27;t return true for a doc with two &quot;p&quot;.
				rneedsContext.test( selector ) ?
					jQuery( selector, this.context ).index( this[0] ) &gt;= 0 :
					jQuery.filter( selector, this ).length &gt; 0 :
				this.filter( selector ).length &gt; 0 );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			ret = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== &quot;string&quot; ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i &lt; l; i++ ) {
			cur = this[i];

			while ( cur &amp;&amp; cur.ownerDocument &amp;&amp; cur !== context &amp;&amp; cur.nodeType !== 11 ) {
				if ( pos ? pos.index(cur) &gt; -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;
				}
				cur = cur.parentNode;
			}
		}

		ret = ret.length &gt; 1 ? jQuery.unique( ret ) : ret;

		return this.pushStack( ret, &quot;closest&quot;, selectors );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] &amp;&amp; this[0].parentNode ) ? this.prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === &quot;string&quot; ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === &quot;string&quot; ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector &amp;&amp; selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

jQuery.fn.andSelf = jQuery.fn.addBack;

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

function sibling( cur, dir ) {
	do {
		cur = cur[ dir ];
	} while ( cur &amp;&amp; cur.nodeType !== 1 );

	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent &amp;&amp; parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, &quot;parentNode&quot; );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, &quot;parentNode&quot;, until );
	},
	next: function( elem ) {
		return sibling( elem, &quot;nextSibling&quot; );
	},
	prev: function( elem ) {
		return sibling( elem, &quot;previousSibling&quot; );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, &quot;nextSibling&quot; );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, &quot;previousSibling&quot; );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, &quot;nextSibling&quot;, until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, &quot;previousSibling&quot;, until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, &quot;iframe&quot; ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector &amp;&amp; typeof selector === &quot;string&quot; ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length &gt; 1 &amp;&amp; !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

		if ( this.length &gt; 1 &amp;&amp; rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, core_slice.call( arguments ).join(&quot;,&quot;) );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = &quot;:not(&quot; + expr + &quot;)&quot;;
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur &amp;&amp; cur.nodeType !== 9 &amp;&amp; (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 &amp;&amp; n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

	// Can&#x27;t pass null or undefined to indexOf in Firefox 4
	// Set to 0 to skip string check
	qualifier = qualifier || 0;

	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return ( elem === qualifier ) === keep;
		});

	} else if ( typeof qualifier === &quot;string&quot; ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return ( jQuery.inArray( elem, qualifier ) &gt;= 0 ) === keep;
	});
}
function createSafeFragment( document ) {
	var list = nodeNames.split( &quot;|&quot; ),
	safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = &quot;abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|&quot; +
		&quot;header|hgroup|mark|meter|nav|output|progress|section|summary|time|video&quot;,
	rinlinejQuery = / jQuery\d+=&quot;(?:null|\d+)&quot;/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^&gt;]*)\/&gt;/gi,
	rtagName = /&lt;([\w:]+)/,
	rtbody = /&lt;tbody/i,
	rhtml = /&lt;|&amp;#?\w+;/,
	rnoInnerhtml = /&lt;(?:script|style|link)/i,
	rnocache = /&lt;(?:script|object|embed|option|style)/i,
	rnoshimcache = new RegExp(&quot;&lt;(?:&quot; + nodeNames + &quot;)[\\s/&gt;]&quot;, &quot;i&quot;),
	rcheckableType = /^(?:checkbox|radio)$/,
	// checked=&quot;checked&quot; or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*&lt;!(?:\[CDATA\[|\-\-)|[\]\-]{2}&gt;\s*$/g,
	wrapMap = {
		option: [ 1, &quot;&lt;select multiple=&#x27;multiple&#x27;&gt;&quot;, &quot;&lt;/select&gt;&quot; ],
		legend: [ 1, &quot;&lt;fieldset&gt;&quot;, &quot;&lt;/fieldset&gt;&quot; ],
		thead: [ 1, &quot;&lt;table&gt;&quot;, &quot;&lt;/table&gt;&quot; ],
		tr: [ 2, &quot;&lt;table&gt;&lt;tbody&gt;&quot;, &quot;&lt;/tbody&gt;&lt;/table&gt;&quot; ],
		td: [ 3, &quot;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&quot;, &quot;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&quot; ],
		col: [ 2, &quot;&lt;table&gt;&lt;tbody&gt;&lt;/tbody&gt;&lt;colgroup&gt;&quot;, &quot;&lt;/colgroup&gt;&lt;/table&gt;&quot; ],
		area: [ 1, &quot;&lt;map&gt;&quot;, &quot;&lt;/map&gt;&quot; ],
		_default: [ 0, &quot;&quot;, &quot;&quot; ]
	},
	safeFragment = createSafeFragment( document ),
	fragmentDiv = safeFragment.appendChild( document.createElement(&quot;div&quot;) );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE6-8 can&#x27;t serialize link, script, style, or any html5 (NoScope) tags,
// unless wrapped in a div with non-breaking characters in front of it.
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, &quot;X&lt;div&gt;&quot;, &quot;&lt;/div&gt;&quot; ];
}

jQuery.fn.extend({
	text: function( value ) {
		return jQuery.access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] &amp;&amp; this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild &amp;&amp; elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, &quot;body&quot; ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( !isDisconnected( this[0] ) ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		}

		if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			return this.pushStack( jQuery.merge( set, this ), &quot;before&quot;, this.selector );
		}
	},

	after: function() {
		if ( !isDisconnected( this[0] ) ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		}

		if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			return this.pushStack( jQuery.merge( this, set ), &quot;after&quot;, this.selector );
		}
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData &amp;&amp; elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName(&quot;*&quot;) );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName(&quot;*&quot;) );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return jQuery.access( this, function( value ) {
			var elem = this[0] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, &quot;&quot; ) :
					undefined;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === &quot;string&quot; &amp;&amp; !rnoInnerhtml.test( value ) &amp;&amp;
				( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &amp;&amp;
				( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &amp;&amp;
				!wrapMap[ ( rtagName.exec( value ) || [&quot;&quot;, &quot;&quot;] )[1].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, &quot;&lt;$1&gt;&lt;/$2&gt;&quot; );

				try {
					for (; i &lt; l; i++ ) {
						// Remove element nodes and prevent memory leaks
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( elem.getElementsByTagName( &quot;*&quot; ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch(e) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function( value ) {
		if ( !isDisconnected( this[0] ) ) {
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value !== &quot;string&quot; ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery( this ).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		}

		return this.length ?
			this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), &quot;replaceWith&quot;, value ) :
			this;
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {

		// Flatten any nested arrays
		args = [].concat.apply( [], args );

		var results, first, fragment, iNoClone,
			i = 0,
			value = args[0],
			scripts = [],
			l = this.length;

		// We can&#x27;t cloneNode fragments that contain checked, in WebKit
		if ( !jQuery.support.checkClone &amp;&amp; l &gt; 1 &amp;&amp; typeof value === &quot;string&quot; &amp;&amp; rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call( this, i, table ? self.html() : undefined );
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			results = jQuery.buildFragment( args, this, scripts );
			fragment = results.fragment;
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				table = table &amp;&amp; jQuery.nodeName( first, &quot;tr&quot; );

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				// Fragments from the fragment cache must always be cloned and never used in place.
				for ( iNoClone = results.cacheable || l - 1; i &lt; l; i++ ) {
					callback.call(
						table &amp;&amp; jQuery.nodeName( this[i], &quot;table&quot; ) ?
							findOrAppend( this[i], &quot;tbody&quot; ) :
							this[i],
						i === iNoClone ?
							fragment :
							jQuery.clone( fragment, true, true )
					);
				}
			}

			// Fix #11809: Avoid leaking memory
			fragment = first = null;

			if ( scripts.length ) {
				jQuery.each( scripts, function( i, elem ) {
					if ( elem.src ) {
						if ( jQuery.ajax ) {
							jQuery.ajax({
								url: elem.src,
								type: &quot;GET&quot;,
								dataType: &quot;script&quot;,
								async: false,
								global: false,
								&quot;throws&quot;: true
							});
						} else {
							jQuery.error(&quot;no ajax&quot;);
						}
					} else {
						jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || &quot;&quot; ).replace( rcleanScript, &quot;&quot; ) );
					}

					if ( elem.parentNode ) {
						elem.parentNode.removeChild( elem );
					}
				});
			}
		}

		return this;
	}
});

function findOrAppend( elem, tag ) {
	return elem.getElementsByTagName( tag )[0] || elem.appendChild( elem.ownerDocument.createElement( tag ) );
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i &lt; l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function cloneFixAttributes( src, dest ) {
	var nodeName;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	// clearAttributes removes the attributes, which we don&#x27;t want,
	// but also removes the attachEvent events, which we *do* want
	if ( dest.clearAttributes ) {
		dest.clearAttributes();
	}

	// mergeAttributes, in contrast, only merges back on the
	// original attributes, not the events
	if ( dest.mergeAttributes ) {
		dest.mergeAttributes( src );
	}

	nodeName = dest.nodeName.toLowerCase();

	if ( nodeName === &quot;object&quot; ) {
		// IE6-10 improperly clones children of object elements using classid.
		// IE10 throws NoModificationAllowedError if parent is null, #12132.
		if ( dest.parentNode ) {
			dest.outerHTML = src.outerHTML;
		}

		// This path appears unavoidable for IE9. When cloning an object
		// element in IE9, the outerHTML strategy above is not sufficient.
		// If the src has innerHTML and the destination does not,
		// copy the src.innerHTML into the dest.innerHTML. #10324
		if ( jQuery.support.html5Clone &amp;&amp; (src.innerHTML &amp;&amp; !jQuery.trim(dest.innerHTML)) ) {
			dest.innerHTML = src.innerHTML;
		}

	} else if ( nodeName === &quot;input&quot; &amp;&amp; rcheckableType.test( src.type ) ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn&#x27;t also set

		dest.defaultChecked = dest.checked = src.checked;

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of &quot;on&quot;
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === &quot;option&quot; ) {
		dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === &quot;input&quot; || nodeName === &quot;textarea&quot; ) {
		dest.defaultValue = src.defaultValue;

	// IE blanks contents when cloning scripts
	} else if ( nodeName === &quot;script&quot; &amp;&amp; dest.text !== src.text ) {
		dest.text = src.text;
	}

	// Event data gets referenced instead of copied if the expando
	// gets copied too
	dest.removeAttribute( jQuery.expando );
}

jQuery.buildFragment = function( args, context, scripts ) {
	var fragment, cacheable, cachehit,
		first = args[ 0 ];

	// Set context from what may come in as undefined or a jQuery collection or a node
	// Updated to fix #12266 where accessing context[0] could throw an exception in IE9/10 &amp;
	// also doubles as fix for #8950 where plain objects caused createDocumentFragment exception
	context = context || document;
	context = !context.nodeType &amp;&amp; context[0] || context;
	context = context.ownerDocument || context;

	// Only cache &quot;small&quot; (1/2 KB) HTML strings that are associated with the main document
	// Cloning options loses the selected state, so don&#x27;t cache them
	// IE 6 doesn&#x27;t like it when you put &lt;object&gt; or &lt;embed&gt; elements in a fragment
	// Also, WebKit does not clone &#x27;checked&#x27; attributes on cloneNode, so don&#x27;t cache
	// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
	if ( args.length === 1 &amp;&amp; typeof first === &quot;string&quot; &amp;&amp; first.length &lt; 512 &amp;&amp; context === document &amp;&amp;
		first.charAt(0) === &quot;&lt;&quot; &amp;&amp; !rnocache.test( first ) &amp;&amp;
		(jQuery.support.checkClone || !rchecked.test( first )) &amp;&amp;
		(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

		// Mark cacheable and look for a hit
		cacheable = true;
		fragment = jQuery.fragments[ first ];
		cachehit = fragment !== undefined;
	}

	if ( !fragment ) {
		fragment = context.createDocumentFragment();
		jQuery.clean( args, context, fragment, scripts );

		// Update the cache, but only store false
		// unless this is a second parsing of the same content
		if ( cacheable ) {
			jQuery.fragments[ first ] = cachehit &amp;&amp; fragment;
		}
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: &quot;append&quot;,
	prependTo: &quot;prepend&quot;,
	insertBefore: &quot;before&quot;,
	insertAfter: &quot;after&quot;,
	replaceAll: &quot;replaceWith&quot;
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			i = 0,
			ret = [],
			insert = jQuery( selector ),
			l = insert.length,
			parent = this.length === 1 &amp;&amp; this[0].parentNode;

		if ( (parent == null || parent &amp;&amp; parent.nodeType === 11 &amp;&amp; parent.childNodes.length === 1) &amp;&amp; l === 1 ) {
			insert[ original ]( this[0] );
			return this;
		} else {
			for ( ; i &lt; l; i++ ) {
				elems = ( i &gt; 0 ? this.clone(true) : this ).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}

			return this.pushStack( ret, name, insert.selector );
		}
	};
});

function getAll( elem ) {
	if ( typeof elem.getElementsByTagName !== &quot;undefined&quot; ) {
		return elem.getElementsByTagName( &quot;*&quot; );

	} else if ( typeof elem.querySelectorAll !== &quot;undefined&quot; ) {
		return elem.querySelectorAll( &quot;*&quot; );

	} else {
		return [];
	}
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( rcheckableType.test( elem.type ) ) {
		elem.defaultChecked = elem.checked;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var srcElements,
			destElements,
			i,
			clone;

		if ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( &quot;&lt;&quot; + elem.nodeName + &quot;&gt;&quot; ) ) {
			clone = elem.cloneNode( true );

		// IE&lt;=8 does not properly clone detached, unknown element nodes
		} else {
			fragmentDiv.innerHTML = elem.outerHTML;
			fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
		}

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &amp;&amp;
				(elem.nodeType === 1 || elem.nodeType === 11) &amp;&amp; !jQuery.isXMLDoc(elem) ) {
			// IE copies events bound via attachEvent when using cloneNode.
			// Calling detachEvent on the clone will also remove the events
			// from the original. In order to get around this, we use some
			// proprietary methods to clear the events. Thanks to MooTools
			// guys for this hotness.

			cloneFixAttributes( elem, clone );

			// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
			srcElements = getAll( elem );
			destElements = getAll( clone );

			// Weird iteration because IE will replace the length property
			// with an element if you are cloning the body and one of the
			// elements on the page has a name or id of &quot;length&quot;
			for ( i = 0; srcElements[i]; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					cloneFixAttributes( srcElements[i], destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			cloneCopyEvent( elem, clone );

			if ( deepDataAndEvents ) {
				srcElements = getAll( elem );
				destElements = getAll( clone );

				for ( i = 0; srcElements[i]; ++i ) {
					cloneCopyEvent( srcElements[i], destElements[i] );
				}
			}
		}

		srcElements = destElements = null;

		// Return the cloned set
		return clone;
	},

	clean: function( elems, context, fragment, scripts ) {
		var i, j, elem, tag, wrap, depth, div, hasBody, tbody, len, handleScript, jsTags,
			safe = context === document &amp;&amp; safeFragment,
			ret = [];

		// Ensure that context is a document
		if ( !context || typeof context.createDocumentFragment === &quot;undefined&quot; ) {
			context = document;
		}

		// Use the already-created safe fragment if context permits
		for ( i = 0; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === &quot;number&quot; ) {
				elem += &quot;&quot;;
			}

			if ( !elem ) {
				continue;
			}

			// Convert html string into DOM nodes
			if ( typeof elem === &quot;string&quot; ) {
				if ( !rhtml.test( elem ) ) {
					elem = context.createTextNode( elem );
				} else {
					// Ensure a safe container in which to render the html
					safe = safe || createSafeFragment( context );
					div = context.createElement(&quot;div&quot;);
					safe.appendChild( div );

					// Fix &quot;XHTML&quot;-style tags in all browsers
					elem = elem.replace(rxhtmlTag, &quot;&lt;$1&gt;&lt;/$2&gt;&quot;);

					// Go to html and back, then peel off extra wrappers
					tag = ( rtagName.exec( elem ) || [&quot;&quot;, &quot;&quot;] )[1].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					depth = wrap[0];
					div.innerHTML = wrap[1] + elem + wrap[2];

					// Move to the right depth
					while ( depth-- ) {
						div = div.lastChild;
					}

					// Remove IE&#x27;s autoinserted &lt;tbody&gt; from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a &lt;table&gt;, *may* have spurious &lt;tbody&gt;
						hasBody = rtbody.test(elem);
							tbody = tag === &quot;table&quot; &amp;&amp; !hasBody ?
								div.firstChild &amp;&amp; div.firstChild.childNodes :

								// String was a bare &lt;thead&gt; or &lt;tfoot&gt;
								wrap[1] === &quot;&lt;table&gt;&quot; &amp;&amp; !hasBody ?
									div.childNodes :
									[];

						for ( j = tbody.length - 1; j &gt;= 0 ; --j ) {
							if ( jQuery.nodeName( tbody[ j ], &quot;tbody&quot; ) &amp;&amp; !tbody[ j ].childNodes.length ) {
								tbody[ j ].parentNode.removeChild( tbody[ j ] );
							}
						}
					}

					// IE completely kills leading whitespace when innerHTML is used
					if ( !jQuery.support.leadingWhitespace &amp;&amp; rleadingWhitespace.test( elem ) ) {
						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
					}

					elem = div.childNodes;

					// Take out of fragment container (we need a fresh div each time)
					div.parentNode.removeChild( div );
				}
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				jQuery.merge( ret, elem );
			}
		}

		// Fix #11356: Clear elements from safeFragment
		if ( div ) {
			elem = div = safe = null;
		}

		// Reset defaultChecked for any radios and checkboxes
		// about to be appended to the DOM in IE 6/7 (#8060)
		if ( !jQuery.support.appendChecked ) {
			for ( i = 0; (elem = ret[i]) != null; i++ ) {
				if ( jQuery.nodeName( elem, &quot;input&quot; ) ) {
					fixDefaultChecked( elem );
				} else if ( typeof elem.getElementsByTagName !== &quot;undefined&quot; ) {
					jQuery.grep( elem.getElementsByTagName(&quot;input&quot;), fixDefaultChecked );
				}
			}
		}

		// Append elements to a provided document fragment
		if ( fragment ) {
			// Special handling of each script element
			handleScript = function( elem ) {
				// Check if we consider it executable
				if ( !elem.type || rscriptType.test( elem.type ) ) {
					// Detach the script and store it in the scripts array (if provided) or the fragment
					// Return truthy to indicate that it has been handled
					return scripts ?
						scripts.push( elem.parentNode ? elem.parentNode.removeChild( elem ) : elem ) :
						fragment.appendChild( elem );
				}
			};

			for ( i = 0; (elem = ret[i]) != null; i++ ) {
				// Check if we&#x27;re done after handling an executable script
				if ( !( jQuery.nodeName( elem, &quot;script&quot; ) &amp;&amp; handleScript( elem ) ) ) {
					// Append to fragment and handle embedded scripts
					fragment.appendChild( elem );
					if ( typeof elem.getElementsByTagName !== &quot;undefined&quot; ) {
						// handleScript alters the DOM, so use jQuery.merge to ensure snapshot iteration
						jsTags = jQuery.grep( jQuery.merge( [], elem.getElementsByTagName(&quot;script&quot;) ), handleScript );

						// Splice the scripts into ret after their former ancestor and advance our index beyond them
						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
						i += jsTags.length;
					}
				}
			}
		}

		return ret;
	},

	cleanData: function( elems, /* internal */ acceptData ) {
		var data, id, elem, type,
			i = 0,
			internalKey = jQuery.expando,
			cache = jQuery.cache,
			deleteExpando = jQuery.support.deleteExpando,
			special = jQuery.event.special;

		for ( ; (elem = elems[i]) != null; i++ ) {

			if ( acceptData || jQuery.acceptData( elem ) ) {

				id = elem[ internalKey ];
				data = id &amp;&amp; cache[ id ];

				if ( data ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove&#x27;s overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Remove cache only if it was not already removed by jQuery.event.remove
					if ( cache[ id ] ) {

						delete cache[ id ];

						// IE does not allow us to delete expando properties from nodes,
						// nor does it have a removeAttribute function on Document nodes;
						// we must handle all of these cases
						if ( deleteExpando ) {
							delete elem[ internalKey ];

						} else if ( elem.removeAttribute ) {
							elem.removeAttribute( internalKey );

						} else {
							elem[ internalKey ] = null;
						}

						jQuery.deletedIds.push( id );
					}
				}
			}
		}
	}
});
// Limit scope pollution from any deprecated API
(function() {

var matched, browser;

// Use of jQuery.browser is frowned upon.
// More details: http://api.jquery.com/jQuery.browser
// jQuery.uaMatch maintained for back-compat
jQuery.uaMatch = function( ua ) {
	ua = ua.toLowerCase();

	var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
		/(webkit)[ \/]([\w.]+)/.exec( ua ) ||
		/(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
		/(msie) ([\w.]+)/.exec( ua ) ||
		ua.indexOf(&quot;compatible&quot;) &lt; 0 &amp;&amp; /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
		[];

	return {
		browser: match[ 1 ] || &quot;&quot;,
		version: match[ 2 ] || &quot;0&quot;
	};
};

matched = jQuery.uaMatch( navigator.userAgent );
browser = {};

if ( matched.browser ) {
	browser[ matched.browser ] = true;
	browser.version = matched.version;
}

// Chrome is Webkit, but Webkit is also Safari.
if ( browser.chrome ) {
	browser.webkit = true;
} else if ( browser.webkit ) {
	browser.safari = true;
}

jQuery.browser = browser;

jQuery.sub = function() {
	function jQuerySub( selector, context ) {
		return new jQuerySub.fn.init( selector, context );
	}
	jQuery.extend( true, jQuerySub, this );
	jQuerySub.superclass = this;
	jQuerySub.fn = jQuerySub.prototype = this();
	jQuerySub.fn.constructor = jQuerySub;
	jQuerySub.sub = this.sub;
	jQuerySub.fn.init = function init( selector, context ) {
		if ( context &amp;&amp; context instanceof jQuery &amp;&amp; !(context instanceof jQuerySub) ) {
			context = jQuerySub( context );
		}

		return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
	};
	jQuerySub.fn.init.prototype = jQuerySub.fn;
	var rootjQuerySub = jQuerySub(document);
	return jQuerySub;
};

})();
var curCSS, iframe, iframeDoc,
	ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	rposition = /^(top|right|bottom|left)$/,
	// swappable if display is none or starts with table except &quot;table&quot;, &quot;table-cell&quot;, or &quot;table-caption&quot;
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rmargin = /^margin/,
	rnumsplit = new RegExp( &quot;^(&quot; + core_pnum + &quot;)(.*)$&quot;, &quot;i&quot; ),
	rnumnonpx = new RegExp( &quot;^(&quot; + core_pnum + &quot;)(?!px)[a-z%]+$&quot;, &quot;i&quot; ),
	rrelNum = new RegExp( &quot;^([-+])=(&quot; + core_pnum + &quot;)&quot;, &quot;i&quot; ),
	elemdisplay = {},

	cssShow = { position: &quot;absolute&quot;, visibility: &quot;hidden&quot;, display: &quot;block&quot; },
	cssNormalTransform = {
		letterSpacing: 0,
		fontWeight: 400
	},

	cssExpand = [ &quot;Top&quot;, &quot;Right&quot;, &quot;Bottom&quot;, &quot;Left&quot; ],
	cssPrefixes = [ &quot;Webkit&quot;, &quot;O&quot;, &quot;Moz&quot;, &quot;ms&quot; ],

	eventsToggle = jQuery.fn.toggle;

// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name.charAt(0).toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function isHidden( elem, el ) {
	elem = el || elem;
	return jQuery.css( elem, &quot;display&quot; ) === &quot;none&quot; || !jQuery.contains( elem.ownerDocument, elem );
}

function showHide( elements, show ) {
	var elem, display,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index &lt; length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		values[ index ] = jQuery._data( elem, &quot;olddisplay&quot; );
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] &amp;&amp; elem.style.display === &quot;none&quot; ) {
				elem.style.display = &quot;&quot;;
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === &quot;&quot; &amp;&amp; isHidden( elem ) ) {
				values[ index ] = jQuery._data( elem, &quot;olddisplay&quot;, css_defaultDisplay(elem.nodeName) );
			}
		} else {
			display = curCSS( elem, &quot;display&quot; );

			if ( !values[ index ] &amp;&amp; display !== &quot;none&quot; ) {
				jQuery._data( elem, &quot;olddisplay&quot;, display );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index &lt; length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === &quot;none&quot; || elem.style.display === &quot;&quot; ) {
			elem.style.display = show ? values[ index ] || &quot;&quot; : &quot;none&quot;;
		}
	}

	return elements;
}

jQuery.fn.extend({
	css: function( name, value ) {
		return jQuery.access( this, function( elem, name, value ) {
			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length &gt; 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state, fn2 ) {
		var bool = typeof state === &quot;boolean&quot;;

		if ( jQuery.isFunction( state ) &amp;&amp; jQuery.isFunction( fn2 ) ) {
			return eventsToggle.apply( this, arguments );
		}

		return this.each(function() {
			if ( bool ? state : isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, &quot;opacity&quot; );
					return ret === &quot;&quot; ? &quot;1&quot; : ret;

				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		&quot;fillOpacity&quot;: true,
		&quot;fontWeight&quot;: true,
		&quot;lineHeight&quot;: true,
		&quot;opacity&quot;: true,
		&quot;orphans&quot;: true,
		&quot;widows&quot;: true,
		&quot;zIndex&quot;: true,
		&quot;zoom&quot;: true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		&quot;float&quot;: jQuery.support.cssFloat ? &quot;cssFloat&quot; : &quot;styleFloat&quot;
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don&#x27;t set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we&#x27;re working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we&#x27;re setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === &quot;string&quot; &amp;&amp; (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = &quot;number&quot;;
			}

			// Make sure that NaN and null values aren&#x27;t set. See: #7116
			if ( value == null || type === &quot;number&quot; &amp;&amp; isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add &#x27;px&#x27; to the (except for certain CSS properties)
			if ( type === &quot;number&quot; &amp;&amp; !jQuery.cssNumber[ origName ] ) {
				value += &quot;px&quot;;
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !(&quot;set&quot; in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				// Wrapped to prevent IE from throwing errors when &#x27;invalid&#x27; values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks &amp;&amp; &quot;get&quot; in hooks &amp;&amp; (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, numeric, extra ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we&#x27;re working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks &amp;&amp; &quot;get&quot; in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name );
		}

		//convert &quot;normal&quot; to computed value
		if ( val === &quot;normal&quot; &amp;&amp; name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( numeric || extra !== undefined ) {
			num = parseFloat( val );
			return numeric || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	}
});

// NOTE: To any future maintainer, we&#x27;ve window.getComputedStyle
// because jsdom on node.js will break without it.
if ( window.getComputedStyle ) {
	curCSS = function( elem, name ) {
		var ret, width, minWidth, maxWidth,
			computed = window.getComputedStyle( elem, null ),
			style = elem.style;

		if ( computed ) {

			ret = computed[ name ];
			if ( ret === &quot;&quot; &amp;&amp; !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the &quot;awesome hack by Dean Edwards&quot;
			// Chrome &lt; 17 and Safari 5.0 uses &quot;computed value&quot; instead of &quot;used value&quot; for margin-right
			// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) &amp;&amp; rmargin.test( name ) ) {
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret;
	};
} else if ( document.documentElement.currentStyle ) {
	curCSS = function( elem, name ) {
		var left, rsLeft,
			ret = elem.currentStyle &amp;&amp; elem.currentStyle[ name ],
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don&#x27;t default to auto
		if ( ret == null &amp;&amp; style &amp;&amp; style[ name ] ) {
			ret = style[ name ];
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we&#x27;re not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		// but not position css attributes, as those are proportional to the parent element instead
		// and we can&#x27;t measure the parent instead because it might trigger a &quot;stacking dolls&quot; problem
		if ( rnumnonpx.test( ret ) &amp;&amp; !rposition.test( name ) ) {

			// Remember the original values
			left = style.left;
			rsLeft = elem.runtimeStyle &amp;&amp; elem.runtimeStyle.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				elem.runtimeStyle.left = elem.currentStyle.left;
			}
			style.left = name === &quot;fontSize&quot; ? &quot;1em&quot; : ret;
			ret = style.pixelLeft + &quot;px&quot;;

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = rsLeft;
			}
		}

		return ret === &quot;&quot; ? &quot;auto&quot; : ret;
	};
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
			Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || &quot;px&quot; ) :
			value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox ) {
	var i = extra === ( isBorderBox ? &quot;border&quot; : &quot;content&quot; ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === &quot;width&quot; ? 1 : 0,

		val = 0;

	for ( ; i &lt; 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === &quot;margin&quot; ) {
			// we use jQuery.css instead of curCSS here
			// because of the reliableMarginRight CSS hook!
			val += jQuery.css( elem, extra + cssExpand[ i ], true );
		}

		// From this point on we use curCSS for maximum performance (relevant in animations)
		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === &quot;content&quot; ) {
				val -= parseFloat( curCSS( elem, &quot;padding&quot; + cssExpand[ i ] ) ) || 0;
			}

			// at this point, extra isn&#x27;t border nor margin, so remove border
			if ( extra !== &quot;margin&quot; ) {
				val -= parseFloat( curCSS( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot; ) ) || 0;
			}
		} else {
			// at this point, extra isn&#x27;t content, so add padding
			val += parseFloat( curCSS( elem, &quot;padding&quot; + cssExpand[ i ] ) ) || 0;

			// at this point, extra isn&#x27;t content nor padding, so add border
			if ( extra !== &quot;padding&quot; ) {
				val += parseFloat( curCSS( elem, &quot;border&quot; + cssExpand[ i ] + &quot;Width&quot; ) ) || 0;
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var val = name === &quot;width&quot; ? elem.offsetWidth : elem.offsetHeight,
		valueIsBorderBox = true,
		isBorderBox = jQuery.support.boxSizing &amp;&amp; jQuery.css( elem, &quot;boxSizing&quot; ) === &quot;border-box&quot;;

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val &lt;= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name );
		if ( val &lt; 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &amp;&amp; ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );

		// Normalize &quot;&quot;, auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? &quot;border&quot; : &quot;content&quot; ),
			valueIsBorderBox
		)
	) + &quot;px&quot;;
}


// Try to determine the default display value of an element
function css_defaultDisplay( nodeName ) {
	if ( elemdisplay[ nodeName ] ) {
		return elemdisplay[ nodeName ];
	}

	var elem = jQuery( &quot;&lt;&quot; + nodeName + &quot;&gt;&quot; ).appendTo( document.body ),
		display = elem.css(&quot;display&quot;);
	elem.remove();

	// If the simple way fails,
	// get element&#x27;s real default display by attaching it to a temp iframe
	if ( display === &quot;none&quot; || display === &quot;&quot; ) {
		// Use the already-created iframe if possible
		iframe = document.body.appendChild(
			iframe || jQuery.extend( document.createElement(&quot;iframe&quot;), {
				frameBorder: 0,
				width: 0,
				height: 0
			})
		);

		// Create a cacheable copy of the iframe document on first call.
		// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
		// document to it; WebKit &amp; Firefox won&#x27;t allow reusing the iframe document.
		if ( !iframeDoc || !iframe.createElement ) {
			iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
			iframeDoc.write(&quot;&lt;!doctype html&gt;&lt;html&gt;&lt;body&gt;&quot;);
			iframeDoc.close();
		}

		elem = iframeDoc.body.appendChild( iframeDoc.createElement(nodeName) );

		display = curCSS( elem, &quot;display&quot; );
		document.body.removeChild( iframe );
	}

	// Store the correct default display
	elemdisplay[ nodeName ] = display;

	return display;
}

jQuery.each([ &quot;height&quot;, &quot;width&quot; ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				if ( elem.offsetWidth === 0 &amp;&amp; rdisplayswap.test( curCSS( elem, &quot;display&quot; ) ) ) {
					return jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					});
				} else {
					return getWidthOrHeight( elem, name, extra );
				}
			}
		},

		set: function( elem, value, extra ) {
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.support.boxSizing &amp;&amp; jQuery.css( elem, &quot;boxSizing&quot; ) === &quot;border-box&quot;
				) : 0
			);
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed &amp;&amp; elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || &quot;&quot; ) ?
				( 0.01 * parseFloat( RegExp.$1 ) ) + &quot;&quot; :
				computed ? &quot;1&quot; : &quot;&quot;;
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? &quot;alpha(opacity=&quot; + value * 100 + &quot;)&quot; : &quot;&quot;,
				filter = currentStyle &amp;&amp; currentStyle.filter || style.filter || &quot;&quot;;

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			if ( value &gt;= 1 &amp;&amp; jQuery.trim( filter.replace( ralpha, &quot;&quot; ) ) === &quot;&quot; &amp;&amp;
				style.removeAttribute ) {

				// Setting style.filter to null, &quot;&quot; &amp; &quot; &quot; still leave &quot;filter:&quot; in the cssText
				// if &quot;filter:&quot; is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( &quot;filter&quot; );

				// if there there is no filter style applied in a css rule, we are done
				if ( currentStyle &amp;&amp; !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + &quot; &quot; + opacity;
		}
	};
}

// These hooks cannot be added until DOM ready because the support test
// for it is not run until after DOM ready
jQuery(function() {
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// Work around by temporarily setting element display to inline-block
				return jQuery.swap( elem, { &quot;display&quot;: &quot;inline-block&quot; }, function() {
					if ( computed ) {
						return curCSS( elem, &quot;marginRight&quot; );
					}
				});
			}
		};
	}

	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// getComputedStyle returns percent when specified for top/left/bottom/right
	// rather than make the css module depend on the offset module, we just check for it here
	if ( !jQuery.support.pixelPosition &amp;&amp; jQuery.fn.position ) {
		jQuery.each( [ &quot;top&quot;, &quot;left&quot; ], function( i, prop ) {
			jQuery.cssHooks[ prop ] = {
				get: function( elem, computed ) {
					if ( computed ) {
						var ret = curCSS( elem, prop );
						// if curCSS returns percentage, fallback to offset
						return rnumnonpx.test( ret ) ? jQuery( elem ).position()[ prop ] + &quot;px&quot; : ret;
					}
				}
			};
		});
	}

});

if ( jQuery.expr &amp;&amp; jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		return ( elem.offsetWidth === 0 &amp;&amp; elem.offsetHeight === 0 ) || (!jQuery.support.reliableHiddenOffsets &amp;&amp; ((elem.style &amp;&amp; elem.style.display) || curCSS( elem, &quot;display&quot; )) === &quot;none&quot;);
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}

// These hooks are used by animate to expand properties
jQuery.each({
	margin: &quot;&quot;,
	padding: &quot;&quot;,
	border: &quot;Width&quot;
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i,

				// assumes a single number if not a string
				parts = typeof value === &quot;string&quot; ? value.split(&quot; &quot;) : [ value ],
				expanded = {};

			for ( i = 0; i &lt; 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});
var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	rselectTextarea = /^(?:select|textarea)/i;

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function(){
			return this.elements ? jQuery.makeArray( this.elements ) : this;
		})
		.filter(function(){
			return this.name &amp;&amp; !this.disabled &amp;&amp;
				( this.checked || rselectTextarea.test( this.nodeName ) ||
					rinput.test( this.type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val, i ){
						return { name: elem.name, value: val.replace( rCRLF, &quot;\r\n&quot; ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, &quot;\r\n&quot; ) };
		}).get();
	}
});

//Serialize an array of form elements or a set of
//key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? &quot;&quot; : value );
			s[ s.length ] = encodeURIComponent( key ) + &quot;=&quot; + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery &lt;= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings &amp;&amp; jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery &amp;&amp; !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the &quot;old&quot; way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( &quot;&amp;&quot; ).replace( r20, &quot;+&quot; );
};

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// If array item is non-scalar (array or object), encode its
				// numeric index to resolve deserialization ambiguity issues.
				// Note that rack (as of 1.0.0) can&#x27;t currently deserialize
				// nested arrays properly, and attempting to do so may cause
				// a server error. Possible fixes are to modify rack&#x27;s
				// deserialization algorithm or to provide an option or flag
				// to force array serialization to be shallow.
				buildParams( prefix + &quot;[&quot; + ( typeof v === &quot;object&quot; ? i : &quot;&quot; ) + &quot;]&quot;, v, traditional, add );
			}
		});

	} else if ( !traditional &amp;&amp; jQuery.type( obj ) === &quot;object&quot; ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + &quot;[&quot; + name + &quot;]&quot;, obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}
var
	// Document location
	ajaxLocParts,
	ajaxLocation,

	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /&lt;script\b[^&lt;]*(?:(?!&lt;\/script&gt;)&lt;[^&lt;]*)*&lt;\/script&gt;/gi,
	rts = /([?&amp;])_=[^&amp;]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol &quot;*&quot; can be used
	 * 5) execution will start with transport dataType and THEN continue down to &quot;*&quot; if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol &quot;*&quot; can be used
	 * 3) selection will start with transport dataType and THEN go to &quot;*&quot; if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = [&quot;*/&quot;] + [&quot;*&quot;];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( &quot;a&quot; );
	ajaxLocation.href = &quot;&quot;;
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base &quot;constructor&quot; for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to &quot;*&quot;
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== &quot;string&quot; ) {
			func = dataTypeExpression;
			dataTypeExpression = &quot;*&quot;;
		}

		var dataType, list, placeBefore,
			dataTypes = dataTypeExpression.toLowerCase().split( core_rspace ),
			i = 0,
			length = dataTypes.length;

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			for ( ; i &lt; length; i++ ) {
				dataType = dataTypes[ i ];
				// We control if we&#x27;re asked to add before
				// any existing element
				placeBefore = /^\+/.test( dataType );
				if ( placeBefore ) {
					dataType = dataType.substr( 1 ) || &quot;*&quot;;
				}
				list = structure[ dataType ] = structure[ dataType ] || [];
				// then we add to the structure accordingly
				list[ placeBefore ? &quot;unshift&quot; : &quot;push&quot; ]( func );
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */ ) {

	dataType = dataType || options.dataTypes[ 0 ];
	inspected = inspected || {};

	inspected[ dataType ] = true;

	var selection,
		list = structure[ dataType ],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = ( structure === prefilters );

	for ( ; i &lt; length &amp;&amp; ( executeOnly || !selection ); i++ ) {
		selection = list[ i ]( options, originalOptions, jqXHR );
		// If we got redirected to another dataType
		// we try there if executing only and not done already
		if ( typeof selection === &quot;string&quot; ) {
			if ( !executeOnly || inspected[ selection ] ) {
				selection = undefined;
			} else {
				options.dataTypes.unshift( selection );
				selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected );
			}
		}
	}
	// If we&#x27;re only executing or nothing was selected
	// we try the catchall dataType if not done already
	if ( ( executeOnly || !selection ) &amp;&amp; !inspected[ &quot;*&quot; ] ) {
		selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, &quot;*&quot;, inspected );
	}
	// unnecessary when only executing (prefilters)
	// but it&#x27;ll be ignored by the caller in that case
	return selection;
}

// A special extend for ajax options
// that takes &quot;flat&quot; options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}
}

jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== &quot;string&quot; &amp;&amp; _load ) {
		return _load.apply( this, arguments );
	}

	// Don&#x27;t do a request if no elements are being requested
	if ( !this.length ) {
		return this;
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(&quot; &quot;);

	if ( off &gt;= 0 ) {
		selector = url.slice( off, url.length );
		url = url.slice( 0, off );
	}

	// If it&#x27;s a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it&#x27;s the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params &amp;&amp; typeof params === &quot;object&quot; ) {
		type = &quot;POST&quot;;
	}

	// Request the remote document
	jQuery.ajax({
		url: url,

		// if &quot;type&quot; variable is undefined, then &quot;GET&quot; method will be used
		type: type,
		dataType: &quot;html&quot;,
		data: params,
		complete: function( jqXHR, status ) {
			if ( callback ) {
				self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
			}
		}
	}).done(function( responseText ) {

		// Save response for use in complete callback
		response = arguments;

		// See if a selector was specified
		self.html( selector ?

			// Create a dummy div to hold the results
			jQuery(&quot;&lt;div&gt;&quot;)

				// inject the contents of the document in, removing the scripts
				// to avoid any &#x27;Permission Denied&#x27; errors in IE
				.append( responseText.replace( rscript, &quot;&quot; ) )

				// Locate the specified elements
				.find( selector ) :

			// If not, just inject the full result
			responseText );

	});

	return this;
};

// Attach a bunch of functions for handling common AJAX events
jQuery.each( &quot;ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend&quot;.split( &quot; &quot; ), function( i, o ){
	jQuery.fn[ o ] = function( f ){
		return this.on( o, f );
	};
});

jQuery.each( [ &quot;get&quot;, &quot;post&quot; ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			type: method,
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	};
});

jQuery.extend({

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, &quot;script&quot; );
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, &quot;json&quot; );
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		if ( settings ) {
			// Building a settings object
			ajaxExtend( target, jQuery.ajaxSettings );
		} else {
			// Extending ajaxSettings
			settings = target;
			target = jQuery.ajaxSettings;
		}
		ajaxExtend( target, settings );
		return target;
	},

	ajaxSettings: {
		url: ajaxLocation,
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		type: &quot;GET&quot;,
		contentType: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;,
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			xml: &quot;application/xml, text/xml&quot;,
			html: &quot;text/html&quot;,
			text: &quot;text/plain&quot;,
			json: &quot;application/json, text/javascript&quot;,
			&quot;*&quot;: allTypes
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: &quot;responseXML&quot;,
			text: &quot;responseText&quot;
		},

		// List of data converters
		// 1) key format is &quot;source_type destination_type&quot; (a single space in-between)
		// 2) the catchall symbol &quot;*&quot; can be used for source_type
		converters: {

			// Convert anything to text
			&quot;* text&quot;: window.String,

			// Text to html (true = no transformation)
			&quot;text html&quot;: true,

			// Evaluate text as a json expression
			&quot;text json&quot;: jQuery.parseJSON,

			// Parse text as xml
			&quot;text xml&quot;: jQuery.parseXML
		},

		// For options that shouldn&#x27;t be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn&#x27;t be
		// deep extended (see ajaxExtend)
		flatOptions: {
			context: true,
			url: true
		}
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === &quot;object&quot; ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // ifModified key
			ifModifiedKey,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// transport
			transport,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events
			// It&#x27;s the callbackContext if one was provided in the options
			// and if it&#x27;s a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &amp;&amp;
				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
						jQuery( callbackContext ) : jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( &quot;once memory&quot; ),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = &quot;canceled&quot;,
			// Fake xhr
			jqXHR = {

				readyState: 0,

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( !state ) {
						var lname = name.toLowerCase();
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match === undefined ? null : match;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					statusText = statusText || strAbort;
					if ( transport ) {
						transport.abort( statusText );
					}
					done( 0, statusText );
					return this;
				}
			};

		// Callback for when everything is done
		// It is defined here because jslint complains if it is declared
		// at the end of the function (which would be more logical and readable)
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is &quot;done&quot; now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || &quot;&quot;;

			// Set readyState
			jqXHR.readyState = status &gt; 0 ? 4 : 0;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// If successful, handle type chaining
			if ( status &gt;= 200 &amp;&amp; status &lt; 300 || status === 304 ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {

					modified = jqXHR.getResponseHeader(&quot;Last-Modified&quot;);
					if ( modified ) {
						jQuery.lastModified[ ifModifiedKey ] = modified;
					}
					modified = jqXHR.getResponseHeader(&quot;Etag&quot;);
					if ( modified ) {
						jQuery.etag[ ifModifiedKey ] = modified;
					}
				}

				// If not modified
				if ( status === 304 ) {

					statusText = &quot;notmodified&quot;;
					isSuccess = true;

				// If we have data
				} else {

					isSuccess = ajaxConvert( s, response );
					statusText = isSuccess.state;
					success = isSuccess.data;
					error = isSuccess.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( !statusText || status ) {
					statusText = &quot;error&quot;;
					if ( status &lt; 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + &quot;&quot;;

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( &quot;ajax&quot; + ( isSuccess ? &quot;Success&quot; : &quot;Error&quot; ),
						[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( &quot;ajaxComplete&quot;, [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( &quot;ajaxStop&quot; );
				}
			}
		}

		// Attach deferreds
		deferred.promise( jqXHR );
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;
		jqXHR.complete = completeDeferred.add;

		// Status-dependent callbacks
		jqXHR.statusCode = function( map ) {
			if ( map ) {
				var tmp;
				if ( state &lt; 2 ) {
					for ( tmp in map ) {
						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
					}
				} else {
					tmp = map[ jqXHR.status ];
					jqXHR.always( tmp );
				}
			}
			return this;
		};

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// We also use the url parameter if available
		s.url = ( ( url || s.url ) + &quot;&quot; ).replace( rhash, &quot;&quot; ).replace( rprotocol, ajaxLocParts[ 1 ] + &quot;//&quot; );

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || &quot;*&quot; ).toLowerCase().split( core_rspace );

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() ) || false;
			s.crossDomain = parts &amp;&amp; ( parts.join(&quot;:&quot;) + ( parts[ 3 ] ? &quot;&quot; : parts[ 1 ] === &quot;http:&quot; ? 80 : 443 ) ) !==
				( ajaxLocParts.join(&quot;:&quot;) + ( ajaxLocParts[ 3 ] ? &quot;&quot; : ajaxLocParts[ 1 ] === &quot;http:&quot; ? 80 : 443 ) );
		}

		// Convert data if not already a string
		if ( s.data &amp;&amp; s.processData &amp;&amp; typeof s.data !== &quot;string&quot; ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Watch for a new set of requests
		if ( fireGlobals &amp;&amp; jQuery.active++ === 0 ) {
			jQuery.event.trigger( &quot;ajaxStart&quot; );
		}

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				s.url += ( rquery.test( s.url ) ? &quot;&amp;&quot; : &quot;?&quot; ) + s.data;
				// #9682: remove data so that it&#x27;s not used in an eventual retry
				delete s.data;
			}

			// Get ifModifiedKey before adding the anti-cache parameter
			ifModifiedKey = s.url;

			// Add anti-cache in url if needed
			if ( s.cache === false ) {

				var ts = jQuery.now(),
					// try replacing _= if it is there
					ret = s.url.replace( rts, &quot;$1_=&quot; + ts );

				// if nothing was replaced, add timestamp to the end
				s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? &quot;&amp;&quot; : &quot;?&quot; ) + &quot;_=&quot; + ts : &quot;&quot; );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data &amp;&amp; s.hasContent &amp;&amp; s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( &quot;Content-Type&quot;, s.contentType );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			ifModifiedKey = ifModifiedKey || s.url;
			if ( jQuery.lastModified[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( &quot;If-Modified-Since&quot;, jQuery.lastModified[ ifModifiedKey ] );
			}
			if ( jQuery.etag[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( &quot;If-None-Match&quot;, jQuery.etag[ ifModifiedKey ] );
			}
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			&quot;Accept&quot;,
			s.dataTypes[ 0 ] &amp;&amp; s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== &quot;*&quot; ? &quot;, &quot; + allTypes + &quot;; q=0.01&quot; : &quot;&quot; ) :
				s.accepts[ &quot;*&quot; ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &amp;&amp; ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already and return
				return jqXHR.abort();

		}

		// aborting is no longer a cancellation
		strAbort = &quot;abort&quot;;

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, &quot;No Transport&quot; );
		} else {
			jqXHR.readyState = 1;
			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( &quot;ajaxSend&quot;, [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async &amp;&amp; s.timeout &gt; 0 ) {
				timeoutTimer = setTimeout( function(){
					jqXHR.abort( &quot;timeout&quot; );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch (e) {
				// Propagate exception as error if not done
				if ( state &lt; 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		return jqXHR;
	},

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields;

	// Fill responseXXX fields
	for ( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === &quot;*&quot; ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( &quot;content-type&quot; );
		}
	}

	// Check if we&#x27;re dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] &amp;&amp; contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + &quot; &quot; + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

	var conv, conv2, current, tmp,
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice(),
		prev = dataTypes[ 0 ],
		converters = {},
		i = 0;

	// Apply the dataFilter if provided
	if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	// Convert to each sequential dataType, tolerating list modification
	for ( ; (current = dataTypes[++i]); ) {

		// There&#x27;s only work to do if current dataType is non-auto
		if ( current !== &quot;*&quot; ) {

			// Convert response if prev dataType is non-auto and differs from current
			if ( prev !== &quot;*&quot; &amp;&amp; prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + &quot; &quot; + current ] || converters[ &quot;* &quot; + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split(&quot; &quot;);
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + &quot; &quot; + tmp[ 0 ] ] ||
								converters[ &quot;* &quot; + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.splice( i--, 0, current );
								}

								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv &amp;&amp; s[&quot;throws&quot;] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: &quot;parsererror&quot;, error: conv ? e : &quot;No conversion from &quot; + prev + &quot; to &quot; + current };
						}
					}
				}
			}

			// Update prev for next iteration
			prev = current;
		}
	}

	return { state: &quot;success&quot;, data: response };
}
var oldCallbacks = [],
	rquestion = /\?/,
	rjsonp = /(=)\?(?=&amp;|$)|\?\?/,
	nonce = jQuery.now();

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: &quot;callback&quot;,
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + &quot;_&quot; + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( &quot;json jsonp&quot;, function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		data = s.data,
		url = s.url,
		hasCallback = s.jsonp !== false,
		replaceInUrl = hasCallback &amp;&amp; rjsonp.test( url ),
		replaceInData = hasCallback &amp;&amp; !replaceInUrl &amp;&amp; typeof data === &quot;string&quot; &amp;&amp;
			!( s.contentType || &quot;&quot; ).indexOf(&quot;application/x-www-form-urlencoded&quot;) &amp;&amp;
			rjsonp.test( data );

	// Handle iff the expected data type is &quot;jsonp&quot; or we have a parameter to set
	if ( s.dataTypes[ 0 ] === &quot;jsonp&quot; || replaceInUrl || replaceInData ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;
		overwritten = window[ callbackName ];

		// Insert callback into url or form data
		if ( replaceInUrl ) {
			s.url = url.replace( rjsonp, &quot;$1&quot; + callbackName );
		} else if ( replaceInData ) {
			s.data = data.replace( rjsonp, &quot;$1&quot; + callbackName );
		} else if ( hasCallback ) {
			s.url += ( rquestion.test( url ) ? &quot;&amp;&quot; : &quot;?&quot; ) + s.jsonp + &quot;=&quot; + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[&quot;script json&quot;] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + &quot; was not called&quot; );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = &quot;json&quot;;

		// Install callback
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn&#x27;t screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer &amp;&amp; jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return &quot;script&quot;;
	}
});
// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: &quot;text/javascript, application/javascript, application/ecmascript, application/x-ecmascript&quot;
	},
	contents: {
		script: /javascript|ecmascript/
	},
	converters: {
		&quot;text script&quot;: function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache&#x27;s special case and global
jQuery.ajaxPrefilter( &quot;script&quot;, function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = &quot;GET&quot;;
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( &quot;script&quot;, function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || document.getElementsByTagName( &quot;head&quot; )[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement( &quot;script&quot; );

				script.async = &quot;async&quot;;

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( head &amp;&amp; script.parentNode ) {
							head.removeChild( script );
						}

						// Dereference the script
						script = undefined;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, &quot;success&quot; );
						}
					}
				};
				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
				// This arises when a base node is used (#2709 and #4378).
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( 0, 1 );
				}
			}
		};
	}
});
var xhrCallbacks,
	// #5280: Internet Explorer will keep connections alive if we don&#x27;t abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function() {
		// Abort all pending requests
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( 0, 1 );
		}
	} : false,
	xhrId = 0;

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( &quot;Microsoft.XMLHTTP&quot; );
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can&#x27;t request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal &amp;&amp; createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
(function( xhr ) {
	jQuery.extend( jQuery.support, {
		ajax: !!xhr,
		cors: !!xhr &amp;&amp; ( &quot;withCredentials&quot; in xhr )
	});
})( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var handle, i,
						xhr = s.xhr();

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType &amp;&amp; xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won&#x27;t change header if already provided.
					if ( !s.crossDomain &amp;&amp; !headers[&quot;X-Requested-With&quot;] ) {
						headers[ &quot;X-Requested-With&quot; ] = &quot;XMLHttpRequest&quot;;
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( _ ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent &amp;&amp; s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {

						var status,
							statusText,
							responseHeaders,
							responses,
							xml;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occurred
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback &amp;&amp; ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it&#x27;s an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();
									responses = {};
									xml = xhr.responseXML;

									// Construct response list
									if ( xml &amp;&amp; xml.documentElement /* #4958 */ ) {
										responses.xml = xml;
									}

									// When requesting binary data, IE6-9 will throw an exception
									// on any attempt to access responseText (#11426)
									try {
										responses.text = xhr.responseText;
									} catch( _ ) {
									}

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = &quot;&quot;;
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won&#x27;t get notified, that&#x27;s the best we
									// can do given current implementations)
									if ( !status &amp;&amp; s.isLocal &amp;&amp; !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					if ( !s.async ) {
						// if we&#x27;re in sync mode we fire the callback
						callback();
					} else if ( xhr.readyState === 4 ) {
						// (IE6 &amp; IE7) if it&#x27;s in cache and has been
						// retrieved directly we need to fire the callback
						setTimeout( callback, 0 );
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback(0,1);
					}
				}
			};
		}
	});
}
var fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( &quot;^(?:([-+])=|)(&quot; + core_pnum + &quot;)([a-z%]*)$&quot;, &quot;i&quot; ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		&quot;*&quot;: [function( prop, value ) {
			var end, unit,
				tween = this.createTween( prop, value ),
				parts = rfxnum.exec( value ),
				target = tween.cur(),
				start = +target || 0,
				scale = 1,
				maxIterations = 20;

			if ( parts ) {
				end = +parts[2];
				unit = parts[3] || ( jQuery.cssNumber[ prop ] ? &quot;&quot; : &quot;px&quot; );

				// We need to compute starting value
				if ( unit !== &quot;px&quot; &amp;&amp; start ) {
					// Iteratively approximate from a nonzero starting point
					// Prefer the current property, because this process will be trivial if it uses the same units
					// Fallback to end or a simple constant
					start = jQuery.css( tween.elem, prop, true ) || end || 1;

					do {
						// If previous iteration zeroed out, double until we get *something*
						// Use a string for doubling factor so we don&#x27;t accidentally see scale as unchanged below
						scale = scale || &quot;.5&quot;;

						// Adjust and apply
						start = start / scale;
						jQuery.style( tween.elem, prop, start + unit );

					// Update scale, tolerating zero or NaN from tween.cur()
					// And breaking the loop if scale is unchanged or perfect, or if we&#x27;ve just had enough
					} while ( scale !== (scale = tween.cur() / target) &amp;&amp; scale !== 1 &amp;&amp; --maxIterations );
				}

				tween.unit = unit;
				tween.start = start;
				// If a +=/-= token was provided, we&#x27;re doing a relative animation
				tween.end = parts[1] ? start + ( parts[1] + 1 ) * end : end;
			}
			return tween;
		}]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	}, 0 );
	return ( fxNow = jQuery.now() );
}

function createTweens( animation, props ) {
	jQuery.each( props, function( prop, value ) {
		var collection = ( tweeners[ prop ] || [] ).concat( tweeners[ &quot;*&quot; ] ),
			index = 0,
			length = collection.length;
		for ( ; index &lt; length; index++ ) {
			if ( collection[ index ].call( animation, prop, value ) ) {

				// we&#x27;re done with this property
				return;
			}
		}
	});
}

function Animation( elem, properties, options ) {
	var result,
		index = 0,
		tweenerIndex = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don&#x27;t match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				percent = 1 - ( remaining / animation.duration || 0 ),
				index = 0,
				length = animation.tweens.length;

			for ( ; index &lt; length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent &lt; 1 &amp;&amp; length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end, easing ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;

				for ( ; index &lt; length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index &lt; length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	createTweens( animation, props );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			anim: animation,
			queue: animation.opts.queue,
			elem: elem
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks &amp;&amp; &quot;expand&quot; in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing &#x27;index&#x27; from above because we have the correct &quot;name&quot;
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ &quot;*&quot; ];
		} else {
			props = props.split(&quot; &quot;);
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index &lt; length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

function defaultPrefilter( elem, props, opts ) {
	var index, prop, value, length, dataShow, tween, hooks, oldfire,
		anim = this,
		style = elem.style,
		orig = {},
		handled = [],
		hidden = elem.nodeType &amp;&amp; isHidden( elem );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, &quot;fx&quot; );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, &quot;fx&quot; ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 &amp;&amp; ( &quot;height&quot; in props || &quot;width&quot; in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE does not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		if ( jQuery.css( elem, &quot;display&quot; ) === &quot;inline&quot; &amp;&amp;
				jQuery.css( elem, &quot;float&quot; ) === &quot;none&quot; ) {

			// inline-level elements accept inline-block;
			// block-level elements need to be inline with layout
			if ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === &quot;inline&quot; ) {
				style.display = &quot;inline-block&quot;;

			} else {
				style.zoom = 1;
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = &quot;hidden&quot;;
		if ( !jQuery.support.shrinkWrapBlocks ) {
			anim.done(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}
	}


	// show/hide pass
	for ( index in props ) {
		value = props[ index ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ index ];
			if ( value === ( hidden ? &quot;hide&quot; : &quot;show&quot; ) ) {
				continue;
			}
			handled.push( index );
		}
	}

	length = handled.length;
	if ( length ) {
		dataShow = jQuery._data( elem, &quot;fxshow&quot; ) || jQuery._data( elem, &quot;fxshow&quot;, {} );
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;
			jQuery.removeData( elem, &quot;fxshow&quot;, true );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( index = 0 ; index &lt; length ; index++ ) {
			prop = handled[ index ];
			tween = anim.createTween( prop, hidden ? dataShow[ prop ] : 0 );
			orig[ prop ] = dataShow[ prop ] || jQuery.style( elem, prop );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === &quot;width&quot; || prop === &quot;height&quot; ? 1 : 0;
				}
			}
		}
	}
}

function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || &quot;swing&quot;;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? &quot;&quot; : &quot;px&quot; );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks &amp;&amp; hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks &amp;&amp; hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &amp;&amp;
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing any value as a 4th parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as &quot;10px&quot; are parsed to Float.
			// complex values such as &quot;rotate(1rad)&quot; are returned as is.
			result = jQuery.css( tween.elem, tween.prop, false, &quot;&quot; );
			// Empty strings, null, undefined and &quot;auto&quot; are converted to 0.
			return !result || result === &quot;auto&quot; ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style &amp;&amp; ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Remove in 2.0 - this supports IE8&#x27;s panic based approach
// to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType &amp;&amp; tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.each([ &quot;toggle&quot;, &quot;show&quot;, &quot;hide&quot; ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === &quot;boolean&quot; ||
			// special check for .toggle( handler, handler, ... )
			( !i &amp;&amp; jQuery.isFunction( speed ) &amp;&amp; jQuery.isFunction( easing ) ) ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( &quot;opacity&quot;, 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won&#x27;t be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations resolve immediately
				if ( empty ) {
					anim.stop( true );
				}
			};

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== &quot;string&quot; ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue &amp;&amp; type !== false ) {
			this.queue( type || &quot;fx&quot;, [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null &amp;&amp; type + &quot;queueHooks&quot;,
				timers = jQuery.timers,
				data = jQuery._data( this );

			if ( index ) {
				if ( data[ index ] &amp;&amp; data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] &amp;&amp; data[ index ].stop &amp;&amp; rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &amp;&amp; (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn&#x27;t forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	}
});

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		attrs = { height: type },
		i = 0;

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don&#x27;t include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth? 1 : 0;
	for( ; i &lt; 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ &quot;margin&quot; + which ] = attrs[ &quot;padding&quot; + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx(&quot;show&quot;),
	slideUp: genFx(&quot;hide&quot;),
	slideToggle: genFx(&quot;toggle&quot;),
	fadeIn: { opacity: &quot;show&quot; },
	fadeOut: { opacity: &quot;hide&quot; },
	fadeToggle: { opacity: &quot;toggle&quot; }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed &amp;&amp; typeof speed === &quot;object&quot; ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn &amp;&amp; easing ||
			jQuery.isFunction( speed ) &amp;&amp; speed,
		duration: speed,
		easing: fn &amp;&amp; easing || easing &amp;&amp; !jQuery.isFunction( easing ) &amp;&amp; easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === &quot;number&quot; ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -&gt; &quot;fx&quot;
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = &quot;fx&quot;;
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p*Math.PI ) / 2;
	}
};

jQuery.timers = [];
jQuery.fx = Tween.prototype.init;
jQuery.fx.tick = function() {
	var timer,
		timers = jQuery.timers,
		i = 0;

	for ( ; i &lt; timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() &amp;&amp; timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
};

jQuery.fx.timer = function( timer ) {
	if ( timer() &amp;&amp; jQuery.timers.push( timer ) &amp;&amp; !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.interval = 13;

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};

// Back Compat &lt;1.8 extension point
jQuery.fx.step = {};

if ( jQuery.expr &amp;&amp; jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}
var rroot = /^(?:body|html)$/i;

jQuery.fn.offset = function( options ) {
	if ( arguments.length ) {
		return options === undefined ?
			this :
			this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
	}

	var docElem, body, win, clientTop, clientLeft, scrollTop, scrollLeft,
		box = { top: 0, left: 0 },
		elem = this[ 0 ],
		doc = elem &amp;&amp; elem.ownerDocument;

	if ( !doc ) {
		return;
	}

	if ( (body = doc.body) === elem ) {
		return jQuery.offset.bodyOffset( elem );
	}

	docElem = doc.documentElement;

	// Make sure it&#x27;s not a disconnected DOM node
	if ( !jQuery.contains( docElem, elem ) ) {
		return box;
	}

	// If we don&#x27;t have gBCR, just use 0,0 rather than error
	// BlackBerry 5, iOS 3 (original iPhone)
	if ( typeof elem.getBoundingClientRect !== &quot;undefined&quot; ) {
		box = elem.getBoundingClientRect();
	}
	win = getWindow( doc );
	clientTop  = docElem.clientTop  || body.clientTop  || 0;
	clientLeft = docElem.clientLeft || body.clientLeft || 0;
	scrollTop  = win.pageYOffset || docElem.scrollTop;
	scrollLeft = win.pageXOffset || docElem.scrollLeft;
	return {
		top: box.top  + scrollTop  - clientTop,
		left: box.left + scrollLeft - clientLeft
	};
};

jQuery.offset = {

	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;

		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, &quot;marginTop&quot;) ) || 0;
			left += parseFloat( jQuery.css(body, &quot;marginLeft&quot;) ) || 0;
		}

		return { top: top, left: left };
	},

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, &quot;position&quot; );

		// set position first, in-case top/left are set even on static elem
		if ( position === &quot;static&quot; ) {
			elem.style.position = &quot;relative&quot;;
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, &quot;top&quot; ),
			curCSSLeft = jQuery.css( elem, &quot;left&quot; ),
			calculatePosition = ( position === &quot;absolute&quot; || position === &quot;fixed&quot; ) &amp;&amp; jQuery.inArray(&quot;auto&quot;, [curCSSTop, curCSSLeft]) &gt; -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( &quot;using&quot; in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[0] ) {
			return;
		}

		var elem = this[0],

		// Get *real* offsetParent
		offsetParent = this.offsetParent(),

		// Get correct offsets
		offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

		// Subtract element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		offset.top  -= parseFloat( jQuery.css(elem, &quot;marginTop&quot;) ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, &quot;marginLeft&quot;) ) || 0;

		// Add offsetParent borders
		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], &quot;borderTopWidth&quot;) ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], &quot;borderLeftWidth&quot;) ) || 0;

		// Subtract the two offsets
		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent &amp;&amp; (!rroot.test(offsetParent.nodeName) &amp;&amp; jQuery.css(offsetParent, &quot;position&quot;) === &quot;static&quot;) ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent || document.body;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( {scrollLeft: &quot;pageXOffset&quot;, scrollTop: &quot;pageYOffset&quot;}, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return jQuery.access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					win.document.documentElement[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					 top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}
// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: &quot;height&quot;, Width: &quot;width&quot; }, function( name, type ) {
	jQuery.each( { padding: &quot;inner&quot; + name, content: type, &quot;&quot;: &quot;outer&quot; + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length &amp;&amp; ( defaultExtra || typeof margin !== &quot;boolean&quot; ),
				extra = defaultExtra || ( margin === true || value === true ? &quot;margin&quot; : &quot;border&quot; );

			return jQuery.access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn&#x27;t a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ &quot;client&quot; + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
					// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
					return Math.max(
						elem.body[ &quot;scroll&quot; + name ], doc[ &quot;scroll&quot; + name ],
						elem.body[ &quot;offset&quot; + name ], doc[ &quot;offset&quot; + name ],
						doc[ &quot;client&quot; + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, value, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});
// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === &quot;function&quot; &amp;&amp; define.amd &amp;&amp; define.amd.jQuery ) {
	define( &quot;jquery&quot;, [], function () { return jQuery; } );
}

})( window );

/**
 * @license AngularJS v1.1.5
 * (c) 2010-2012 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, document){
  var _jQuery = window.jQuery.noConflict(true);

////////////////////////////////////

/**
 * @ngdoc function
 * @name angular.lowercase
 * @function
 *
 * @description Converts the specified string to lowercase.
 * @param {string} string String to be converted to lowercase.
 * @returns {string} Lowercased string.
 */
var lowercase = function(string){return isString(string) ? string.toLowerCase() : string;};


/**
 * @ngdoc function
 * @name angular.uppercase
 * @function
 *
 * @description Converts the specified string to uppercase.
 * @param {string} string String to be converted to uppercase.
 * @returns {string} Uppercased string.
 */
var uppercase = function(string){return isString(string) ? string.toUpperCase() : string;};


var manualLowercase = function(s) {
  return isString(s)
      ? s.replace(/[A-Z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) | 32);})
      : s;
};
var manualUppercase = function(s) {
  return isString(s)
      ? s.replace(/[a-z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) &amp; ~32);})
      : s;
};


// String#toLowerCase and String#toUpperCase don&#x27;t produce correct results in browsers with Turkish
// locale, for this reason we need to detect this case and redefine lowercase/uppercase methods
// with correct but slower alternatives.
if (&#x27;i&#x27; !== &#x27;I&#x27;.toLowerCase()) {
  lowercase = manualLowercase;
  uppercase = manualUppercase;
}


var /** holds major version number for IE or NaN for real browsers */
    msie              = int((/msie (\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]),
    jqLite,           // delay binding since jQuery could be loaded after us.
    jQuery,           // delay binding
    slice             = [].slice,
    push              = [].push,
    toString          = Object.prototype.toString,


    _angular          = window.angular,
    /** @name angular */
    angular           = window.angular || (window.angular = {}),
    angularModule,
    nodeName_,
    uid               = [&#x27;0&#x27;, &#x27;0&#x27;, &#x27;0&#x27;];

/**
 * @ngdoc function
 * @name angular.noConflict
 * @function
 *
 * @description
 * Restores the previous global value of angular and returns the current instance. Other libraries may already use the
 * angular namespace. Or a previous version of angular is already loaded on the page. In these cases you may want to
 * restore the previous namespace and keep a reference to angular.
 *
 * @return {Object} The current angular namespace
 */
function noConflict() {
  var a = window.angular;
  window.angular = _angular;
  return a;
}

/**
 * @private
 * @param {*} obj
 * @return {boolean} Returns true if &#x60;obj&#x60; is an array or array-like object (NodeList, Arguments, ...)
 */
function isArrayLike(obj) {
  if (!obj || (typeof obj.length !== &#x27;number&#x27;)) return false;

  // We have on object which has length property. Should we treat it as array?
  if (typeof obj.hasOwnProperty != &#x27;function&#x27; &amp;&amp;
      typeof obj.constructor != &#x27;function&#x27;) {
    // This is here for IE8: it is a bogus object treat it as array;
    return true;
  } else  {
    return obj instanceof JQLite ||                      // JQLite
           (jQuery &amp;&amp; obj instanceof jQuery) ||          // jQuery
           toString.call(obj) !== &#x27;[object Object]&#x27; ||   // some browser native object
           typeof obj.callee === &#x27;function&#x27;;              // arguments (on IE8 looks like regular obj)
  }
}

/**
 * @ngdoc function
 * @name angular.forEach
 * @function
 *
 * @description
 * Invokes the &#x60;iterator&#x60; function once for each item in &#x60;obj&#x60; collection, which can be either an
 * object or an array. The &#x60;iterator&#x60; function is invoked with &#x60;iterator(value, key)&#x60;, where &#x60;value&#x60;
 * is the value of an object property or an array element and &#x60;key&#x60; is the object property key or
 * array element index. Specifying a &#x60;context&#x60; for the function is optional.
 *
 * Note: this function was previously known as &#x60;angular.foreach&#x60;.
 *
   &lt;pre&gt;
     var values = {name: &#x27;misko&#x27;, gender: &#x27;male&#x27;};
     var log = [];
     angular.forEach(values, function(value, key){
       this.push(key + &#x27;: &#x27; + value);
     }, log);
     expect(log).toEqual([&#x27;name: misko&#x27;, &#x27;gender:male&#x27;]);
   &lt;/pre&gt;
 *
 * @param {Object|Array} obj Object to iterate over.
 * @param {Function} iterator Iterator function.
 * @param {Object=} context Object to become context (&#x60;this&#x60;) for the iterator function.
 * @returns {Object|Array} Reference to &#x60;obj&#x60;.
 */
function forEach(obj, iterator, context) {
  var key;
  if (obj) {
    if (isFunction(obj)){
      for (key in obj) {
        if (key != &#x27;prototype&#x27; &amp;&amp; key != &#x27;length&#x27; &amp;&amp; key != &#x27;name&#x27; &amp;&amp; obj.hasOwnProperty(key)) {
          iterator.call(context, obj[key], key);
        }
      }
    } else if (obj.forEach &amp;&amp; obj.forEach !== forEach) {
      obj.forEach(iterator, context);
    } else if (isArrayLike(obj)) {
      for (key = 0; key &lt; obj.length; key++)
        iterator.call(context, obj[key], key);
    } else {
      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          iterator.call(context, obj[key], key);
        }
      }
    }
  }
  return obj;
}

function sortedKeys(obj) {
  var keys = [];
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      keys.push(key);
    }
  }
  return keys.sort();
}

function forEachSorted(obj, iterator, context) {
  var keys = sortedKeys(obj);
  for ( var i = 0; i &lt; keys.length; i++) {
    iterator.call(context, obj[keys[i]], keys[i]);
  }
  return keys;
}


/**
 * when using forEach the params are value, key, but it is often useful to have key, value.
 * @param {function(string, *)} iteratorFn
 * @returns {function(*, string)}
 */
function reverseParams(iteratorFn) {
  return function(value, key) { iteratorFn(key, value) };
}

/**
 * A consistent way of creating unique IDs in angular. The ID is a sequence of alpha numeric
 * characters such as &#x27;012ABC&#x27;. The reason why we are not using simply a number counter is that
 * the number string gets longer over time, and it can also overflow, where as the nextId
 * will grow much slower, it is a string, and it will never overflow.
 *
 * @returns an unique alpha-numeric string
 */
function nextUid() {
  var index = uid.length;
  var digit;

  while(index) {
    index--;
    digit = uid[index].charCodeAt(0);
    if (digit == 57 /*&#x27;9&#x27;*/) {
      uid[index] = &#x27;A&#x27;;
      return uid.join(&#x27;&#x27;);
    }
    if (digit == 90  /*&#x27;Z&#x27;*/) {
      uid[index] = &#x27;0&#x27;;
    } else {
      uid[index] = String.fromCharCode(digit + 1);
      return uid.join(&#x27;&#x27;);
    }
  }
  uid.unshift(&#x27;0&#x27;);
  return uid.join(&#x27;&#x27;);
}


/**
 * Set or clear the hashkey for an object.
 * @param obj object 
 * @param h the hashkey (!truthy to delete the hashkey)
 */
function setHashKey(obj, h) {
  if (h) {
    obj.$$hashKey = h;
  }
  else {
    delete obj.$$hashKey;
  }
}

/**
 * @ngdoc function
 * @name angular.extend
 * @function
 *
 * @description
 * Extends the destination object &#x60;dst&#x60; by copying all of the properties from the &#x60;src&#x60; object(s)
 * to &#x60;dst&#x60;. You can specify multiple &#x60;src&#x60; objects.
 *
 * @param {Object} dst Destination object.
 * @param {...Object} src Source object(s).
 * @returns {Object} Reference to &#x60;dst&#x60;.
 */
function extend(dst) {
  var h = dst.$$hashKey;
  forEach(arguments, function(obj){
    if (obj !== dst) {
      forEach(obj, function(value, key){
        dst[key] = value;
      });
    }
  });

  setHashKey(dst,h);
  return dst;
}

function int(str) {
  return parseInt(str, 10);
}


function inherit(parent, extra) {
  return extend(new (extend(function() {}, {prototype:parent}))(), extra);
}

var START_SPACE = /^\s*/;
var END_SPACE = /\s*$/;
function stripWhitespace(str) {
  return isString(str) ? str.replace(START_SPACE, &#x27;&#x27;).replace(END_SPACE, &#x27;&#x27;) : str;
}

/**
 * @ngdoc function
 * @name angular.noop
 * @function
 *
 * @description
 * A function that performs no operations. This function can be useful when writing code in the
 * functional style.
   &lt;pre&gt;
     function foo(callback) {
       var result = calculateResult();
       (callback || angular.noop)(result);
     }
   &lt;/pre&gt;
 */
function noop() {}
noop.$inject = [];


/**
 * @ngdoc function
 * @name angular.identity
 * @function
 *
 * @description
 * A function that returns its first argument. This function is useful when writing code in the
 * functional style.
 *
   &lt;pre&gt;
     function transformer(transformationFn, value) {
       return (transformationFn || identity)(value);
     };
   &lt;/pre&gt;
 */
function identity($) {return $;}
identity.$inject = [];


function valueFn(value) {return function() {return value;};}

/**
 * @ngdoc function
 * @name angular.isUndefined
 * @function
 *
 * @description
 * Determines if a reference is undefined.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if &#x60;value&#x60; is undefined.
 */
function isUndefined(value){return typeof value == &#x27;undefined&#x27;;}


/**
 * @ngdoc function
 * @name angular.isDefined
 * @function
 *
 * @description
 * Determines if a reference is defined.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if &#x60;value&#x60; is defined.
 */
function isDefined(value){return typeof value != &#x27;undefined&#x27;;}


/**
 * @ngdoc function
 * @name angular.isObject
 * @function
 *
 * @description
 * Determines if a reference is an &#x60;Object&#x60;. Unlike &#x60;typeof&#x60; in JavaScript, &#x60;null&#x60;s are not
 * considered to be objects.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if &#x60;value&#x60; is an &#x60;Object&#x60; but not &#x60;null&#x60;.
 */
function isObject(value){return value != null &amp;&amp; typeof value == &#x27;object&#x27;;}


/**
 * @ngdoc function
 * @name angular.isString
 * @function
 *
 * @description
 * Determines if a reference is a &#x60;String&#x60;.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if &#x60;value&#x60; is a &#x60;String&#x60;.
 */
function isString(value){return typeof value == &#x27;string&#x27;;}


/**
 * @ngdoc function
 * @name angular.isNumber
 * @function
 *
 * @description
 * Determines if a reference is a &#x60;Number&#x60;.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if &#x60;value&#x60; is a &#x60;Number&#x60;.
 */
function isNumber(value){return typeof value == &#x27;number&#x27;;}


/**
 * @ngdoc function
 * @name angular.isDate
 * @function
 *
 * @description
 * Determines if a value is a date.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if &#x60;value&#x60; is a &#x60;Date&#x60;.
 */
function isDate(value){
  return toString.apply(value) == &#x27;[object Date]&#x27;;
}


/**
 * @ngdoc function
 * @name angular.isArray
 * @function
 *
 * @description
 * Determines if a reference is an &#x60;Array&#x60;.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if &#x60;value&#x60; is an &#x60;Array&#x60;.
 */
function isArray(value) {
  return toString.apply(value) == &#x27;[object Array]&#x27;;
}


/**
 * @ngdoc function
 * @name angular.isFunction
 * @function
 *
 * @description
 * Determines if a reference is a &#x60;Function&#x60;.
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if &#x60;value&#x60; is a &#x60;Function&#x60;.
 */
function isFunction(value){return typeof value == &#x27;function&#x27;;}


/**
 * Checks if &#x60;obj&#x60; is a window object.
 *
 * @private
 * @param {*} obj Object to check
 * @returns {boolean} True if &#x60;obj&#x60; is a window obj.
 */
function isWindow(obj) {
  return obj &amp;&amp; obj.document &amp;&amp; obj.location &amp;&amp; obj.alert &amp;&amp; obj.setInterval;
}


function isScope(obj) {
  return obj &amp;&amp; obj.$evalAsync &amp;&amp; obj.$watch;
}


function isFile(obj) {
  return toString.apply(obj) === &#x27;[object File]&#x27;;
}


function isBoolean(value) {
  return typeof value == &#x27;boolean&#x27;;
}


function trim(value) {
  return isString(value) ? value.replace(/^\s*/, &#x27;&#x27;).replace(/\s*$/, &#x27;&#x27;) : value;
}

/**
 * @ngdoc function
 * @name angular.isElement
 * @function
 *
 * @description
 * Determines if a reference is a DOM element (or wrapped jQuery element).
 *
 * @param {*} value Reference to check.
 * @returns {boolean} True if &#x60;value&#x60; is a DOM element (or wrapped jQuery element).
 */
function isElement(node) {
  return node &amp;&amp;
    (node.nodeName  // we are a direct element
    || (node.bind &amp;&amp; node.find));  // we have a bind and find method part of jQuery API
}

/**
 * @param str &#x27;key1,key2,...&#x27;
 * @returns {object} in the form of {key1:true, key2:true, ...}
 */
function makeMap(str){
  var obj = {}, items = str.split(&quot;,&quot;), i;
  for ( i = 0; i &lt; items.length; i++ )
    obj[ items[i] ] = true;
  return obj;
}


if (msie &lt; 9) {
  nodeName_ = function(element) {
    element = element.nodeName ? element : element[0];
    return (element.scopeName &amp;&amp; element.scopeName != &#x27;HTML&#x27;)
      ? uppercase(element.scopeName + &#x27;:&#x27; + element.nodeName) : element.nodeName;
  };
} else {
  nodeName_ = function(element) {
    return element.nodeName ? element.nodeName : element[0].nodeName;
  };
}


function map(obj, iterator, context) {
  var results = [];
  forEach(obj, function(value, index, list) {
    results.push(iterator.call(context, value, index, list));
  });
  return results;
}


/**
 * @description
 * Determines the number of elements in an array, the number of properties an object has, or
 * the length of a string.
 *
 * Note: This function is used to augment the Object type in Angular expressions. See
 * {@link angular.Object} for more information about Angular arrays.
 *
 * @param {Object|Array|string} obj Object, array, or string to inspect.
 * @param {boolean} [ownPropsOnly=false] Count only &quot;own&quot; properties in an object
 * @returns {number} The size of &#x60;obj&#x60; or &#x60;0&#x60; if &#x60;obj&#x60; is neither an object nor an array.
 */
function size(obj, ownPropsOnly) {
  var size = 0, key;

  if (isArray(obj) || isString(obj)) {
    return obj.length;
  } else if (isObject(obj)){
    for (key in obj)
      if (!ownPropsOnly || obj.hasOwnProperty(key))
        size++;
  }

  return size;
}


function includes(array, obj) {
  return indexOf(array, obj) != -1;
}

function indexOf(array, obj) {
  if (array.indexOf) return array.indexOf(obj);

  for ( var i = 0; i &lt; array.length; i++) {
    if (obj === array[i]) return i;
  }
  return -1;
}

function arrayRemove(array, value) {
  var index = indexOf(array, value);
  if (index &gt;=0)
    array.splice(index, 1);
  return value;
}

function isLeafNode (node) {
  if (node) {
    switch (node.nodeName) {
    case &quot;OPTION&quot;:
    case &quot;PRE&quot;:
    case &quot;TITLE&quot;:
      return true;
    }
  }
  return false;
}

/**
 * @ngdoc function
 * @name angular.copy
 * @function
 *
 * @description
 * Creates a deep copy of &#x60;source&#x60;, which should be an object or an array.
 *
 * * If no destination is supplied, a copy of the object or array is created.
 * * If a destination is provided, all of its elements (for array) or properties (for objects)
 *   are deleted and then all elements/properties from the source are copied to it.
 * * If  &#x60;source&#x60; is not an object or array, &#x60;source&#x60; is returned.
 *
 * Note: this function is used to augment the Object type in Angular expressions. See
 * {@link ng.$filter} for more information about Angular arrays.
 *
 * @param {*} source The source that will be used to make a copy.
 *                   Can be any type, including primitives, &#x60;null&#x60;, and &#x60;undefined&#x60;.
 * @param {(Object|Array)=} destination Destination into which the source is copied. If
 *     provided, must be of the same type as &#x60;source&#x60;.
 * @returns {*} The copy or updated &#x60;destination&#x60;, if &#x60;destination&#x60; was specified.
 */
function copy(source, destination){
  if (isWindow(source) || isScope(source)) throw Error(&quot;Can&#x27;t copy Window or Scope&quot;);
  if (!destination) {
    destination = source;
    if (source) {
      if (isArray(source)) {
        destination = copy(source, []);
      } else if (isDate(source)) {
        destination = new Date(source.getTime());
      } else if (isObject(source)) {
        destination = copy(source, {});
      }
    }
  } else {
    if (source === destination) throw Error(&quot;Can&#x27;t copy equivalent objects or arrays&quot;);
    if (isArray(source)) {
      destination.length = 0;
      for ( var i = 0; i &lt; source.length; i++) {
        destination.push(copy(source[i]));
      }
    } else {
      var h = destination.$$hashKey;
      forEach(destination, function(value, key){
        delete destination[key];
      });
      for ( var key in source) {
        destination[key] = copy(source[key]);
      }
      setHashKey(destination,h);
    }
  }
  return destination;
}

/**
 * Create a shallow copy of an object
 */
function shallowCopy(src, dst) {
  dst = dst || {};

  for(var key in src) {
    if (src.hasOwnProperty(key) &amp;&amp; key.substr(0, 2) !== &#x27;$$&#x27;) {
      dst[key] = src[key];
    }
  }

  return dst;
}


/**
 * @ngdoc function
 * @name angular.equals
 * @function
 *
 * @description
 * Determines if two objects or two values are equivalent. Supports value types, arrays and
 * objects.
 *
 * Two objects or values are considered equivalent if at least one of the following is true:
 *
 * * Both objects or values pass &#x60;===&#x60; comparison.
 * * Both objects or values are of the same type and all of their properties pass &#x60;===&#x60; comparison.
 * * Both values are NaN. (In JavasScript, NaN == NaN =&gt; false. But we consider two NaN as equal)
 *
 * During a property comparison, properties of &#x60;function&#x60; type and properties with names
 * that begin with &#x60;$&#x60; are ignored.
 *
 * Scope and DOMWindow objects are being compared only by identify (&#x60;===&#x60;).
 *
 * @param {*} o1 Object or value to compare.
 * @param {*} o2 Object or value to compare.
 * @returns {boolean} True if arguments are equal.
 */
function equals(o1, o2) {
  if (o1 === o2) return true;
  if (o1 === null || o2 === null) return false;
  if (o1 !== o1 &amp;&amp; o2 !== o2) return true; // NaN === NaN
  var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
  if (t1 == t2) {
    if (t1 == &#x27;object&#x27;) {
      if (isArray(o1)) {
        if ((length = o1.length) == o2.length) {
          for(key=0; key&lt;length; key++) {
            if (!equals(o1[key], o2[key])) return false;
          }
          return true;
        }
      } else if (isDate(o1)) {
        return isDate(o2) &amp;&amp; o1.getTime() == o2.getTime();
      } else {
        if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2)) return false;
        keySet = {};
        for(key in o1) {
          if (key.charAt(0) === &#x27;$&#x27; || isFunction(o1[key])) continue;
          if (!equals(o1[key], o2[key])) return false;
          keySet[key] = true;
        }
        for(key in o2) {
          if (!keySet[key] &amp;&amp;
              key.charAt(0) !== &#x27;$&#x27; &amp;&amp;
              o2[key] !== undefined &amp;&amp;
              !isFunction(o2[key])) return false;
        }
        return true;
      }
    }
  }
  return false;
}


function concat(array1, array2, index) {
  return array1.concat(slice.call(array2, index));
}

function sliceArgs(args, startIndex) {
  return slice.call(args, startIndex || 0);
}


/**
 * @ngdoc function
 * @name angular.bind
 * @function
 *
 * @description
 * Returns a function which calls function &#x60;fn&#x60; bound to &#x60;self&#x60; (&#x60;self&#x60; becomes the &#x60;this&#x60; for
 * &#x60;fn&#x60;). You can supply optional &#x60;args&#x60; that are prebound to the function. This feature is also
 * known as [function currying](http://en.wikipedia.org/wiki/Currying).
 *
 * @param {Object} self Context which &#x60;fn&#x60; should be evaluated in.
 * @param {function()} fn Function to be bound.
 * @param {...*} args Optional arguments to be prebound to the &#x60;fn&#x60; function call.
 * @returns {function()} Function that wraps the &#x60;fn&#x60; with all the specified bindings.
 */
function bind(self, fn) {
  var curryArgs = arguments.length &gt; 2 ? sliceArgs(arguments, 2) : [];
  if (isFunction(fn) &amp;&amp; !(fn instanceof RegExp)) {
    return curryArgs.length
      ? function() {
          return arguments.length
            ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0)))
            : fn.apply(self, curryArgs);
        }
      : function() {
          return arguments.length
            ? fn.apply(self, arguments)
            : fn.call(self);
        };
  } else {
    // in IE, native methods are not functions so they cannot be bound (note: they don&#x27;t need to be)
    return fn;
  }
}


function toJsonReplacer(key, value) {
  var val = value;

  if (/^\$+/.test(key)) {
    val = undefined;
  } else if (isWindow(value)) {
    val = &#x27;$WINDOW&#x27;;
  } else if (value &amp;&amp;  document === value) {
    val = &#x27;$DOCUMENT&#x27;;
  } else if (isScope(value)) {
    val = &#x27;$SCOPE&#x27;;
  }

  return val;
}


/**
 * @ngdoc function
 * @name angular.toJson
 * @function
 *
 * @description
 * Serializes input into a JSON-formatted string.
 *
 * @param {Object|Array|Date|string|number} obj Input to be serialized into JSON.
 * @param {boolean=} pretty If set to true, the JSON output will contain newlines and whitespace.
 * @returns {string} Jsonified string representing &#x60;obj&#x60;.
 */
function toJson(obj, pretty) {
  return JSON.stringify(obj, toJsonReplacer, pretty ? &#x27;  &#x27; : null);
}


/**
 * @ngdoc function
 * @name angular.fromJson
 * @function
 *
 * @description
 * Deserializes a JSON string.
 *
 * @param {string} json JSON string to deserialize.
 * @returns {Object|Array|Date|string|number} Deserialized thingy.
 */
function fromJson(json) {
  return isString(json)
      ? JSON.parse(json)
      : json;
}


function toBoolean(value) {
  if (value &amp;&amp; value.length !== 0) {
    var v = lowercase(&quot;&quot; + value);
    value = !(v == &#x27;f&#x27; || v == &#x27;0&#x27; || v == &#x27;false&#x27; || v == &#x27;no&#x27; || v == &#x27;n&#x27; || v == &#x27;[]&#x27;);
  } else {
    value = false;
  }
  return value;
}

/**
 * @returns {string} Returns the string representation of the element.
 */
function startingTag(element) {
  element = jqLite(element).clone();
  try {
    // turns out IE does not let you set .html() on elements which
    // are not allowed to have children. So we just ignore it.
    element.html(&#x27;&#x27;);
  } catch(e) {}
  // As Per DOM Standards
  var TEXT_NODE = 3;
  var elemHtml = jqLite(&#x27;&lt;div&gt;&#x27;).append(element).html();
  try {
    return element[0].nodeType === TEXT_NODE ? lowercase(elemHtml) :
        elemHtml.
          match(/^(&lt;[^&gt;]+&gt;)/)[1].
          replace(/^&lt;([\w\-]+)/, function(match, nodeName) { return &#x27;&lt;&#x27; + lowercase(nodeName); });
  } catch(e) {
    return lowercase(elemHtml);
  }

}


/////////////////////////////////////////////////

/**
 * Parses an escaped url query string into key-value pairs.
 * @returns Object.&lt;(string|boolean)&gt;
 */
function parseKeyValue(/**string*/keyValue) {
  var obj = {}, key_value, key;
  forEach((keyValue || &quot;&quot;).split(&#x27;&amp;&#x27;), function(keyValue){
    if (keyValue) {
      key_value = keyValue.split(&#x27;=&#x27;);
      key = decodeURIComponent(key_value[0]);
      obj[key] = isDefined(key_value[1]) ? decodeURIComponent(key_value[1]) : true;
    }
  });
  return obj;
}

function toKeyValue(obj) {
  var parts = [];
  forEach(obj, function(value, key) {
    parts.push(encodeUriQuery(key, true) + (value === true ? &#x27;&#x27; : &#x27;=&#x27; + encodeUriQuery(value, true)));
  });
  return parts.length ? parts.join(&#x27;&amp;&#x27;) : &#x27;&#x27;;
}


/**
 * We need our custom method because encodeURIComponent is too aggressive and doesn&#x27;t follow
 * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path
 * segments:
 *    segment       = *pchar
 *    pchar         = unreserved / pct-encoded / sub-delims / &quot;:&quot; / &quot;@&quot;
 *    pct-encoded   = &quot;%&quot; HEXDIG HEXDIG
 *    unreserved    = ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot;
 *    sub-delims    = &quot;!&quot; / &quot;$&quot; / &quot;&amp;&quot; / &quot;&#x27;&quot; / &quot;(&quot; / &quot;)&quot;
 *                     / &quot;*&quot; / &quot;+&quot; / &quot;,&quot; / &quot;;&quot; / &quot;=&quot;
 */
function encodeUriSegment(val) {
  return encodeUriQuery(val, true).
             replace(/%26/gi, &#x27;&amp;&#x27;).
             replace(/%3D/gi, &#x27;=&#x27;).
             replace(/%2B/gi, &#x27;+&#x27;);
}


/**
 * This method is intended for encoding *key* or *value* parts of query component. We need a custom
 * method because encodeURIComponent is too aggressive and encodes stuff that doesn&#x27;t have to be
 * encoded per http://tools.ietf.org/html/rfc3986:
 *    query       = *( pchar / &quot;/&quot; / &quot;?&quot; )
 *    pchar         = unreserved / pct-encoded / sub-delims / &quot;:&quot; / &quot;@&quot;
 *    unreserved    = ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot;
 *    pct-encoded   = &quot;%&quot; HEXDIG HEXDIG
 *    sub-delims    = &quot;!&quot; / &quot;$&quot; / &quot;&amp;&quot; / &quot;&#x27;&quot; / &quot;(&quot; / &quot;)&quot;
 *                     / &quot;*&quot; / &quot;+&quot; / &quot;,&quot; / &quot;;&quot; / &quot;=&quot;
 */
function encodeUriQuery(val, pctEncodeSpaces) {
  return encodeURIComponent(val).
             replace(/%40/gi, &#x27;@&#x27;).
             replace(/%3A/gi, &#x27;:&#x27;).
             replace(/%24/g, &#x27;$&#x27;).
             replace(/%2C/gi, &#x27;,&#x27;).
             replace(/%20/g, (pctEncodeSpaces ? &#x27;%20&#x27; : &#x27;+&#x27;));
}


/**
 * @ngdoc directive
 * @name ng.directive:ngApp
 *
 * @element ANY
 * @param {angular.Module} ngApp an optional application
 *   {@link angular.module module} name to load.
 *
 * @description
 *
 * Use this directive to auto-bootstrap an application. Only
 * one directive can be used per HTML document. The directive
 * designates the root of the application and is typically placed
 * at the root of the page.
 *
 * In the example below if the &#x60;ngApp&#x60; directive would not be placed
 * on the &#x60;html&#x60; element then the document would not be compiled
 * and the &#x60;{{ 1+2 }}&#x60; would not be resolved to &#x60;3&#x60;.
 *
 * &#x60;ngApp&#x60; is the easiest way to bootstrap an application.
 *
 &lt;doc:example&gt;
   &lt;doc:source&gt;
    I can add: 1 + 2 =  {{ 1+2 }}
   &lt;/doc:source&gt;
 &lt;/doc:example&gt;
 *
 */
function angularInit(element, bootstrap) {
  var elements = [element],
      appElement,
      module,
      names = [&#x27;ng:app&#x27;, &#x27;ng-app&#x27;, &#x27;x-ng-app&#x27;, &#x27;data-ng-app&#x27;],
      NG_APP_CLASS_REGEXP = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/;

  function append(element) {
    element &amp;&amp; elements.push(element);
  }

  forEach(names, function(name) {
    names[name] = true;
    append(document.getElementById(name));
    name = name.replace(&#x27;:&#x27;, &#x27;\\:&#x27;);
    if (element.querySelectorAll) {
      forEach(element.querySelectorAll(&#x27;.&#x27; + name), append);
      forEach(element.querySelectorAll(&#x27;.&#x27; + name + &#x27;\\:&#x27;), append);
      forEach(element.querySelectorAll(&#x27;[&#x27; + name + &#x27;]&#x27;), append);
    }
  });

  forEach(elements, function(element) {
    if (!appElement) {
      var className = &#x27; &#x27; + element.className + &#x27; &#x27;;
      var match = NG_APP_CLASS_REGEXP.exec(className);
      if (match) {
        appElement = element;
        module = (match[2] || &#x27;&#x27;).replace(/\s+/g, &#x27;,&#x27;);
      } else {
        forEach(element.attributes, function(attr) {
          if (!appElement &amp;&amp; names[attr.name]) {
            appElement = element;
            module = attr.value;
          }
        });
      }
    }
  });
  if (appElement) {
    bootstrap(appElement, module ? [module] : []);
  }
}

/**
 * @ngdoc function
 * @name angular.bootstrap
 * @description
 * Use this function to manually start up angular application.
 *
 * See: {@link guide/bootstrap Bootstrap}
 *
 * @param {Element} element DOM element which is the root of angular application.
 * @param {Array&lt;String|Function&gt;=} modules an array of module declarations. See: {@link angular.module modules}
 * @returns {AUTO.$injector} Returns the newly created injector for this app.
 */
function bootstrap(element, modules) {
  var resumeBootstrapInternal = function() {
    element = jqLite(element);
    modules = modules || [];
    modules.unshift([&#x27;$provide&#x27;, function($provide) {
      $provide.value(&#x27;$rootElement&#x27;, element);
    }]);
    modules.unshift(&#x27;ng&#x27;);
    var injector = createInjector(modules);
    injector.invoke([&#x27;$rootScope&#x27;, &#x27;$rootElement&#x27;, &#x27;$compile&#x27;, &#x27;$injector&#x27;, &#x27;$animator&#x27;,
       function(scope, element, compile, injector, animator) {
        scope.$apply(function() {
          element.data(&#x27;$injector&#x27;, injector);
          compile(element)(scope);
        });
        animator.enabled(true);
      }]
    );
    return injector;
  };

  var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;

  if (window &amp;&amp; !NG_DEFER_BOOTSTRAP.test(window.name)) {
    return resumeBootstrapInternal();
  }

  window.name = window.name.replace(NG_DEFER_BOOTSTRAP, &#x27;&#x27;);
  angular.resumeBootstrap = function(extraModules) {
    forEach(extraModules, function(module) {
      modules.push(module);
    });
    resumeBootstrapInternal();
  };
}

var SNAKE_CASE_REGEXP = /[A-Z]/g;
function snake_case(name, separator){
  separator = separator || &#x27;_&#x27;;
  return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
    return (pos ? separator : &#x27;&#x27;) + letter.toLowerCase();
  });
}

function bindJQuery() {
  // bind to jQuery if present;
  jQuery = window.jQuery;
  // reset to jQuery or default to us.
  if (jQuery) {
    jqLite = jQuery;
    extend(jQuery.fn, {
      scope: JQLitePrototype.scope,
      controller: JQLitePrototype.controller,
      injector: JQLitePrototype.injector,
      inheritedData: JQLitePrototype.inheritedData
    });
    JQLitePatchJQueryRemove(&#x27;remove&#x27;, true);
    JQLitePatchJQueryRemove(&#x27;empty&#x27;);
    JQLitePatchJQueryRemove(&#x27;html&#x27;);
  } else {
    jqLite = JQLite;
  }
  angular.element = jqLite;
}

/**
 * throw error if the argument is falsy.
 */
function assertArg(arg, name, reason) {
  if (!arg) {
    throw new Error(&quot;Argument &#x27;&quot; + (name || &#x27;?&#x27;) + &quot;&#x27; is &quot; + (reason || &quot;required&quot;));
  }
  return arg;
}

function assertArgFn(arg, name, acceptArrayAnnotation) {
  if (acceptArrayAnnotation &amp;&amp; isArray(arg)) {
      arg = arg[arg.length - 1];
  }

  assertArg(isFunction(arg), name, &#x27;not a function, got &#x27; +
      (arg &amp;&amp; typeof arg == &#x27;object&#x27; ? arg.constructor.name || &#x27;Object&#x27; : typeof arg));
  return arg;
}

/**
 * @ngdoc interface
 * @name angular.Module
 * @description
 *
 * Interface for configuring angular {@link angular.module modules}.
 */

function setupModuleLoader(window) {

  function ensure(obj, name, factory) {
    return obj[name] || (obj[name] = factory());
  }

  return ensure(ensure(window, &#x27;angular&#x27;, Object), &#x27;module&#x27;, function() {
    /** @type {Object.&lt;string, angular.Module&gt;} */
    var modules = {};

    /**
     * @ngdoc function
     * @name angular.module
     * @description
     *
     * The &#x60;angular.module&#x60; is a global place for creating and registering Angular modules. All
     * modules (angular core or 3rd party) that should be available to an application must be
     * registered using this mechanism.
     *
     *
     * # Module
     *
     * A module is a collocation of services, directives, filters, and configuration information. Module
     * is used to configure the {@link AUTO.$injector $injector}.
     *
     * &lt;pre&gt;
     * // Create a new module
     * var myModule = angular.module(&#x27;myModule&#x27;, []);
     *
     * // register a new service
     * myModule.value(&#x27;appName&#x27;, &#x27;MyCoolApp&#x27;);
     *
     * // configure existing services inside initialization blocks.
     * myModule.config(function($locationProvider) {
     *   // Configure existing providers
     *   $locationProvider.hashPrefix(&#x27;!&#x27;);
     * });
     * &lt;/pre&gt;
     *
     * Then you can create an injector and load your modules like this:
     *
     * &lt;pre&gt;
     * var injector = angular.injector([&#x27;ng&#x27;, &#x27;MyModule&#x27;])
     * &lt;/pre&gt;
     *
     * However it&#x27;s more likely that you&#x27;ll just use
     * {@link ng.directive:ngApp ngApp} or
     * {@link angular.bootstrap} to simplify this process for you.
     *
     * @param {!string} name The name of the module to create or retrieve.
     * @param {Array.&lt;string&gt;=} requires If specified then new module is being created. If unspecified then the
     *        the module is being retrieved for further configuration.
     * @param {Function} configFn Optional configuration function for the module. Same as
     *        {@link angular.Module#config Module#config()}.
     * @returns {module} new module with the {@link angular.Module} api.
     */
    return function module(name, requires, configFn) {
      if (requires &amp;&amp; modules.hasOwnProperty(name)) {
        modules[name] = null;
      }
      return ensure(modules, name, function() {
        if (!requires) {
          throw Error(&#x27;No module: &#x27; + name);
        }

        /** @type {!Array.&lt;Array.&lt;*&gt;&gt;} */
        var invokeQueue = [];

        /** @type {!Array.&lt;Function&gt;} */
        var runBlocks = [];

        var config = invokeLater(&#x27;$injector&#x27;, &#x27;invoke&#x27;);

        /** @type {angular.Module} */
        var moduleInstance = {
          // Private state
          _invokeQueue: invokeQueue,
          _runBlocks: runBlocks,

          /**
           * @ngdoc property
           * @name angular.Module#requires
           * @propertyOf angular.Module
           * @returns {Array.&lt;string&gt;} List of module names which must be loaded before this module.
           * @description
           * Holds the list of modules which the injector will load before the current module is loaded.
           */
          requires: requires,

          /**
           * @ngdoc property
           * @name angular.Module#name
           * @propertyOf angular.Module
           * @returns {string} Name of the module.
           * @description
           */
          name: name,


          /**
           * @ngdoc method
           * @name angular.Module#provider
           * @methodOf angular.Module
           * @param {string} name service name
           * @param {Function} providerType Construction function for creating new instance of the service.
           * @description
           * See {@link AUTO.$provide#provider $provide.provider()}.
           */
          provider: invokeLater(&#x27;$provide&#x27;, &#x27;provider&#x27;),

          /**
           * @ngdoc method
           * @name angular.Module#factory
           * @methodOf angular.Module
           * @param {string} name service name
           * @param {Function} providerFunction Function for creating new instance of the service.
           * @description
           * See {@link AUTO.$provide#factory $provide.factory()}.
           */
          factory: invokeLater(&#x27;$provide&#x27;, &#x27;factory&#x27;),

          /**
           * @ngdoc method
           * @name angular.Module#service
           * @methodOf angular.Module
           * @param {string} name service name
           * @param {Function} constructor A constructor function that will be instantiated.
           * @description
           * See {@link AUTO.$provide#service $provide.service()}.
           */
          service: invokeLater(&#x27;$provide&#x27;, &#x27;service&#x27;),

          /**
           * @ngdoc method
           * @name angular.Module#value
           * @methodOf angular.Module
           * @param {string} name service name
           * @param {*} object Service instance object.
           * @description
           * See {@link AUTO.$provide#value $provide.value()}.
           */
          value: invokeLater(&#x27;$provide&#x27;, &#x27;value&#x27;),

          /**
           * @ngdoc method
           * @name angular.Module#constant
           * @methodOf angular.Module
           * @param {string} name constant name
           * @param {*} object Constant value.
           * @description
           * Because the constant are fixed, they get applied before other provide methods.
           * See {@link AUTO.$provide#constant $provide.constant()}.
           */
          constant: invokeLater(&#x27;$provide&#x27;, &#x27;constant&#x27;, &#x27;unshift&#x27;),

          /**
           * @ngdoc method
           * @name angular.Module#animation
           * @methodOf angular.Module
           * @param {string} name animation name
           * @param {Function} animationFactory Factory function for creating new instance of an animation.
           * @description
           *
           * Defines an animation hook that can be later used with {@link ng.directive:ngAnimate ngAnimate}
           * alongside {@link ng.directive:ngAnimate#Description common ng directives} as well as custom directives.
           * &lt;pre&gt;
           * module.animation(&#x27;animation-name&#x27;, function($inject1, $inject2) {
           *   return {
           *     //this gets called in preparation to setup an animation
           *     setup : function(element) { ... },
           *
           *     //this gets called once the animation is run
           *     start : function(element, done, memo) { ... }
           *   }
           * })
           * &lt;/pre&gt;
           *
           * See {@link ng.$animationProvider#register $animationProvider.register()} and
           * {@link ng.directive:ngAnimate ngAnimate} for more information.
           */
          animation: invokeLater(&#x27;$animationProvider&#x27;, &#x27;register&#x27;),

          /**
           * @ngdoc method
           * @name angular.Module#filter
           * @methodOf angular.Module
           * @param {string} name Filter name.
           * @param {Function} filterFactory Factory function for creating new instance of filter.
           * @description
           * See {@link ng.$filterProvider#register $filterProvider.register()}.
           */
          filter: invokeLater(&#x27;$filterProvider&#x27;, &#x27;register&#x27;),

          /**
           * @ngdoc method
           * @name angular.Module#controller
           * @methodOf angular.Module
           * @param {string} name Controller name.
           * @param {Function} constructor Controller constructor function.
           * @description
           * See {@link ng.$controllerProvider#register $controllerProvider.register()}.
           */
          controller: invokeLater(&#x27;$controllerProvider&#x27;, &#x27;register&#x27;),

          /**
           * @ngdoc method
           * @name angular.Module#directive
           * @methodOf angular.Module
           * @param {string} name directive name
           * @param {Function} directiveFactory Factory function for creating new instance of
           * directives.
           * @description
           * See {@link ng.$compileProvider#directive $compileProvider.directive()}.
           */
          directive: invokeLater(&#x27;$compileProvider&#x27;, &#x27;directive&#x27;),

          /**
           * @ngdoc method
           * @name angular.Module#config
           * @methodOf angular.Module
           * @param {Function} configFn Execute this function on module load. Useful for service
           *    configuration.
           * @description
           * Use this method to register work which needs to be performed on module loading.
           */
          config: config,

          /**
           * @ngdoc method
           * @name angular.Module#run
           * @methodOf angular.Module
           * @param {Function} initializationFn Execute this function after injector creation.
           *    Useful for application initialization.
           * @description
           * Use this method to register work which should be performed when the injector is done
           * loading all modules.
           */
          run: function(block) {
            runBlocks.push(block);
            return this;
          }
        };

        if (configFn) {
          config(configFn);
        }

        return  moduleInstance;

        /**
         * @param {string} provider
         * @param {string} method
         * @param {String=} insertMethod
         * @returns {angular.Module}
         */
        function invokeLater(provider, method, insertMethod) {
          return function() {
            invokeQueue[insertMethod || &#x27;push&#x27;]([provider, method, arguments]);
            return moduleInstance;
          }
        }
      });
    };
  });

}

/**
 * @ngdoc property
 * @name angular.version
 * @description
 * An object that contains information about the current AngularJS version. This object has the
 * following properties:
 *
 * - &#x60;full&#x60;  &#x60;{string}&#x60;  Full version string, such as &quot;0.9.18&quot;.
 * - &#x60;major&#x60;  &#x60;{number}&#x60;  Major version number, such as &quot;0&quot;.
 * - &#x60;minor&#x60;  &#x60;{number}&#x60;  Minor version number, such as &quot;9&quot;.
 * - &#x60;dot&#x60;  &#x60;{number}&#x60;  Dot version number, such as &quot;18&quot;.
 * - &#x60;codeName&#x60;  &#x60;{string}&#x60;  Code name of the release, such as &quot;jiggling-armfat&quot;.
 */
var version = {
  full: &#x27;1.1.5&#x27;,    // all of these placeholder strings will be replaced by grunt&#x27;s
  major: 1,    // package task
  minor: 1,
  dot: 5,
  codeName: &#x27;triangle-squarification&#x27;
};


function publishExternalAPI(angular){
  extend(angular, {
    &#x27;bootstrap&#x27;: bootstrap,
    &#x27;copy&#x27;: copy,
    &#x27;extend&#x27;: extend,
    &#x27;equals&#x27;: equals,
    &#x27;element&#x27;: jqLite,
    &#x27;forEach&#x27;: forEach,
    &#x27;injector&#x27;: createInjector,
    &#x27;noop&#x27;:noop,
    &#x27;bind&#x27;:bind,
    &#x27;toJson&#x27;: toJson,
    &#x27;fromJson&#x27;: fromJson,
    &#x27;identity&#x27;:identity,
    &#x27;isUndefined&#x27;: isUndefined,
    &#x27;isDefined&#x27;: isDefined,
    &#x27;isString&#x27;: isString,
    &#x27;isFunction&#x27;: isFunction,
    &#x27;isObject&#x27;: isObject,
    &#x27;isNumber&#x27;: isNumber,
    &#x27;isElement&#x27;: isElement,
    &#x27;isArray&#x27;: isArray,
    &#x27;version&#x27;: version,
    &#x27;isDate&#x27;: isDate,
    &#x27;lowercase&#x27;: lowercase,
    &#x27;uppercase&#x27;: uppercase,
    &#x27;callbacks&#x27;: {counter: 0},
    &#x27;noConflict&#x27;: noConflict
  });

  angularModule = setupModuleLoader(window);
  try {
    angularModule(&#x27;ngLocale&#x27;);
  } catch (e) {
    angularModule(&#x27;ngLocale&#x27;, []).provider(&#x27;$locale&#x27;, $LocaleProvider);
  }

  angularModule(&#x27;ng&#x27;, [&#x27;ngLocale&#x27;], [&#x27;$provide&#x27;,
    function ngModule($provide) {
      $provide.provider(&#x27;$compile&#x27;, $CompileProvider).
        directive({
            a: htmlAnchorDirective,
            input: inputDirective,
            textarea: inputDirective,
            form: formDirective,
            script: scriptDirective,
            select: selectDirective,
            style: styleDirective,
            option: optionDirective,
            ngBind: ngBindDirective,
            ngBindHtmlUnsafe: ngBindHtmlUnsafeDirective,
            ngBindTemplate: ngBindTemplateDirective,
            ngClass: ngClassDirective,
            ngClassEven: ngClassEvenDirective,
            ngClassOdd: ngClassOddDirective,
            ngCsp: ngCspDirective,
            ngCloak: ngCloakDirective,
            ngController: ngControllerDirective,
            ngForm: ngFormDirective,
            ngHide: ngHideDirective,
            ngIf: ngIfDirective,
            ngInclude: ngIncludeDirective,
            ngInit: ngInitDirective,
            ngNonBindable: ngNonBindableDirective,
            ngPluralize: ngPluralizeDirective,
            ngRepeat: ngRepeatDirective,
            ngShow: ngShowDirective,
            ngSubmit: ngSubmitDirective,
            ngStyle: ngStyleDirective,
            ngSwitch: ngSwitchDirective,
            ngSwitchWhen: ngSwitchWhenDirective,
            ngSwitchDefault: ngSwitchDefaultDirective,
            ngOptions: ngOptionsDirective,
            ngView: ngViewDirective,
            ngTransclude: ngTranscludeDirective,
            ngModel: ngModelDirective,
            ngList: ngListDirective,
            ngChange: ngChangeDirective,
            required: requiredDirective,
            ngRequired: requiredDirective,
            ngValue: ngValueDirective
        }).
        directive(ngAttributeAliasDirectives).
        directive(ngEventDirectives);
      $provide.provider({
        $anchorScroll: $AnchorScrollProvider,
        $animation: $AnimationProvider,
        $animator: $AnimatorProvider,
        $browser: $BrowserProvider,
        $cacheFactory: $CacheFactoryProvider,
        $controller: $ControllerProvider,
        $document: $DocumentProvider,
        $exceptionHandler: $ExceptionHandlerProvider,
        $filter: $FilterProvider,
        $interpolate: $InterpolateProvider,
        $http: $HttpProvider,
        $httpBackend: $HttpBackendProvider,
        $location: $LocationProvider,
        $log: $LogProvider,
        $parse: $ParseProvider,
        $route: $RouteProvider,
        $routeParams: $RouteParamsProvider,
        $rootScope: $RootScopeProvider,
        $q: $QProvider,
        $sniffer: $SnifferProvider,
        $templateCache: $TemplateCacheProvider,
        $timeout: $TimeoutProvider,
        $window: $WindowProvider
      });
    }
  ]);
}

//////////////////////////////////
//JQLite
//////////////////////////////////

/**
 * @ngdoc function
 * @name angular.element
 * @function
 *
 * @description
 * Wraps a raw DOM element or HTML string as a [jQuery](http://jquery.com) element.
 * &#x60;angular.element&#x60; can be either an alias for [jQuery](http://api.jquery.com/jQuery/) function, if
 * jQuery is available, or a function that wraps the element or string in Angular&#x27;s jQuery lite
 * implementation (commonly referred to as jqLite).
 *
 * Real jQuery always takes precedence over jqLite, provided it was loaded before &#x60;DOMContentLoaded&#x60;
 * event fired.
 *
 * jqLite is a tiny, API-compatible subset of jQuery that allows
 * Angular to manipulate the DOM. jqLite implements only the most commonly needed functionality
 * within a very small footprint, so only a subset of the jQuery API - methods, arguments and
 * invocation styles - are supported.
 *
 * Note: All element references in Angular are always wrapped with jQuery or jqLite; they are never
 * raw DOM references.
 *
 * ## Angular&#x27;s jQuery lite provides the following methods:
 *
 * - [addClass()](http://api.jquery.com/addClass/)
 * - [after()](http://api.jquery.com/after/)
 * - [append()](http://api.jquery.com/append/)
 * - [attr()](http://api.jquery.com/attr/)
 * - [bind()](http://api.jquery.com/bind/) - Does not support namespaces
 * - [children()](http://api.jquery.com/children/) - Does not support selectors
 * - [clone()](http://api.jquery.com/clone/)
 * - [contents()](http://api.jquery.com/contents/)
 * - [css()](http://api.jquery.com/css/)
 * - [data()](http://api.jquery.com/data/)
 * - [eq()](http://api.jquery.com/eq/)
 * - [find()](http://api.jquery.com/find/) - Limited to lookups by tag name
 * - [hasClass()](http://api.jquery.com/hasClass/)
 * - [html()](http://api.jquery.com/html/)
 * - [next()](http://api.jquery.com/next/) - Does not support selectors
 * - [parent()](http://api.jquery.com/parent/) - Does not support selectors
 * - [prepend()](http://api.jquery.com/prepend/)
 * - [prop()](http://api.jquery.com/prop/)
 * - [ready()](http://api.jquery.com/ready/)
 * - [remove()](http://api.jquery.com/remove/)
 * - [removeAttr()](http://api.jquery.com/removeAttr/)
 * - [removeClass()](http://api.jquery.com/removeClass/)
 * - [removeData()](http://api.jquery.com/removeData/)
 * - [replaceWith()](http://api.jquery.com/replaceWith/)
 * - [text()](http://api.jquery.com/text/)
 * - [toggleClass()](http://api.jquery.com/toggleClass/)
 * - [triggerHandler()](http://api.jquery.com/triggerHandler/) - Passes a dummy event object to handlers.
 * - [unbind()](http://api.jquery.com/unbind/) - Does not support namespaces
 * - [val()](http://api.jquery.com/val/)
 * - [wrap()](http://api.jquery.com/wrap/)
 *
 * ## In addition to the above, Angular provides additional methods to both jQuery and jQuery lite:
 *
 * - &#x60;controller(name)&#x60; - retrieves the controller of the current element or its parent. By default
 *   retrieves controller associated with the &#x60;ngController&#x60; directive. If &#x60;name&#x60; is provided as
 *   camelCase directive name, then the controller for this directive will be retrieved (e.g.
 *   &#x60;&#x27;ngModel&#x27;&#x60;).
 * - &#x60;injector()&#x60; - retrieves the injector of the current element or its parent.
 * - &#x60;scope()&#x60; - retrieves the {@link api/ng.$rootScope.Scope scope} of the current
 *   element or its parent.
 * - &#x60;inheritedData()&#x60; - same as &#x60;data()&#x60;, but walks up the DOM until a value is found or the top
 *   parent element is reached.
 *
 * @param {string|DOMElement} element HTML string or DOMElement to be wrapped into jQuery.
 * @returns {Object} jQuery object.
 */

var jqCache = JQLite.cache = {},
    jqName = JQLite.expando = &#x27;ng-&#x27; + new Date().getTime(),
    jqId = 1,
    addEventListenerFn = (window.document.addEventListener
      ? function(element, type, fn) {element.addEventListener(type, fn, false);}
      : function(element, type, fn) {element.attachEvent(&#x27;on&#x27; + type, fn);}),
    removeEventListenerFn = (window.document.removeEventListener
      ? function(element, type, fn) {element.removeEventListener(type, fn, false); }
      : function(element, type, fn) {element.detachEvent(&#x27;on&#x27; + type, fn); });

function jqNextId() { return ++jqId; }


var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
var MOZ_HACK_REGEXP = /^moz([A-Z])/;

/**
 * Converts snake_case to camelCase.
 * Also there is special case for Moz prefix starting with upper case letter.
 * @param name Name to normalize
 */
function camelCase(name) {
  return name.
    replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
      return offset ? letter.toUpperCase() : letter;
    }).
    replace(MOZ_HACK_REGEXP, &#x27;Moz$1&#x27;);
}

/////////////////////////////////////////////
// jQuery mutation patch
//
//  In conjunction with bindJQuery intercepts all jQuery&#x27;s DOM destruction apis and fires a
// $destroy event on all DOM nodes being removed.
//
/////////////////////////////////////////////

function JQLitePatchJQueryRemove(name, dispatchThis) {
  var originalJqFn = jQuery.fn[name];
  originalJqFn = originalJqFn.$original || originalJqFn;
  removePatch.$original = originalJqFn;
  jQuery.fn[name] = removePatch;

  function removePatch() {
    var list = [this],
        fireEvent = dispatchThis,
        set, setIndex, setLength,
        element, childIndex, childLength, children,
        fns, events;

    while(list.length) {
      set = list.shift();
      for(setIndex = 0, setLength = set.length; setIndex &lt; setLength; setIndex++) {
        element = jqLite(set[setIndex]);
        if (fireEvent) {
          element.triggerHandler(&#x27;$destroy&#x27;);
        } else {
          fireEvent = !fireEvent;
        }
        for(childIndex = 0, childLength = (children = element.children()).length;
            childIndex &lt; childLength;
            childIndex++) {
          list.push(jQuery(children[childIndex]));
        }
      }
    }
    return originalJqFn.apply(this, arguments);
  }
}

/////////////////////////////////////////////
function JQLite(element) {
  if (element instanceof JQLite) {
    return element;
  }
  if (!(this instanceof JQLite)) {
    if (isString(element) &amp;&amp; element.charAt(0) != &#x27;&lt;&#x27;) {
      throw Error(&#x27;selectors not implemented&#x27;);
    }
    return new JQLite(element);
  }

  if (isString(element)) {
    var div = document.createElement(&#x27;div&#x27;);
    // Read about the NoScope elements here:
    // http://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx
    div.innerHTML = &#x27;&lt;div&gt;&amp;#160;&lt;/div&gt;&#x27; + element; // IE insanity to make NoScope elements work!
    div.removeChild(div.firstChild); // remove the superfluous div
    JQLiteAddNodes(this, div.childNodes);
    this.remove(); // detach the elements from the temporary DOM div.
  } else {
    JQLiteAddNodes(this, element);
  }
}

function JQLiteClone(element) {
  return element.cloneNode(true);
}

function JQLiteDealoc(element){
  JQLiteRemoveData(element);
  for ( var i = 0, children = element.childNodes || []; i &lt; children.length; i++) {
    JQLiteDealoc(children[i]);
  }
}

function JQLiteUnbind(element, type, fn) {
  var events = JQLiteExpandoStore(element, &#x27;events&#x27;),
      handle = JQLiteExpandoStore(element, &#x27;handle&#x27;);

  if (!handle) return; //no listeners registered

  if (isUndefined(type)) {
    forEach(events, function(eventHandler, type) {
      removeEventListenerFn(element, type, eventHandler);
      delete events[type];
    });
  } else {
    if (isUndefined(fn)) {
      removeEventListenerFn(element, type, events[type]);
      delete events[type];
    } else {
      arrayRemove(events[type], fn);
    }
  }
}

function JQLiteRemoveData(element) {
  var expandoId = element[jqName],
      expandoStore = jqCache[expandoId];

  if (expandoStore) {
    if (expandoStore.handle) {
      expandoStore.events.$destroy &amp;&amp; expandoStore.handle({}, &#x27;$destroy&#x27;);
      JQLiteUnbind(element);
    }
    delete jqCache[expandoId];
    element[jqName] = undefined; // ie does not allow deletion of attributes on elements.
  }
}

function JQLiteExpandoStore(element, key, value) {
  var expandoId = element[jqName],
      expandoStore = jqCache[expandoId || -1];

  if (isDefined(value)) {
    if (!expandoStore) {
      element[jqName] = expandoId = jqNextId();
      expandoStore = jqCache[expandoId] = {};
    }
    expandoStore[key] = value;
  } else {
    return expandoStore &amp;&amp; expandoStore[key];
  }
}

function JQLiteData(element, key, value) {
  var data = JQLiteExpandoStore(element, &#x27;data&#x27;),
      isSetter = isDefined(value),
      keyDefined = !isSetter &amp;&amp; isDefined(key),
      isSimpleGetter = keyDefined &amp;&amp; !isObject(key);

  if (!data &amp;&amp; !isSimpleGetter) {
    JQLiteExpandoStore(element, &#x27;data&#x27;, data = {});
  }

  if (isSetter) {
    data[key] = value;
  } else {
    if (keyDefined) {
      if (isSimpleGetter) {
        // don&#x27;t create data in this case.
        return data &amp;&amp; data[key];
      } else {
        extend(data, key);
      }
    } else {
      return data;
    }
  }
}

function JQLiteHasClass(element, selector) {
  return ((&quot; &quot; + element.className + &quot; &quot;).replace(/[\n\t]/g, &quot; &quot;).
      indexOf( &quot; &quot; + selector + &quot; &quot; ) &gt; -1);
}

function JQLiteRemoveClass(element, cssClasses) {
  if (cssClasses) {
    forEach(cssClasses.split(&#x27; &#x27;), function(cssClass) {
      element.className = trim(
          (&quot; &quot; + element.className + &quot; &quot;)
          .replace(/[\n\t]/g, &quot; &quot;)
          .replace(&quot; &quot; + trim(cssClass) + &quot; &quot;, &quot; &quot;)
      );
    });
  }
}

function JQLiteAddClass(element, cssClasses) {
  if (cssClasses) {
    forEach(cssClasses.split(&#x27; &#x27;), function(cssClass) {
      if (!JQLiteHasClass(element, cssClass)) {
        element.className = trim(element.className + &#x27; &#x27; + trim(cssClass));
      }
    });
  }
}

function JQLiteAddNodes(root, elements) {
  if (elements) {
    elements = (!elements.nodeName &amp;&amp; isDefined(elements.length) &amp;&amp; !isWindow(elements))
      ? elements
      : [ elements ];
    for(var i=0; i &lt; elements.length; i++) {
      root.push(elements[i]);
    }
  }
}

function JQLiteController(element, name) {
  return JQLiteInheritedData(element, &#x27;$&#x27; + (name || &#x27;ngController&#x27; ) + &#x27;Controller&#x27;);
}

function JQLiteInheritedData(element, name, value) {
  element = jqLite(element);

  // if element is the document object work with the html element instead
  // this makes $(document).scope() possible
  if(element[0].nodeType == 9) {
    element = element.find(&#x27;html&#x27;);
  }

  while (element.length) {
    if (value = element.data(name)) return value;
    element = element.parent();
  }
}

//////////////////////////////////////////
// Functions which are declared directly.
//////////////////////////////////////////
var JQLitePrototype = JQLite.prototype = {
  ready: function(fn) {
    var fired = false;

    function trigger() {
      if (fired) return;
      fired = true;
      fn();
    }

    // check if document already is loaded
    if (document.readyState === &#x27;complete&#x27;){
      setTimeout(trigger);
    } else {
      this.bind(&#x27;DOMContentLoaded&#x27;, trigger); // works for modern browsers and IE9
      // we can not use jqLite since we are not done loading and jQuery could be loaded later.
      JQLite(window).bind(&#x27;load&#x27;, trigger); // fallback to window.onload for others
    }
  },
  toString: function() {
    var value = [];
    forEach(this, function(e){ value.push(&#x27;&#x27; + e);});
    return &#x27;[&#x27; + value.join(&#x27;, &#x27;) + &#x27;]&#x27;;
  },

  eq: function(index) {
      return (index &gt;= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
  },

  length: 0,
  push: push,
  sort: [].sort,
  splice: [].splice
};

//////////////////////////////////////////
// Functions iterating getter/setters.
// these functions return self on setter and
// value on get.
//////////////////////////////////////////
var BOOLEAN_ATTR = {};
forEach(&#x27;multiple,selected,checked,disabled,readOnly,required,open&#x27;.split(&#x27;,&#x27;), function(value) {
  BOOLEAN_ATTR[lowercase(value)] = value;
});
var BOOLEAN_ELEMENTS = {};
forEach(&#x27;input,select,option,textarea,button,form,details&#x27;.split(&#x27;,&#x27;), function(value) {
  BOOLEAN_ELEMENTS[uppercase(value)] = true;
});

function getBooleanAttrName(element, name) {
  // check dom last since we will most likely fail on name
  var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];

  // booleanAttr is here twice to minimize DOM access
  return booleanAttr &amp;&amp; BOOLEAN_ELEMENTS[element.nodeName] &amp;&amp; booleanAttr;
}

forEach({
  data: JQLiteData,
  inheritedData: JQLiteInheritedData,

  scope: function(element) {
    return JQLiteInheritedData(element, &#x27;$scope&#x27;);
  },

  controller: JQLiteController ,

  injector: function(element) {
    return JQLiteInheritedData(element, &#x27;$injector&#x27;);
  },

  removeAttr: function(element,name) {
    element.removeAttribute(name);
  },

  hasClass: JQLiteHasClass,

  css: function(element, name, value) {
    name = camelCase(name);

    if (isDefined(value)) {
      element.style[name] = value;
    } else {
      var val;

      if (msie &lt;= 8) {
        // this is some IE specific weirdness that jQuery 1.6.4 does not sure why
        val = element.currentStyle &amp;&amp; element.currentStyle[name];
        if (val === &#x27;&#x27;) val = &#x27;auto&#x27;;
      }

      val = val || element.style[name];

      if (msie &lt;= 8) {
        // jquery weirdness :-/
        val = (val === &#x27;&#x27;) ? undefined : val;
      }

      return  val;
    }
  },

  attr: function(element, name, value){
    var lowercasedName = lowercase(name);
    if (BOOLEAN_ATTR[lowercasedName]) {
      if (isDefined(value)) {
        if (!!value) {
          element[name] = true;
          element.setAttribute(name, lowercasedName);
        } else {
          element[name] = false;
          element.removeAttribute(lowercasedName);
        }
      } else {
        return (element[name] ||
                 (element.attributes.getNamedItem(name)|| noop).specified)
               ? lowercasedName
               : undefined;
      }
    } else if (isDefined(value)) {
      element.setAttribute(name, value);
    } else if (element.getAttribute) {
      // the extra argument &quot;2&quot; is to get the right thing for a.href in IE, see jQuery code
      // some elements (e.g. Document) don&#x27;t have get attribute, so return undefined
      var ret = element.getAttribute(name, 2);
      // normalize non-existing attributes to undefined (as jQuery)
      return ret === null ? undefined : ret;
    }
  },

  prop: function(element, name, value) {
    if (isDefined(value)) {
      element[name] = value;
    } else {
      return element[name];
    }
  },

  text: extend((msie &lt; 9)
      ? function(element, value) {
        if (element.nodeType == 1 /** Element */) {
          if (isUndefined(value))
            return element.innerText;
          element.innerText = value;
        } else {
          if (isUndefined(value))
            return element.nodeValue;
          element.nodeValue = value;
        }
      }
      : function(element, value) {
        if (isUndefined(value)) {
          return element.textContent;
        }
        element.textContent = value;
      }, {$dv:&#x27;&#x27;}),

  val: function(element, value) {
    if (isUndefined(value)) {
      return element.value;
    }
    element.value = value;
  },

  html: function(element, value) {
    if (isUndefined(value)) {
      return element.innerHTML;
    }
    for (var i = 0, childNodes = element.childNodes; i &lt; childNodes.length; i++) {
      JQLiteDealoc(childNodes[i]);
    }
    element.innerHTML = value;
  }
}, function(fn, name){
  /**
   * Properties: writes return selection, reads return first value
   */
  JQLite.prototype[name] = function(arg1, arg2) {
    var i, key;

    // JQLiteHasClass has only two arguments, but is a getter-only fn, so we need to special-case it
    // in a way that survives minification.
    if (((fn.length == 2 &amp;&amp; (fn !== JQLiteHasClass &amp;&amp; fn !== JQLiteController)) ? arg1 : arg2) === undefined) {
      if (isObject(arg1)) {

        // we are a write, but the object properties are the key/values
        for(i=0; i &lt; this.length; i++) {
          if (fn === JQLiteData) {
            // data() takes the whole object in jQuery
            fn(this[i], arg1);
          } else {
            for (key in arg1) {
              fn(this[i], key, arg1[key]);
            }
          }
        }
        // return self for chaining
        return this;
      } else {
        // we are a read, so read the first child.
        if (this.length)
          return fn(this[0], arg1, arg2);
      }
    } else {
      // we are a write, so apply to all children
      for(i=0; i &lt; this.length; i++) {
        fn(this[i], arg1, arg2);
      }
      // return self for chaining
      return this;
    }
    return fn.$dv;
  };
});

function createEventHandler(element, events) {
  var eventHandler = function (event, type) {
    if (!event.preventDefault) {
      event.preventDefault = function() {
        event.returnValue = false; //ie
      };
    }

    if (!event.stopPropagation) {
      event.stopPropagation = function() {
        event.cancelBubble = true; //ie
      };
    }

    if (!event.target) {
      event.target = event.srcElement || document;
    }

    if (isUndefined(event.defaultPrevented)) {
      var prevent = event.preventDefault;
      event.preventDefault = function() {
        event.defaultPrevented = true;
        prevent.call(event);
      };
      event.defaultPrevented = false;
    }

    event.isDefaultPrevented = function() {
      return event.defaultPrevented || event.returnValue == false;
    };

    forEach(events[type || event.type], function(fn) {
      fn.call(element, event);
    });

    // Remove monkey-patched methods (IE),
    // as they would cause memory leaks in IE8.
    if (msie &lt;= 8) {
      // IE7/8 does not allow to delete property on native object
      event.preventDefault = null;
      event.stopPropagation = null;
      event.isDefaultPrevented = null;
    } else {
      // It shouldn&#x27;t affect normal browsers (native methods are defined on prototype).
      delete event.preventDefault;
      delete event.stopPropagation;
      delete event.isDefaultPrevented;
    }
  };
  eventHandler.elem = element;
  return eventHandler;
}

//////////////////////////////////////////
// Functions iterating traversal.
// These functions chain results into a single
// selector.
//////////////////////////////////////////
forEach({
  removeData: JQLiteRemoveData,

  dealoc: JQLiteDealoc,

  bind: function bindFn(element, type, fn){
    var events = JQLiteExpandoStore(element, &#x27;events&#x27;),
        handle = JQLiteExpandoStore(element, &#x27;handle&#x27;);

    if (!events) JQLiteExpandoStore(element, &#x27;events&#x27;, events = {});
    if (!handle) JQLiteExpandoStore(element, &#x27;handle&#x27;, handle = createEventHandler(element, events));

    forEach(type.split(&#x27; &#x27;), function(type){
      var eventFns = events[type];

      if (!eventFns) {
        if (type == &#x27;mouseenter&#x27; || type == &#x27;mouseleave&#x27;) {
          var contains = document.body.contains || document.body.compareDocumentPosition ?
          function( a, b ) {
            var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b &amp;&amp; b.parentNode;
            return a === bup || !!( bup &amp;&amp; bup.nodeType === 1 &amp;&amp; (
              adown.contains ?
              adown.contains( bup ) :
              a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition( bup ) &amp; 16
              ));
            } :
            function( a, b ) {
              if ( b ) {
                while ( (b = b.parentNode) ) {
                  if ( b === a ) {
                    return true;
                  }
                }
              }
              return false;
            };	

          events[type] = [];
		
		  // Refer to jQuery&#x27;s implementation of mouseenter &amp; mouseleave
          // Read about mouseenter and mouseleave:
          // http://www.quirksmode.org/js/events_mouse.html#link8
          var eventmap = { mouseleave : &quot;mouseout&quot;, mouseenter : &quot;mouseover&quot;}          
          bindFn(element, eventmap[type], function(event) {
            var ret, target = this, related = event.relatedTarget;
            // For mousenter/leave call the handler if related is outside the target.
            // NB: No relatedTarget if the mouse left/entered the browser window
            if ( !related || (related !== target &amp;&amp; !contains(target, related)) ){
              handle(event, type);
            }	

          });

        } else {
          addEventListenerFn(element, type, handle);
          events[type] = [];
        }
        eventFns = events[type]
      }
      eventFns.push(fn);
    });
  },

  unbind: JQLiteUnbind,

  replaceWith: function(element, replaceNode) {
    var index, parent = element.parentNode;
    JQLiteDealoc(element);
    forEach(new JQLite(replaceNode), function(node){
      if (index) {
        parent.insertBefore(node, index.nextSibling);
      } else {
        parent.replaceChild(node, element);
      }
      index = node;
    });
  },

  children: function(element) {
    var children = [];
    forEach(element.childNodes, function(element){
      if (element.nodeType === 1)
        children.push(element);
    });
    return children;
  },

  contents: function(element) {
    return element.childNodes || [];
  },

  append: function(element, node) {
    forEach(new JQLite(node), function(child){
      if (element.nodeType === 1 || element.nodeType === 11) {
        element.appendChild(child);
      }
    });
  },

  prepend: function(element, node) {
    if (element.nodeType === 1) {
      var index = element.firstChild;
      forEach(new JQLite(node), function(child){
        if (index) {
          element.insertBefore(child, index);
        } else {
          element.appendChild(child);
          index = child;
        }
      });
    }
  },

  wrap: function(element, wrapNode) {
    wrapNode = jqLite(wrapNode)[0];
    var parent = element.parentNode;
    if (parent) {
      parent.replaceChild(wrapNode, element);
    }
    wrapNode.appendChild(element);
  },

  remove: function(element) {
    JQLiteDealoc(element);
    var parent = element.parentNode;
    if (parent) parent.removeChild(element);
  },

  after: function(element, newElement) {
    var index = element, parent = element.parentNode;
    forEach(new JQLite(newElement), function(node){
      parent.insertBefore(node, index.nextSibling);
      index = node;
    });
  },

  addClass: JQLiteAddClass,
  removeClass: JQLiteRemoveClass,

  toggleClass: function(element, selector, condition) {
    if (isUndefined(condition)) {
      condition = !JQLiteHasClass(element, selector);
    }
    (condition ? JQLiteAddClass : JQLiteRemoveClass)(element, selector);
  },

  parent: function(element) {
    var parent = element.parentNode;
    return parent &amp;&amp; parent.nodeType !== 11 ? parent : null;
  },

  next: function(element) {
    if (element.nextElementSibling) {
      return element.nextElementSibling;
    }

    // IE8 doesn&#x27;t have nextElementSibling
    var elm = element.nextSibling;
    while (elm != null &amp;&amp; elm.nodeType !== 1) {
      elm = elm.nextSibling;
    }
    return elm;
  },

  find: function(element, selector) {
    return element.getElementsByTagName(selector);
  },

  clone: JQLiteClone,

  triggerHandler: function(element, eventName) {
    var eventFns = (JQLiteExpandoStore(element, &#x27;events&#x27;) || {})[eventName];
    var event;

    forEach(eventFns, function(fn) {
      fn.call(element, {preventDefault: noop});
    });
  }
}, function(fn, name){
  /**
   * chaining functions
   */
  JQLite.prototype[name] = function(arg1, arg2) {
    var value;
    for(var i=0; i &lt; this.length; i++) {
      if (value == undefined) {
        value = fn(this[i], arg1, arg2);
        if (value !== undefined) {
          // any function which returns a value needs to be wrapped
          value = jqLite(value);
        }
      } else {
        JQLiteAddNodes(value, fn(this[i], arg1, arg2));
      }
    }
    return value == undefined ? this : value;
  };
});

/**
 * Computes a hash of an &#x27;obj&#x27;.
 * Hash of a:
 *  string is string
 *  number is number as string
 *  object is either result of calling $$hashKey function on the object or uniquely generated id,
 *         that is also assigned to the $$hashKey property of the object.
 *
 * @param obj
 * @returns {string} hash string such that the same input will have the same hash string.
 *         The resulting string key is in &#x27;type:hashKey&#x27; format.
 */
function hashKey(obj) {
  var objType = typeof obj,
      key;

  if (objType == &#x27;object&#x27; &amp;&amp; obj !== null) {
    if (typeof (key = obj.$$hashKey) == &#x27;function&#x27;) {
      // must invoke on object to keep the right this
      key = obj.$$hashKey();
    } else if (key === undefined) {
      key = obj.$$hashKey = nextUid();
    }
  } else {
    key = obj;
  }

  return objType + &#x27;:&#x27; + key;
}

/**
 * HashMap which can use objects as keys
 */
function HashMap(array){
  forEach(array, this.put, this);
}
HashMap.prototype = {
  /**
   * Store key value pair
   * @param key key to store can be any type
   * @param value value to store can be any type
   */
  put: function(key, value) {
    this[hashKey(key)] = value;
  },

  /**
   * @param key
   * @returns the value for the key
   */
  get: function(key) {
    return this[hashKey(key)];
  },

  /**
   * Remove the key/value pair
   * @param key
   */
  remove: function(key) {
    var value = this[key = hashKey(key)];
    delete this[key];
    return value;
  }
};

/**
 * @ngdoc function
 * @name angular.injector
 * @function
 *
 * @description
 * Creates an injector function that can be used for retrieving services as well as for
 * dependency injection (see {@link guide/di dependency injection}).
 *

 * @param {Array.&lt;string|Function&gt;} modules A list of module functions or their aliases. See
 *        {@link angular.module}. The &#x60;ng&#x60; module must be explicitly added.
 * @returns {function()} Injector function. See {@link AUTO.$injector $injector}.
 *
 * @example
 * Typical usage
 * &lt;pre&gt;
 *   // create an injector
 *   var $injector = angular.injector([&#x27;ng&#x27;]);
 *
 *   // use the injector to kick off your application
 *   // use the type inference to auto inject arguments, or use implicit injection
 *   $injector.invoke(function($rootScope, $compile, $document){
 *     $compile($document)($rootScope);
 *     $rootScope.$digest();
 *   });
 * &lt;/pre&gt;
 */


/**
 * @ngdoc overview
 * @name AUTO
 * @description
 *
 * Implicit module which gets automatically added to each {@link AUTO.$injector $injector}.
 */

var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
var FN_ARG_SPLIT = /,/;
var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
function annotate(fn) {
  var $inject,
      fnText,
      argDecl,
      last;

  if (typeof fn == &#x27;function&#x27;) {
    if (!($inject = fn.$inject)) {
      $inject = [];
      fnText = fn.toString().replace(STRIP_COMMENTS, &#x27;&#x27;);
      argDecl = fnText.match(FN_ARGS);
      forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg){
        arg.replace(FN_ARG, function(all, underscore, name){
          $inject.push(name);
        });
      });
      fn.$inject = $inject;
    }
  } else if (isArray(fn)) {
    last = fn.length - 1;
    assertArgFn(fn[last], &#x27;fn&#x27;);
    $inject = fn.slice(0, last);
  } else {
    assertArgFn(fn, &#x27;fn&#x27;, true);
  }
  return $inject;
}

///////////////////////////////////////

/**
 * @ngdoc object
 * @name AUTO.$injector
 * @function
 *
 * @description
 *
 * &#x60;$injector&#x60; is used to retrieve object instances as defined by
 * {@link AUTO.$provide provider}, instantiate types, invoke methods,
 * and load modules.
 *
 * The following always holds true:
 *
 * &lt;pre&gt;
 *   var $injector = angular.injector();
 *   expect($injector.get(&#x27;$injector&#x27;)).toBe($injector);
 *   expect($injector.invoke(function($injector){
 *     return $injector;
 *   }).toBe($injector);
 * &lt;/pre&gt;
 *
 * # Injection Function Annotation
 *
 * JavaScript does not have annotations, and annotations are needed for dependency injection. The
 * following are all valid ways of annotating function with injection arguments and are equivalent.
 *
 * &lt;pre&gt;
 *   // inferred (only works if code not minified/obfuscated)
 *   $injector.invoke(function(serviceA){});
 *
 *   // annotated
 *   function explicit(serviceA) {};
 *   explicit.$inject = [&#x27;serviceA&#x27;];
 *   $injector.invoke(explicit);
 *
 *   // inline
 *   $injector.invoke([&#x27;serviceA&#x27;, function(serviceA){}]);
 * &lt;/pre&gt;
 *
 * ## Inference
 *
 * In JavaScript calling &#x60;toString()&#x60; on a function returns the function definition. The definition can then be
 * parsed and the function arguments can be extracted. *NOTE:* This does not work with minification, and obfuscation
 * tools since these tools change the argument names.
 *
 * ## &#x60;$inject&#x60; Annotation
 * By adding a &#x60;$inject&#x60; property onto a function the injection parameters can be specified.
 *
 * ## Inline
 * As an array of injection names, where the last item in the array is the function to call.
 */

/**
 * @ngdoc method
 * @name AUTO.$injector#get
 * @methodOf AUTO.$injector
 *
 * @description
 * Return an instance of the service.
 *
 * @param {string} name The name of the instance to retrieve.
 * @return {*} The instance.
 */

/**
 * @ngdoc method
 * @name AUTO.$injector#invoke
 * @methodOf AUTO.$injector
 *
 * @description
 * Invoke the method and supply the method arguments from the &#x60;$injector&#x60;.
 *
 * @param {!function} fn The function to invoke. The function arguments come form the function annotation.
 * @param {Object=} self The &#x60;this&#x60; for the invoked method.
 * @param {Object=} locals Optional object. If preset then any argument names are read from this object first, before
 *   the &#x60;$injector&#x60; is consulted.
 * @returns {*} the value returned by the invoked &#x60;fn&#x60; function.
 */

/**
 * @ngdoc method
 * @name AUTO.$injector#has
 * @methodOf AUTO.$injector
 *
 * @description
 * Allows the user to query if the particular service exist.
 *
 * @param {string} Name of the service to query.
 * @returns {boolean} returns true if injector has given service.
 */

/**
 * @ngdoc method
 * @name AUTO.$injector#instantiate
 * @methodOf AUTO.$injector
 * @description
 * Create a new instance of JS type. The method takes a constructor function invokes the new operator and supplies
 * all of the arguments to the constructor function as specified by the constructor annotation.
 *
 * @param {function} Type Annotated constructor function.
 * @param {Object=} locals Optional object. If preset then any argument names are read from this object first, before
 *   the &#x60;$injector&#x60; is consulted.
 * @returns {Object} new instance of &#x60;Type&#x60;.
 */

/**
 * @ngdoc method
 * @name AUTO.$injector#annotate
 * @methodOf AUTO.$injector
 *
 * @description
 * Returns an array of service names which the function is requesting for injection. This API is used by the injector
 * to determine which services need to be injected into the function when the function is invoked. There are three
 * ways in which the function can be annotated with the needed dependencies.
 *
 * # Argument names
 *
 * The simplest form is to extract the dependencies from the arguments of the function. This is done by converting
 * the function into a string using &#x60;toString()&#x60; method and extracting the argument names.
 * &lt;pre&gt;
 *   // Given
 *   function MyController($scope, $route) {
 *     // ...
 *   }
 *
 *   // Then
 *   expect(injector.annotate(MyController)).toEqual([&#x27;$scope&#x27;, &#x27;$route&#x27;]);
 * &lt;/pre&gt;
 *
 * This method does not work with code minfication / obfuscation. For this reason the following annotation strategies
 * are supported.
 *
 * # The &#x60;$inject&#x60; property
 *
 * If a function has an &#x60;$inject&#x60; property and its value is an array of strings, then the strings represent names of
 * services to be injected into the function.
 * &lt;pre&gt;
 *   // Given
 *   var MyController = function(obfuscatedScope, obfuscatedRoute) {
 *     // ...
 *   }
 *   // Define function dependencies
 *   MyController.$inject = [&#x27;$scope&#x27;, &#x27;$route&#x27;];
 *
 *   // Then
 *   expect(injector.annotate(MyController)).toEqual([&#x27;$scope&#x27;, &#x27;$route&#x27;]);
 * &lt;/pre&gt;
 *
 * # The array notation
 *
 * It is often desirable to inline Injected functions and that&#x27;s when setting the &#x60;$inject&#x60; property is very
 * inconvenient. In these situations using the array notation to specify the dependencies in a way that survives
 * minification is a better choice:
 *
 * &lt;pre&gt;
 *   // We wish to write this (not minification / obfuscation safe)
 *   injector.invoke(function($compile, $rootScope) {
 *     // ...
 *   });
 *
 *   // We are forced to write break inlining
 *   var tmpFn = function(obfuscatedCompile, obfuscatedRootScope) {
 *     // ...
 *   };
 *   tmpFn.$inject = [&#x27;$compile&#x27;, &#x27;$rootScope&#x27;];
 *   injector.invoke(tmpFn);
 *
 *   // To better support inline function the inline annotation is supported
 *   injector.invoke([&#x27;$compile&#x27;, &#x27;$rootScope&#x27;, function(obfCompile, obfRootScope) {
 *     // ...
 *   }]);
 *
 *   // Therefore
 *   expect(injector.annotate(
 *      [&#x27;$compile&#x27;, &#x27;$rootScope&#x27;, function(obfus_$compile, obfus_$rootScope) {}])
 *    ).toEqual([&#x27;$compile&#x27;, &#x27;$rootScope&#x27;]);
 * &lt;/pre&gt;
 *
 * @param {function|Array.&lt;string|Function&gt;} fn Function for which dependent service names need to be retrieved as described
 *   above.
 *
 * @returns {Array.&lt;string&gt;} The names of the services which the function requires.
 */




/**
 * @ngdoc object
 * @name AUTO.$provide
 *
 * @description
 *
 * Use &#x60;$provide&#x60; to register new providers with the &#x60;$injector&#x60;. The providers are the factories for the instance.
 * The providers share the same name as the instance they create with &#x60;Provider&#x60; suffixed to them.
 *
 * A provider is an object with a &#x60;$get()&#x60; method. The injector calls the &#x60;$get&#x60; method to create a new instance of
 * a service. The Provider can have additional methods which would allow for configuration of the provider.
 *
 * &lt;pre&gt;
 *   function GreetProvider() {
 *     var salutation = &#x27;Hello&#x27;;
 *
 *     this.salutation = function(text) {
 *       salutation = text;
 *     };
 *
 *     this.$get = function() {
 *       return function (name) {
 *         return salutation + &#x27; &#x27; + name + &#x27;!&#x27;;
 *       };
 *     };
 *   }
 *
 *   describe(&#x27;Greeter&#x27;, function(){
 *
 *     beforeEach(module(function($provide) {
 *       $provide.provider(&#x27;greet&#x27;, GreetProvider);
 *     }));
 *
 *     it(&#x27;should greet&#x27;, inject(function(greet) {
 *       expect(greet(&#x27;angular&#x27;)).toEqual(&#x27;Hello angular!&#x27;);
 *     }));
 *
 *     it(&#x27;should allow configuration of salutation&#x27;, function() {
 *       module(function(greetProvider) {
 *         greetProvider.salutation(&#x27;Ahoj&#x27;);
 *       });
 *       inject(function(greet) {
 *         expect(greet(&#x27;angular&#x27;)).toEqual(&#x27;Ahoj angular!&#x27;);
 *       });
 *     });
 * &lt;/pre&gt;
 */

/**
 * @ngdoc method
 * @name AUTO.$provide#provider
 * @methodOf AUTO.$provide
 * @description
 *
 * Register a provider for a service. The providers can be retrieved and can have additional configuration methods.
 *
 * @param {string} name The name of the instance. NOTE: the provider will be available under &#x60;name + &#x27;Provider&#x27;&#x60; key.
 * @param {(Object|function())} provider If the provider is:
 *
 *   - &#x60;Object&#x60;: then it should have a &#x60;$get&#x60; method. The &#x60;$get&#x60; method will be invoked using
 *               {@link AUTO.$injector#invoke $injector.invoke()} when an instance needs to be created.
 *   - &#x60;Constructor&#x60;: a new instance of the provider will be created using
 *               {@link AUTO.$injector#instantiate $injector.instantiate()}, then treated as &#x60;object&#x60;.
 *
 * @returns {Object} registered provider instance
 */

/**
 * @ngdoc method
 * @name AUTO.$provide#factory
 * @methodOf AUTO.$provide
 * @description
 *
 * A short hand for configuring services if only &#x60;$get&#x60; method is required.
 *
 * @param {string} name The name of the instance.
 * @param {function()} $getFn The $getFn for the instance creation. Internally this is a short hand for
 * &#x60;$provide.provider(name, {$get: $getFn})&#x60;.
 * @returns {Object} registered provider instance
 */


/**
 * @ngdoc method
 * @name AUTO.$provide#service
 * @methodOf AUTO.$provide
 * @description
 *
 * A short hand for registering service of given class.
 *
 * @param {string} name The name of the instance.
 * @param {Function} constructor A class (constructor function) that will be instantiated.
 * @returns {Object} registered provider instance
 */


/**
 * @ngdoc method
 * @name AUTO.$provide#value
 * @methodOf AUTO.$provide
 * @description
 *
 * A short hand for configuring services if the &#x60;$get&#x60; method is a constant.
 *
 * @param {string} name The name of the instance.
 * @param {*} value The value.
 * @returns {Object} registered provider instance
 */


/**
 * @ngdoc method
 * @name AUTO.$provide#constant
 * @methodOf AUTO.$provide
 * @description
 *
 * A constant value, but unlike {@link AUTO.$provide#value value} it can be injected
 * into configuration function (other modules) and it is not interceptable by
 * {@link AUTO.$provide#decorator decorator}.
 *
 * @param {string} name The name of the constant.
 * @param {*} value The constant value.
 * @returns {Object} registered instance
 */


/**
 * @ngdoc method
 * @name AUTO.$provide#decorator
 * @methodOf AUTO.$provide
 * @description
 *
 * Decoration of service, allows the decorator to intercept the service instance creation. The
 * returned instance may be the original instance, or a new instance which delegates to the
 * original instance.
 *
 * @param {string} name The name of the service to decorate.
 * @param {function()} decorator This function will be invoked when the service needs to be
 *    instantiated. The function is called using the {@link AUTO.$injector#invoke
 *    injector.invoke} method and is therefore fully injectable. Local injection arguments:
 *
 *    * &#x60;$delegate&#x60; - The original service instance, which can be monkey patched, configured,
 *      decorated or delegated to.
 */


function createInjector(modulesToLoad) {
  var INSTANTIATING = {},
      providerSuffix = &#x27;Provider&#x27;,
      path = [],
      loadedModules = new HashMap(),
      providerCache = {
        $provide: {
            provider: supportObject(provider),
            factory: supportObject(factory),
            service: supportObject(service),
            value: supportObject(value),
            constant: supportObject(constant),
            decorator: decorator
          }
      },
      providerInjector = (providerCache.$injector =
          createInternalInjector(providerCache, function() {
            throw Error(&quot;Unknown provider: &quot; + path.join(&#x27; &lt;- &#x27;));
          })),
      instanceCache = {},
      instanceInjector = (instanceCache.$injector =
          createInternalInjector(instanceCache, function(servicename) {
            var provider = providerInjector.get(servicename + providerSuffix);
            return instanceInjector.invoke(provider.$get, provider);
          }));


  forEach(loadModules(modulesToLoad), function(fn) { instanceInjector.invoke(fn || noop); });

  return instanceInjector;

  ////////////////////////////////////
  // $provider
  ////////////////////////////////////

  function supportObject(delegate) {
    return function(key, value) {
      if (isObject(key)) {
        forEach(key, reverseParams(delegate));
      } else {
        return delegate(key, value);
      }
    }
  }

  function provider(name, provider_) {
    if (isFunction(provider_) || isArray(provider_)) {
      provider_ = providerInjector.instantiate(provider_);
    }
    if (!provider_.$get) {
      throw Error(&#x27;Provider &#x27; + name + &#x27; must define $get factory method.&#x27;);
    }
    return providerCache[name + providerSuffix] = provider_;
  }

  function factory(name, factoryFn) { return provider(name, { $get: factoryFn }); }

  function service(name, constructor) {
    return factory(name, [&#x27;$injector&#x27;, function($injector) {
      return $injector.instantiate(constructor);
    }]);
  }

  function value(name, value) { return factory(name, valueFn(value)); }

  function constant(name, value) {
    providerCache[name] = value;
    instanceCache[name] = value;
  }

  function decorator(serviceName, decorFn) {
    var origProvider = providerInjector.get(serviceName + providerSuffix),
        orig$get = origProvider.$get;

    origProvider.$get = function() {
      var origInstance = instanceInjector.invoke(orig$get, origProvider);
      return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
    };
  }

  ////////////////////////////////////
  // Module Loading
  ////////////////////////////////////
  function loadModules(modulesToLoad){
    var runBlocks = [];
    forEach(modulesToLoad, function(module) {
      if (loadedModules.get(module)) return;
      loadedModules.put(module, true);
      if (isString(module)) {
        var moduleFn = angularModule(module);
        runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);

        try {
          for(var invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; i &lt; ii; i++) {
            var invokeArgs = invokeQueue[i],
                provider = providerInjector.get(invokeArgs[0]);

            provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
          }
        } catch (e) {
          if (e.message) e.message += &#x27; from &#x27; + module;
          throw e;
        }
      } else if (isFunction(module)) {
        try {
          runBlocks.push(providerInjector.invoke(module));
        } catch (e) {
          if (e.message) e.message += &#x27; from &#x27; + module;
          throw e;
        }
      } else if (isArray(module)) {
        try {
          runBlocks.push(providerInjector.invoke(module));
        } catch (e) {
          if (e.message) e.message += &#x27; from &#x27; + String(module[module.length - 1]);
          throw e;
        }
      } else {
        assertArgFn(module, &#x27;module&#x27;);
      }
    });
    return runBlocks;
  }

  ////////////////////////////////////
  // internal Injector
  ////////////////////////////////////

  function createInternalInjector(cache, factory) {

    function getService(serviceName) {
      if (typeof serviceName !== &#x27;string&#x27;) {
        throw Error(&#x27;Service name expected&#x27;);
      }
      if (cache.hasOwnProperty(serviceName)) {
        if (cache[serviceName] === INSTANTIATING) {
          throw Error(&#x27;Circular dependency: &#x27; + path.join(&#x27; &lt;- &#x27;));
        }
        return cache[serviceName];
      } else {
        try {
          path.unshift(serviceName);
          cache[serviceName] = INSTANTIATING;
          return cache[serviceName] = factory(serviceName);
        } finally {
          path.shift();
        }
      }
    }

    function invoke(fn, self, locals){
      var args = [],
          $inject = annotate(fn),
          length, i,
          key;

      for(i = 0, length = $inject.length; i &lt; length; i++) {
        key = $inject[i];
        args.push(
          locals &amp;&amp; locals.hasOwnProperty(key)
          ? locals[key]
          : getService(key)
        );
      }
      if (!fn.$inject) {
        // this means that we must be an array.
        fn = fn[length];
      }


      // Performance optimization: http://jsperf.com/apply-vs-call-vs-invoke
      switch (self ? -1 : args.length) {
        case  0: return fn();
        case  1: return fn(args[0]);
        case  2: return fn(args[0], args[1]);
        case  3: return fn(args[0], args[1], args[2]);
        case  4: return fn(args[0], args[1], args[2], args[3]);
        case  5: return fn(args[0], args[1], args[2], args[3], args[4]);
        case  6: return fn(args[0], args[1], args[2], args[3], args[4], args[5]);
        case  7: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        case  8: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
        case  9: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);
        case 10: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);
        default: return fn.apply(self, args);
      }
    }

    function instantiate(Type, locals) {
      var Constructor = function() {},
          instance, returnedValue;

      // Check if Type is annotated and use just the given function at n-1 as parameter
      // e.g. someModule.factory(&#x27;greeter&#x27;, [&#x27;$window&#x27;, function(renamed$window) {}]);
      Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype;
      instance = new Constructor();
      returnedValue = invoke(Type, instance, locals);

      return isObject(returnedValue) ? returnedValue : instance;
    }

    return {
      invoke: invoke,
      instantiate: instantiate,
      get: getService,
      annotate: annotate,
      has: function(name) {
        return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
      }
    };
  }
}

/**
 * @ngdoc function
 * @name ng.$anchorScroll
 * @requires $window
 * @requires $location
 * @requires $rootScope
 *
 * @description
 * When called, it checks current value of &#x60;$location.hash()&#x60; and scroll to related element,
 * according to rules specified in
 * {@link http://dev.w3.org/html5/spec/Overview.html#the-indicated-part-of-the-document Html5 spec}.
 *
 * It also watches the &#x60;$location.hash()&#x60; and scroll whenever it changes to match any anchor.
 * This can be disabled by calling &#x60;$anchorScrollProvider.disableAutoScrolling()&#x60;.
 */
function $AnchorScrollProvider() {

  var autoScrollingEnabled = true;

  this.disableAutoScrolling = function() {
    autoScrollingEnabled = false;
  };

  this.$get = [&#x27;$window&#x27;, &#x27;$location&#x27;, &#x27;$rootScope&#x27;, function($window, $location, $rootScope) {
    var document = $window.document;

    // helper function to get first anchor from a NodeList
    // can&#x27;t use filter.filter, as it accepts only instances of Array
    // and IE can&#x27;t convert NodeList to an array using [].slice
    // TODO(vojta): use filter if we change it to accept lists as well
    function getFirstAnchor(list) {
      var result = null;
      forEach(list, function(element) {
        if (!result &amp;&amp; lowercase(element.nodeName) === &#x27;a&#x27;) result = element;
      });
      return result;
    }

    function scroll() {
      var hash = $location.hash(), elm;

      // empty hash, scroll to the top of the page
      if (!hash) $window.scrollTo(0, 0);

      // element with given id
      else if ((elm = document.getElementById(hash))) elm.scrollIntoView();

      // first anchor with given name :-D
      else if ((elm = getFirstAnchor(document.getElementsByName(hash)))) elm.scrollIntoView();

      // no element and hash == &#x27;top&#x27;, scroll to the top of the page
      else if (hash === &#x27;top&#x27;) $window.scrollTo(0, 0);
    }

    // does not scroll when user clicks on anchor link that is currently on
    // (no url change, no $location.hash() change), browser native does scroll
    if (autoScrollingEnabled) {
      $rootScope.$watch(function autoScrollWatch() {return $location.hash();},
        function autoScrollWatchAction() {
          $rootScope.$evalAsync(scroll);
        });
    }

    return scroll;
  }];
}


/**
 * @ngdoc object
 * @name ng.$animationProvider
 * @description
 *
 * The $AnimationProvider provider allows developers to register and access custom JavaScript animations directly inside
 * of a module.
 *
 */
$AnimationProvider.$inject = [&#x27;$provide&#x27;];
function $AnimationProvider($provide) {
  var suffix = &#x27;Animation&#x27;;

  /**
   * @ngdoc function
   * @name ng.$animation#register
   * @methodOf ng.$animationProvider
   *
   * @description
   * Registers a new injectable animation factory function. The factory function produces the animation object which
   * has these two properties:
   *
   *   * &#x60;setup&#x60;: &#x60;function(Element):*&#x60; A function which receives the starting state of the element. The purpose
   *   of this function is to get the element ready for animation. Optionally the function returns an memento which
   *   is passed to the &#x60;start&#x60; function.
   *   * &#x60;start&#x60;: &#x60;function(Element, doneFunction, *)&#x60; The element to animate, the &#x60;doneFunction&#x60; to be called on
   *   element animation completion, and an optional memento from the &#x60;setup&#x60; function.
   *
   * @param {string} name The name of the animation.
   * @param {function} factory The factory function that will be executed to return the animation object.
   * 
   */
  this.register = function(name, factory) {
    $provide.factory(camelCase(name) + suffix, factory);
  };

  this.$get = [&#x27;$injector&#x27;, function($injector) {
    /**
     * @ngdoc function
     * @name ng.$animation
     * @function
     *
     * @description
     * The $animation service is used to retrieve any defined animation functions. When executed, the $animation service
     * will return a object that contains the setup and start functions that were defined for the animation.
     *
     * @param {String} name Name of the animation function to retrieve. Animation functions are registered and stored
     *        inside of the AngularJS DI so a call to $animate(&#x27;custom&#x27;) is the same as injecting &#x60;customAnimation&#x60;
     *        via dependency injection.
     * @return {Object} the animation object which contains the &#x60;setup&#x60; and &#x60;start&#x60; functions that perform the animation.
     */
    return function $animation(name) {
      if (name) {
        var animationName = camelCase(name) + suffix;
        if ($injector.has(animationName)) {
          return $injector.get(animationName);
        }
      }
    };
  }];
}

// NOTE: this is a pseudo directive.

/**
 * @ngdoc directive
 * @name ng.directive:ngAnimate
 *
 * @description
 * The &#x60;ngAnimate&#x60; directive works as an attribute that is attached alongside pre-existing directives.
 * It effects how the directive will perform DOM manipulation. This allows for complex animations to take place
 * without burdening the directive which uses the animation with animation details. The built in directives
 * &#x60;ngRepeat&#x60;, &#x60;ngInclude&#x60;, &#x60;ngSwitch&#x60;, &#x60;ngShow&#x60;, &#x60;ngHide&#x60; and &#x60;ngView&#x60; already accept &#x60;ngAnimate&#x60; directive.
 * Custom directives can take advantage of animation through {@link ng.$animator $animator service}.
 *
 * Below is a more detailed breakdown of the supported callback events provided by pre-exisitng ng directives:
 *
 * | Directive                                                 | Supported Animations                               |
 * |========================================================== |====================================================|
 * | {@link ng.directive:ngRepeat#animations ngRepeat}         | enter, leave and move                              |
 * | {@link ng.directive:ngView#animations ngView}             | enter and leave                                    |
 * | {@link ng.directive:ngInclude#animations ngInclude}       | enter and leave                                    |
 * | {@link ng.directive:ngSwitch#animations ngSwitch}         | enter and leave                                    |
 * | {@link ng.directive:ngIf#animations ngIf}                 | enter and leave                                    |
 * | {@link ng.directive:ngShow#animations ngShow &amp; ngHide}    | show and hide                                      |
 *
 * You can find out more information about animations upon visiting each directive page.
 *
 * Below is an example of a directive that makes use of the ngAnimate attribute:
 *
 * &lt;pre&gt;
 * &lt;!-- you can also use data-ng-animate, ng:animate or x-ng-animate as well --&gt;
 * &lt;ANY ng-directive ng-animate=&quot;{event1: &#x27;animation-name&#x27;, event2: &#x27;animation-name-2&#x27;}&quot;&gt;&lt;/ANY&gt;
 *
 * &lt;!-- you can also use a short hand --&gt;
 * &lt;ANY ng-directive ng-animate=&quot; &#x27;animation&#x27; &quot;&gt;&lt;/ANY&gt;
 * &lt;!-- which expands to --&gt;
 * &lt;ANY ng-directive ng-animate=&quot;{ enter: &#x27;animation-enter&#x27;, leave: &#x27;animation-leave&#x27;, ...}&quot;&gt;&lt;/ANY&gt;
 *
 * &lt;!-- keep in mind that ng-animate can take expressions --&gt;
 * &lt;ANY ng-directive ng-animate=&quot; computeCurrentAnimation() &quot;&gt;&lt;/ANY&gt;
 * &lt;/pre&gt;
 *
 * The &#x60;event1&#x60; and &#x60;event2&#x60; attributes refer to the animation events specific to the directive that has been assigned.
 *
 * Keep in mind that if an animation is running, no child element of such animation can also be animated.
 *
 * &lt;h2&gt;CSS-defined Animations&lt;/h2&gt;
 * By default, ngAnimate attaches two CSS classes per animation event to the DOM element to achieve the animation.
 * It is up to you, the developer, to ensure that the animations take place using cross-browser CSS3 transitions as
 * well as CSS animations.
 *
 * The following code below demonstrates how to perform animations using **CSS transitions** with ngAnimate:
 *
 * &lt;pre&gt;
 * &lt;style type=&quot;text/css&quot;&gt;
 * /&amp;#42;
 *  The animate-enter CSS class is the event name that you
 *  have provided within the ngAnimate attribute.
 * &amp;#42;/
 * .animate-enter {
 *  -webkit-transition: 1s linear all; /&amp;#42; Safari/Chrome &amp;#42;/
 *  -moz-transition: 1s linear all; /&amp;#42; Firefox &amp;#42;/
 *  -o-transition: 1s linear all; /&amp;#42; Opera &amp;#42;/
 *  transition: 1s linear all; /&amp;#42; IE10+ and Future Browsers &amp;#42;/
 *
 *  /&amp;#42; The animation preparation code &amp;#42;/
 *  opacity: 0;
 * }
 *
 * /&amp;#42;
 *  Keep in mind that you want to combine both CSS
 *  classes together to avoid any CSS-specificity
 *  conflicts
 * &amp;#42;/
 * .animate-enter.animate-enter-active {
 *  /&amp;#42; The animation code itself &amp;#42;/
 *  opacity: 1;
 * }
 * &lt;/style&gt;
 *
 * &lt;div ng-directive ng-animate=&quot;{enter: &#x27;animate-enter&#x27;}&quot;&gt;&lt;/div&gt;
 * &lt;/pre&gt;
 *
 * The following code below demonstrates how to perform animations using **CSS animations** with ngAnimate:
 *
 * &lt;pre&gt;
 * &lt;style type=&quot;text/css&quot;&gt;
 * .animate-enter {
 *   -webkit-animation: enter_sequence 1s linear; /&amp;#42; Safari/Chrome &amp;#42;/
 *   -moz-animation: enter_sequence 1s linear; /&amp;#42; Firefox &amp;#42;/
 *   -o-animation: enter_sequence 1s linear; /&amp;#42; Opera &amp;#42;/
 *   animation: enter_sequence 1s linear; /&amp;#42; IE10+ and Future Browsers &amp;#42;/
 * }
 * &amp;#64-webkit-keyframes enter_sequence {
 *   from { opacity:0; }
 *   to { opacity:1; }
 * }
 * &amp;#64-moz-keyframes enter_sequence {
 *   from { opacity:0; }
 *   to { opacity:1; }
 * }
 * &amp;#64-o-keyframes enter_sequence {
 *   from { opacity:0; }
 *   to { opacity:1; }
 * }
 * &amp;#64keyframes enter_sequence {
 *   from { opacity:0; }
 *   to { opacity:1; }
 * }
 * &lt;/style&gt;
 *
 * &lt;div ng-directive ng-animate=&quot;{enter: &#x27;animate-enter&#x27;}&quot;&gt;&lt;/div&gt;
 * &lt;/pre&gt;
 *
 * ngAnimate will first examine any CSS animation code and then fallback to using CSS transitions.
 *
 * Upon DOM mutation, the event class is added first, then the browser is allowed to reflow the content and then,
 * the active class is added to trigger the animation. The ngAnimate directive will automatically extract the duration
 * of the animation to determine when the animation ends. Once the animation is over then both CSS classes will be
 * removed from the DOM. If a browser does not support CSS transitions or CSS animations then the animation will start and end
 * immediately resulting in a DOM element that is at it&#x27;s final state. This final state is when the DOM element
 * has no CSS transition/animation classes surrounding it.
 *
 * &lt;h2&gt;JavaScript-defined Animations&lt;/h2&gt;
 * In the event that you do not want to use CSS3 transitions or CSS3 animations or if you wish to offer animations to browsers that do not
 * yet support them, then you can make use of JavaScript animations defined inside of your AngularJS module.
 *
 * &lt;pre&gt;
 * var ngModule = angular.module(&#x27;YourApp&#x27;, []);
 * ngModule.animation(&#x27;animate-enter&#x27;, function() {
 *   return {
 *     setup : function(element) {
 *       //prepare the element for animation
 *       element.css({ &#x27;opacity&#x27;: 0 });
 *       var memo = &quot;...&quot;; //this value is passed to the start function
 *       return memo;
 *     },
 *     start : function(element, done, memo) {
 *       //start the animation
 *       element.animate({
 *         &#x27;opacity&#x27; : 1
 *       }, function() {
 *         //call when the animation is complete
 *         done()
 *       });
 *     }
 *   }
 * });
 * &lt;/pre&gt;
 *
 * As you can see, the JavaScript code follows a similar template to the CSS3 animations. Once defined, the animation
 * can be used in the same way with the ngAnimate attribute. Keep in mind that, when using JavaScript-enabled
 * animations, ngAnimate will also add in the same CSS classes that CSS-enabled animations do (even if you&#x27;re not using
 * CSS animations) to animated the element, but it will not attempt to find any CSS3 transition or animation duration/delay values.
 * It will instead close off the animation once the provided done function is executed. So it&#x27;s important that you
 * make sure your animations remember to fire off the done function once the animations are complete.
 *
 * @param {expression} ngAnimate Used to configure the DOM manipulation animations.
 *
 */

var $AnimatorProvider = function() {
  var NG_ANIMATE_CONTROLLER = &#x27;$ngAnimateController&#x27;;
  var rootAnimateController = {running:true};

  this.$get = [&#x27;$animation&#x27;, &#x27;$window&#x27;, &#x27;$sniffer&#x27;, &#x27;$rootElement&#x27;, &#x27;$rootScope&#x27;,
      function($animation, $window, $sniffer, $rootElement, $rootScope) {
    $rootElement.data(NG_ANIMATE_CONTROLLER, rootAnimateController);

    /**
     * @ngdoc function
     * @name ng.$animator
     * @function
     *
     * @description
     * The $animator.create service provides the DOM manipulation API which is decorated with animations.
     *
     * @param {Scope} scope the scope for the ng-animate.
     * @param {Attributes} attr the attributes object which contains the ngAnimate key / value pair. (The attributes are
     *        passed into the linking function of the directive using the &#x60;$animator&#x60;.)
     * @return {object} the animator object which contains the enter, leave, move, show, hide and animate methods.
     */
     var AnimatorService = function(scope, attrs) {
        var animator = {};
  
        /**
         * @ngdoc function
         * @name ng.animator#enter
         * @methodOf ng.$animator
         * @function
         *
         * @description
         * Injects the element object into the DOM (inside of the parent element) and then runs the enter animation.
         *
         * @param {jQuery/jqLite element} element the element that will be the focus of the enter animation
         * @param {jQuery/jqLite element} parent the parent element of the element that will be the focus of the enter animation
         * @param {jQuery/jqLite element} after the sibling element (which is the previous element) of the element that will be the focus of the enter animation
        */
        animator.enter = animateActionFactory(&#x27;enter&#x27;, insert, noop);
  
        /**
         * @ngdoc function
         * @name ng.animator#leave
         * @methodOf ng.$animator
         * @function
         *
         * @description
         * Runs the leave animation operation and, upon completion, removes the element from the DOM.
         *
         * @param {jQuery/jqLite element} element the element that will be the focus of the leave animation
         * @param {jQuery/jqLite element} parent the parent element of the element that will be the focus of the leave animation
        */
        animator.leave = animateActionFactory(&#x27;leave&#x27;, noop, remove);
  
        /**
         * @ngdoc function
         * @name ng.animator#move
         * @methodOf ng.$animator
         * @function
         *
         * @description
         * Fires the move DOM operation. Just before the animation starts, the animator will either append it into the parent container or
         * add the element directly after the after element if present. Then the move animation will be run.
         *
         * @param {jQuery/jqLite element} element the element that will be the focus of the move animation
         * @param {jQuery/jqLite element} parent the parent element of the element that will be the focus of the move animation
         * @param {jQuery/jqLite element} after the sibling element (which is the previous element) of the element that will be the focus of the move animation
        */
        animator.move = animateActionFactory(&#x27;move&#x27;, move, noop);
  
        /**
         * @ngdoc function
         * @name ng.animator#show
         * @methodOf ng.$animator
         * @function
         *
         * @description
         * Reveals the element by setting the CSS property &#x60;display&#x60; to &#x60;block&#x60; and then starts the show animation directly after.
         *
         * @param {jQuery/jqLite element} element the element that will be rendered visible or hidden
        */
        animator.show = animateActionFactory(&#x27;show&#x27;, show, noop);
  
        /**
         * @ngdoc function
         * @name ng.animator#hide
         * @methodOf ng.$animator
         *
         * @description
         * Starts the hide animation first and sets the CSS &#x60;display&#x60; property to &#x60;none&#x60; upon completion.
         *
         * @param {jQuery/jqLite element} element the element that will be rendered visible or hidden
        */
        animator.hide = animateActionFactory(&#x27;hide&#x27;, noop, hide);

        /**
         * @ngdoc function
         * @name ng.animator#animate
         * @methodOf ng.$animator
         *
         * @description
         * Triggers a custom animation event to be executed on the given element
         *
         * @param {jQuery/jqLite element} element that will be animated
        */
        animator.animate = function(event, element) {
          animateActionFactory(event, noop, noop)(element);
        }
        return animator;
  
        function animateActionFactory(type, beforeFn, afterFn) {
          return function(element, parent, after) {
            var ngAnimateValue = scope.$eval(attrs.ngAnimate);
            var className = ngAnimateValue
                ? isObject(ngAnimateValue) ? ngAnimateValue[type] : ngAnimateValue + &#x27;-&#x27; + type
                : &#x27;&#x27;;
            var animationPolyfill = $animation(className);
            var polyfillSetup = animationPolyfill &amp;&amp; animationPolyfill.setup;
            var polyfillStart = animationPolyfill &amp;&amp; animationPolyfill.start;
            var polyfillCancel = animationPolyfill &amp;&amp; animationPolyfill.cancel;

            if (!className) {
              beforeFn(element, parent, after);
              afterFn(element, parent, after);
            } else {
              var activeClassName = className + &#x27;-active&#x27;;

              if (!parent) {
                parent = after ? after.parent() : element.parent();
              }
              if ((!$sniffer.transitions &amp;&amp; !polyfillSetup &amp;&amp; !polyfillStart) ||
                  (parent.inheritedData(NG_ANIMATE_CONTROLLER) || noop).running) {
                beforeFn(element, parent, after);
                afterFn(element, parent, after);
                return;
              }

              var animationData = element.data(NG_ANIMATE_CONTROLLER) || {};
              if(animationData.running) {
                (polyfillCancel || noop)(element);
                animationData.done();
              }

              element.data(NG_ANIMATE_CONTROLLER, {running:true, done:done});
              element.addClass(className);
              beforeFn(element, parent, after);
              if (element.length == 0) return done();

              var memento = (polyfillSetup || noop)(element);

              // $window.setTimeout(beginAnimation, 0); this was causing the element not to animate
              // keep at 1 for animation dom rerender
              $window.setTimeout(beginAnimation, 1);
            }

            function parseMaxTime(str) {
              var total = 0, values = isString(str) ? str.split(/\s*,\s*/) : [];
              forEach(values, function(value) {
                total = Math.max(parseFloat(value) || 0, total);
              });
              return total;
            }

            function beginAnimation() {
              element.addClass(activeClassName);
              if (polyfillStart) {
                polyfillStart(element, done, memento);
              } else if (isFunction($window.getComputedStyle)) {
                //one day all browsers will have these properties
                var w3cAnimationProp = &#x27;animation&#x27;; 
                var w3cTransitionProp = &#x27;transition&#x27;;

                //but some still use vendor-prefixed styles 
                var vendorAnimationProp = $sniffer.vendorPrefix + &#x27;Animation&#x27;;
                var vendorTransitionProp = $sniffer.vendorPrefix + &#x27;Transition&#x27;;

                var durationKey = &#x27;Duration&#x27;,
                    delayKey = &#x27;Delay&#x27;,
                    animationIterationCountKey = &#x27;IterationCount&#x27;,
                    duration = 0;
                
                //we want all the styles defined before and after
                var ELEMENT_NODE = 1;
                forEach(element, function(element) {
                  if (element.nodeType == ELEMENT_NODE) {
                    var w3cProp = w3cTransitionProp,
                        vendorProp = vendorTransitionProp,
                        iterations = 1,
                        elementStyles = $window.getComputedStyle(element) || {};

                    //use CSS Animations over CSS Transitions
                    if(parseFloat(elementStyles[w3cAnimationProp + durationKey]) &gt; 0 ||
                       parseFloat(elementStyles[vendorAnimationProp + durationKey]) &gt; 0) {
                      w3cProp = w3cAnimationProp;
                      vendorProp = vendorAnimationProp;
                      iterations = Math.max(parseInt(elementStyles[w3cProp    + animationIterationCountKey]) || 0,
                                            parseInt(elementStyles[vendorProp + animationIterationCountKey]) || 0,
                                            iterations);
                    }

                    var parsedDelay     = Math.max(parseMaxTime(elementStyles[w3cProp     + delayKey]),
                                                   parseMaxTime(elementStyles[vendorProp  + delayKey]));

                    var parsedDuration  = Math.max(parseMaxTime(elementStyles[w3cProp     + durationKey]),
                                                   parseMaxTime(elementStyles[vendorProp  + durationKey]));

                    duration = Math.max(parsedDelay + (iterations * parsedDuration), duration);
                  }
                });
                $window.setTimeout(done, duration * 1000);
              } else {
                done();
              }
            }

            function done() {
              if(!done.run) {
                done.run = true;
                afterFn(element, parent, after);
                element.removeClass(className);
                element.removeClass(activeClassName);
                element.removeData(NG_ANIMATE_CONTROLLER);
              }
            }
          };
        }
  
        function show(element) {
          element.css(&#x27;display&#x27;, &#x27;&#x27;);
        }
  
        function hide(element) {
          element.css(&#x27;display&#x27;, &#x27;none&#x27;);
        }
  
        function insert(element, parent, after) {
          if (after) {
            after.after(element);
          } else {
            parent.append(element);
          }
        }
  
        function remove(element) {
          element.remove();
        }
  
        function move(element, parent, after) {
          // Do not remove element before insert. Removing will cause data associated with the
          // element to be dropped. Insert will implicitly do the remove.
          insert(element, parent, after);
        }
      };

    /**
     * @ngdoc function
     * @name ng.animator#enabled
     * @methodOf ng.$animator
     * @function
     *
     * @param {Boolean=} If provided then set the animation on or off.
     * @return {Boolean} Current animation state.
     *
     * @description
     * Globally enables/disables animations.
     *
    */
    AnimatorService.enabled = function(value) {
      if (arguments.length) {
        rootAnimateController.running = !value;
      }
      return !rootAnimateController.running;
    };

    return AnimatorService;
  }];
};

/**
 * ! This is a private undocumented service !
 *
 * @name ng.$browser
 * @requires $log
 * @description
 * This object has two goals:
 *
 * - hide all the global state in the browser caused by the window object
 * - abstract away all the browser specific features and inconsistencies
 *
 * For tests we provide {@link ngMock.$browser mock implementation} of the &#x60;$browser&#x60;
 * service, which can be used for convenient testing of the application without the interaction with
 * the real browser apis.
 */
/**
 * @param {object} window The global window object.
 * @param {object} document jQuery wrapped document.
 * @param {function()} XHR XMLHttpRequest constructor.
 * @param {object} $log console.log or an object with the same interface.
 * @param {object} $sniffer $sniffer service
 */
function Browser(window, document, $log, $sniffer) {
  var self = this,
      rawDocument = document[0],
      location = window.location,
      history = window.history,
      setTimeout = window.setTimeout,
      clearTimeout = window.clearTimeout,
      pendingDeferIds = {};

  self.isMock = false;

  var outstandingRequestCount = 0;
  var outstandingRequestCallbacks = [];

  // TODO(vojta): remove this temporary api
  self.$$completeOutstandingRequest = completeOutstandingRequest;
  self.$$incOutstandingRequestCount = function() { outstandingRequestCount++; };

  /**
   * Executes the &#x60;fn&#x60; function(supports currying) and decrements the &#x60;outstandingRequestCallbacks&#x60;
   * counter. If the counter reaches 0, all the &#x60;outstandingRequestCallbacks&#x60; are executed.
   */
  function completeOutstandingRequest(fn) {
    try {
      fn.apply(null, sliceArgs(arguments, 1));
    } finally {
      outstandingRequestCount--;
      if (outstandingRequestCount === 0) {
        while(outstandingRequestCallbacks.length) {
          try {
            outstandingRequestCallbacks.pop()();
          } catch (e) {
            $log.error(e);
          }
        }
      }
    }
  }

  /**
   * @private
   * Note: this method is used only by scenario runner
   * TODO(vojta): prefix this method with $$ ?
   * @param {function()} callback Function that will be called when no outstanding request
   */
  self.notifyWhenNoOutstandingRequests = function(callback) {
    // force browser to execute all pollFns - this is needed so that cookies and other pollers fire
    // at some deterministic time in respect to the test runner&#x27;s actions. Leaving things up to the
    // regular poller would result in flaky tests.
    forEach(pollFns, function(pollFn){ pollFn(); });

    if (outstandingRequestCount === 0) {
      callback();
    } else {
      outstandingRequestCallbacks.push(callback);
    }
  };

  //////////////////////////////////////////////////////////////
  // Poll Watcher API
  //////////////////////////////////////////////////////////////
  var pollFns = [],
      pollTimeout;

  /**
   * @name ng.$browser#addPollFn
   * @methodOf ng.$browser
   *
   * @param {function()} fn Poll function to add
   *
   * @description
   * Adds a function to the list of functions that poller periodically executes,
   * and starts polling if not started yet.
   *
   * @returns {function()} the added function
   */
  self.addPollFn = function(fn) {
    if (isUndefined(pollTimeout)) startPoller(100, setTimeout);
    pollFns.push(fn);
    return fn;
  };

  /**
   * @param {number} interval How often should browser call poll functions (ms)
   * @param {function()} setTimeout Reference to a real or fake &#x60;setTimeout&#x60; function.
   *
   * @description
   * Configures the poller to run in the specified intervals, using the specified
   * setTimeout fn and kicks it off.
   */
  function startPoller(interval, setTimeout) {
    (function check() {
      forEach(pollFns, function(pollFn){ pollFn(); });
      pollTimeout = setTimeout(check, interval);
    })();
  }

  //////////////////////////////////////////////////////////////
  // URL API
  //////////////////////////////////////////////////////////////

  var lastBrowserUrl = location.href,
      baseElement = document.find(&#x27;base&#x27;);

  /**
   * @name ng.$browser#url
   * @methodOf ng.$browser
   *
   * @description
   * GETTER:
   * Without any argument, this method just returns current value of location.href.
   *
   * SETTER:
   * With at least one argument, this method sets url to new value.
   * If html5 history api supported, pushState/replaceState is used, otherwise
   * location.href/location.replace is used.
   * Returns its own instance to allow chaining
   *
   * NOTE: this api is intended for use only by the $location service. Please use the
   * {@link ng.$location $location service} to change url.
   *
   * @param {string} url New url (when used as setter)
   * @param {boolean=} replace Should new url replace current history record ?
   */
  self.url = function(url, replace) {
    // setter
    if (url) {
      if (lastBrowserUrl == url) return;
      lastBrowserUrl = url;
      if ($sniffer.history) {
        if (replace) history.replaceState(null, &#x27;&#x27;, url);
        else {
          history.pushState(null, &#x27;&#x27;, url);
          // Crazy Opera Bug: http://my.opera.com/community/forums/topic.dml?id=1185462
          baseElement.attr(&#x27;href&#x27;, baseElement.attr(&#x27;href&#x27;));
        }
      } else {
        if (replace) location.replace(url);
        else location.href = url;
      }
      return self;
    // getter
    } else {
      // the replacement is a workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=407172
      return location.href.replace(/%27/g,&quot;&#x27;&quot;);
    }
  };

  var urlChangeListeners = [],
      urlChangeInit = false;

  function fireUrlChange() {
    if (lastBrowserUrl == self.url()) return;

    lastBrowserUrl = self.url();
    forEach(urlChangeListeners, function(listener) {
      listener(self.url());
    });
  }

  /**
   * @name ng.$browser#onUrlChange
   * @methodOf ng.$browser
   * @TODO(vojta): refactor to use node&#x27;s syntax for events
   *
   * @description
   * Register callback function that will be called, when url changes.
   *
   * It&#x27;s only called when the url is changed by outside of angular:
   * - user types different url into address bar
   * - user clicks on history (forward/back) button
   * - user clicks on a link
   *
   * It&#x27;s not called when url is changed by $browser.url() method
   *
   * The listener gets called with new url as parameter.
   *
   * NOTE: this api is intended for use only by the $location service. Please use the
   * {@link ng.$location $location service} to monitor url changes in angular apps.
   *
   * @param {function(string)} listener Listener function to be called when url changes.
   * @return {function(string)} Returns the registered listener fn - handy if the fn is anonymous.
   */
  self.onUrlChange = function(callback) {
    if (!urlChangeInit) {
      // We listen on both (hashchange/popstate) when available, as some browsers (e.g. Opera)
      // don&#x27;t fire popstate when user change the address bar and don&#x27;t fire hashchange when url
      // changed by push/replaceState

      // html5 history api - popstate event
      if ($sniffer.history) jqLite(window).bind(&#x27;popstate&#x27;, fireUrlChange);
      // hashchange event
      if ($sniffer.hashchange) jqLite(window).bind(&#x27;hashchange&#x27;, fireUrlChange);
      // polling
      else self.addPollFn(fireUrlChange);

      urlChangeInit = true;
    }

    urlChangeListeners.push(callback);
    return callback;
  };

  //////////////////////////////////////////////////////////////
  // Misc API
  //////////////////////////////////////////////////////////////

  /**
   * Returns current &lt;base href&gt;
   * (always relative - without domain)
   *
   * @returns {string=}
   */
  self.baseHref = function() {
    var href = baseElement.attr(&#x27;href&#x27;);
    return href ? href.replace(/^https?\:\/\/[^\/]*/, &#x27;&#x27;) : &#x27;&#x27;;
  };

  //////////////////////////////////////////////////////////////
  // Cookies API
  //////////////////////////////////////////////////////////////
  var lastCookies = {};
  var lastCookieString = &#x27;&#x27;;
  var cookiePath = self.baseHref();

  /**
   * @name ng.$browser#cookies
   * @methodOf ng.$browser
   *
   * @param {string=} name Cookie name
   * @param {string=} value Cookie value
   *
   * @description
   * The cookies method provides a &#x27;private&#x27; low level access to browser cookies.
   * It is not meant to be used directly, use the $cookie service instead.
   *
   * The return values vary depending on the arguments that the method was called with as follows:
   * &lt;ul&gt;
   *   &lt;li&gt;cookies() -&gt; hash of all cookies, this is NOT a copy of the internal state, so do not modify it&lt;/li&gt;
   *   &lt;li&gt;cookies(name, value) -&gt; set name to value, if value is undefined delete the cookie&lt;/li&gt;
   *   &lt;li&gt;cookies(name) -&gt; the same as (name, undefined) == DELETES (no one calls it right now that way)&lt;/li&gt;
   * &lt;/ul&gt;
   *
   * @returns {Object} Hash of all cookies (if called without any parameter)
   */
  self.cookies = function(name, value) {
    var cookieLength, cookieArray, cookie, i, index;

    if (name) {
      if (value === undefined) {
        rawDocument.cookie = escape(name) + &quot;=;path=&quot; + cookiePath + &quot;;expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;;
      } else {
        if (isString(value)) {
          cookieLength = (rawDocument.cookie = escape(name) + &#x27;=&#x27; + escape(value) + &#x27;;path=&#x27; + cookiePath).length + 1;

          // per http://www.ietf.org/rfc/rfc2109.txt browser must allow at minimum:
          // - 300 cookies
          // - 20 cookies per unique domain
          // - 4096 bytes per cookie
          if (cookieLength &gt; 4096) {
            $log.warn(&quot;Cookie &#x27;&quot;+ name +&quot;&#x27; possibly not set or overflowed because it was too large (&quot;+
              cookieLength + &quot; &gt; 4096 bytes)!&quot;);
          }
        }
      }
    } else {
      if (rawDocument.cookie !== lastCookieString) {
        lastCookieString = rawDocument.cookie;
        cookieArray = lastCookieString.split(&quot;; &quot;);
        lastCookies = {};

        for (i = 0; i &lt; cookieArray.length; i++) {
          cookie = cookieArray[i];
          index = cookie.indexOf(&#x27;=&#x27;);
          if (index &gt; 0) { //ignore nameless cookies
            var name = unescape(cookie.substring(0, index));
            // the first value that is seen for a cookie is the most
            // specific one.  values for the same cookie name that
            // follow are for less specific paths.
            if (lastCookies[name] === undefined) {
              lastCookies[name] = unescape(cookie.substring(index + 1));
            }
          }
        }
      }
      return lastCookies;
    }
  };


  /**
   * @name ng.$browser#defer
   * @methodOf ng.$browser
   * @param {function()} fn A function, who&#x27;s execution should be defered.
   * @param {number=} [delay=0] of milliseconds to defer the function execution.
   * @returns {*} DeferId that can be used to cancel the task via &#x60;$browser.defer.cancel()&#x60;.
   *
   * @description
   * Executes a fn asynchronously via &#x60;setTimeout(fn, delay)&#x60;.
   *
   * Unlike when calling &#x60;setTimeout&#x60; directly, in test this function is mocked and instead of using
   * &#x60;setTimeout&#x60; in tests, the fns are queued in an array, which can be programmatically flushed
   * via &#x60;$browser.defer.flush()&#x60;.
   *
   */
  self.defer = function(fn, delay) {
    var timeoutId;
    outstandingRequestCount++;
    timeoutId = setTimeout(function() {
      delete pendingDeferIds[timeoutId];
      completeOutstandingRequest(fn);
    }, delay || 0);
    pendingDeferIds[timeoutId] = true;
    return timeoutId;
  };


  /**
   * @name ng.$browser#defer.cancel
   * @methodOf ng.$browser.defer
   *
   * @description
   * Cancels a defered task identified with &#x60;deferId&#x60;.
   *
   * @param {*} deferId Token returned by the &#x60;$browser.defer&#x60; function.
   * @returns {boolean} Returns &#x60;true&#x60; if the task hasn&#x27;t executed yet and was successfully canceled.
   */
  self.defer.cancel = function(deferId) {
    if (pendingDeferIds[deferId]) {
      delete pendingDeferIds[deferId];
      clearTimeout(deferId);
      completeOutstandingRequest(noop);
      return true;
    }
    return false;
  };

}

function $BrowserProvider(){
  this.$get = [&#x27;$window&#x27;, &#x27;$log&#x27;, &#x27;$sniffer&#x27;, &#x27;$document&#x27;,
      function( $window,   $log,   $sniffer,   $document){
        return new Browser($window, $document, $log, $sniffer);
      }];
}

/**
 * @ngdoc object
 * @name ng.$cacheFactory
 *
 * @description
 * Factory that constructs cache objects.
 *
 *
 * @param {string} cacheId Name or id of the newly created cache.
 * @param {object=} options Options object that specifies the cache behavior. Properties:
 *
 *   - &#x60;{number=}&#x60; &#x60;capacity&#x60;  turns the cache into LRU cache.
 *
 * @returns {object} Newly created cache object with the following set of methods:
 *
 * - &#x60;{object}&#x60; &#x60;info()&#x60;  Returns id, size, and options of cache.
 * - &#x60;{{*}}&#x60; &#x60;put({string} key, {*} value)&#x60;  Puts a new key-value pair into the cache and returns it.
 * - &#x60;{{*}}&#x60; &#x60;get({string} key)&#x60;  Returns cached value for &#x60;key&#x60; or undefined for cache miss.
 * - &#x60;{void}&#x60; &#x60;remove({string} key)&#x60;  Removes a key-value pair from the cache.
 * - &#x60;{void}&#x60; &#x60;removeAll()&#x60;  Removes all cached values.
 * - &#x60;{void}&#x60; &#x60;destroy()&#x60;  Removes references to this cache from $cacheFactory.
 *
 */
function $CacheFactoryProvider() {

  this.$get = function() {
    var caches = {};

    function cacheFactory(cacheId, options) {
      if (cacheId in caches) {
        throw Error(&#x27;cacheId &#x27; + cacheId + &#x27; taken&#x27;);
      }

      var size = 0,
          stats = extend({}, options, {id: cacheId}),
          data = {},
          capacity = (options &amp;&amp; options.capacity) || Number.MAX_VALUE,
          lruHash = {},
          freshEnd = null,
          staleEnd = null;

      return caches[cacheId] = {

        put: function(key, value) {
          var lruEntry = lruHash[key] || (lruHash[key] = {key: key});

          refresh(lruEntry);

          if (isUndefined(value)) return;
          if (!(key in data)) size++;
          data[key] = value;

          if (size &gt; capacity) {
            this.remove(staleEnd.key);
          }

          return value;
        },


        get: function(key) {
          var lruEntry = lruHash[key];

          if (!lruEntry) return;

          refresh(lruEntry);

          return data[key];
        },


        remove: function(key) {
          var lruEntry = lruHash[key];

          if (!lruEntry) return;

          if (lruEntry == freshEnd) freshEnd = lruEntry.p;
          if (lruEntry == staleEnd) staleEnd = lruEntry.n;
          link(lruEntry.n,lruEntry.p);

          delete lruHash[key];
          delete data[key];
          size--;
        },


        removeAll: function() {
          data = {};
          size = 0;
          lruHash = {};
          freshEnd = staleEnd = null;
        },


        destroy: function() {
          data = null;
          stats = null;
          lruHash = null;
          delete caches[cacheId];
        },


        info: function() {
          return extend({}, stats, {size: size});
        }
      };


      /**
       * makes the &#x60;entry&#x60; the freshEnd of the LRU linked list
       */
      function refresh(entry) {
        if (entry != freshEnd) {
          if (!staleEnd) {
            staleEnd = entry;
          } else if (staleEnd == entry) {
            staleEnd = entry.n;
          }

          link(entry.n, entry.p);
          link(entry, freshEnd);
          freshEnd = entry;
          freshEnd.n = null;
        }
      }


      /**
       * bidirectionally links two entries of the LRU linked list
       */
      function link(nextEntry, prevEntry) {
        if (nextEntry != prevEntry) {
          if (nextEntry) nextEntry.p = prevEntry; //p stands for previous, &#x27;prev&#x27; didn&#x27;t minify
          if (prevEntry) prevEntry.n = nextEntry; //n stands for next, &#x27;next&#x27; didn&#x27;t minify
        }
      }
    }


    cacheFactory.info = function() {
      var info = {};
      forEach(caches, function(cache, cacheId) {
        info[cacheId] = cache.info();
      });
      return info;
    };


    cacheFactory.get = function(cacheId) {
      return caches[cacheId];
    };


    return cacheFactory;
  };
}

/**
 * @ngdoc object
 * @name ng.$templateCache
 *
 * @description
 * Cache used for storing html templates.
 *
 * See {@link ng.$cacheFactory $cacheFactory}.
 *
 */
function $TemplateCacheProvider() {
  this.$get = [&#x27;$cacheFactory&#x27;, function($cacheFactory) {
    return $cacheFactory(&#x27;templates&#x27;);
  }];
}

/* ! VARIABLE/FUNCTION NAMING CONVENTIONS THAT APPLY TO THIS FILE!
 *
 * DOM-related variables:
 *
 * - &quot;node&quot; - DOM Node
 * - &quot;element&quot; - DOM Element or Node
 * - &quot;$node&quot; or &quot;$element&quot; - jqLite-wrapped node or element
 *
 *
 * Compiler related stuff:
 *
 * - &quot;linkFn&quot; - linking fn of a single directive
 * - &quot;nodeLinkFn&quot; - function that aggregates all linking fns for a particular node
 * - &quot;childLinkFn&quot; -  function that aggregates all linking fns for child nodes of a particular node
 * - &quot;compositeLinkFn&quot; - function that aggregates all linking fns for a compilation root (nodeList)
 */


var NON_ASSIGNABLE_MODEL_EXPRESSION = &#x27;Non-assignable model expression: &#x27;;


/**
 * @ngdoc function
 * @name ng.$compile
 * @function
 *
 * @description
 * Compiles a piece of HTML string or DOM into a template and produces a template function, which
 * can then be used to link {@link ng.$rootScope.Scope scope} and the template together.
 *
 * The compilation is a process of walking the DOM tree and trying to match DOM elements to
 * {@link ng.$compileProvider#directive directives}. For each match it
 * executes corresponding template function and collects the
 * instance functions into a single template function which is then returned.
 *
 * The template function can then be used once to produce the view or as it is the case with
 * {@link ng.directive:ngRepeat repeater} many-times, in which
 * case each call results in a view that is a DOM clone of the original template.
 *
 &lt;doc:example module=&quot;compile&quot;&gt;
   &lt;doc:source&gt;
    &lt;script&gt;
      // declare a new module, and inject the $compileProvider
      angular.module(&#x27;compile&#x27;, [], function($compileProvider) {
        // configure new &#x27;compile&#x27; directive by passing a directive
        // factory function. The factory function injects the &#x27;$compile&#x27;
        $compileProvider.directive(&#x27;compile&#x27;, function($compile) {
          // directive factory creates a link function
          return function(scope, element, attrs) {
            scope.$watch(
              function(scope) {
                 // watch the &#x27;compile&#x27; expression for changes
                return scope.$eval(attrs.compile);
              },
              function(value) {
                // when the &#x27;compile&#x27; expression changes
                // assign it into the current DOM
                element.html(value);

                // compile the new DOM and link it to the current
                // scope.
                // NOTE: we only compile .childNodes so that
                // we don&#x27;t get into infinite loop compiling ourselves
                $compile(element.contents())(scope);
              }
            );
          };
        })
      });

      function Ctrl($scope) {
        $scope.name = &#x27;Angular&#x27;;
        $scope.html = &#x27;Hello {{name}}&#x27;;
      }
    &lt;/script&gt;
    &lt;div ng-controller=&quot;Ctrl&quot;&gt;
      &lt;input ng-model=&quot;name&quot;&gt; &lt;br&gt;
      &lt;textarea ng-model=&quot;html&quot;&gt;&lt;/textarea&gt; &lt;br&gt;
      &lt;div compile=&quot;html&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
   &lt;/doc:source&gt;
   &lt;doc:scenario&gt;
     it(&#x27;should auto compile&#x27;, function() {
       expect(element(&#x27;div[compile]&#x27;).text()).toBe(&#x27;Hello Angular&#x27;);
       input(&#x27;html&#x27;).enter(&#x27;{{name}}!&#x27;);
       expect(element(&#x27;div[compile]&#x27;).text()).toBe(&#x27;Angular!&#x27;);
     });
   &lt;/doc:scenario&gt;
 &lt;/doc:example&gt;

 *
 *
 * @param {string|DOMElement} element Element or HTML string to compile into a template function.
 * @param {function(angular.Scope[, cloneAttachFn]} transclude function available to directives.
 * @param {number} maxPriority only apply directives lower then given priority (Only effects the
 *                 root element(s), not their children)
 * @returns {function(scope[, cloneAttachFn])} a link function which is used to bind template
 * (a DOM element/tree) to a scope. Where:
 *
 *  * &#x60;scope&#x60; - A {@link ng.$rootScope.Scope Scope} to bind to.
 *  * &#x60;cloneAttachFn&#x60; - If &#x60;cloneAttachFn&#x60; is provided, then the link function will clone the
 *               &#x60;template&#x60; and call the &#x60;cloneAttachFn&#x60; function allowing the caller to attach the
 *               cloned elements to the DOM document at the appropriate place. The &#x60;cloneAttachFn&#x60; is
 *               called as: &lt;br&gt; &#x60;cloneAttachFn(clonedElement, scope)&#x60; where:
 *
 *      * &#x60;clonedElement&#x60; - is a clone of the original &#x60;element&#x60; passed into the compiler.
 *      * &#x60;scope&#x60; - is the current scope with which the linking function is working with.
 *
 * Calling the linking function returns the element of the template. It is either the original element
 * passed in, or the clone of the element if the &#x60;cloneAttachFn&#x60; is provided.
 *
 * After linking the view is not updated until after a call to $digest which typically is done by
 * Angular automatically.
 *
 * If you need access to the bound view, there are two ways to do it:
 *
 * - If you are not asking the linking function to clone the template, create the DOM element(s)
 *   before you send them to the compiler and keep this reference around.
 *   &lt;pre&gt;
 *     var element = $compile(&#x27;&lt;p&gt;{{total}}&lt;/p&gt;&#x27;)(scope);
 *   &lt;/pre&gt;
 *
 * - if on the other hand, you need the element to be cloned, the view reference from the original
 *   example would not point to the clone, but rather to the original template that was cloned. In
 *   this case, you can access the clone via the cloneAttachFn:
 *   &lt;pre&gt;
 *     var templateHTML = angular.element(&#x27;&lt;p&gt;{{total}}&lt;/p&gt;&#x27;),
 *         scope = ....;
 *
 *     var clonedElement = $compile(templateHTML)(scope, function(clonedElement, scope) {
 *       //attach the clone to DOM document at the right place
 *     });
 *
 *     //now we have reference to the cloned DOM via &#x60;clone&#x60;
 *   &lt;/pre&gt;
 *
 *
 * For information on how the compiler works, see the
 * {@link guide/compiler Angular HTML Compiler} section of the Developer Guide.
 */


/**
 * @ngdoc service
 * @name ng.$compileProvider
 * @function
 *
 * @description
 */
$CompileProvider.$inject = [&#x27;$provide&#x27;];
function $CompileProvider($provide) {
  var hasDirectives = {},
      Suffix = &#x27;Directive&#x27;,
      COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\d\w\-_]+)\s+(.*)$/,
      CLASS_DIRECTIVE_REGEXP = /(([\d\w\-_]+)(?:\:([^;]+))?;?)/,
      MULTI_ROOT_TEMPLATE_ERROR = &#x27;Template must have exactly one root element. was: &#x27;,
      urlSanitizationWhitelist = /^\s*(https?|ftp|mailto|file):/;


  /**
   * @ngdoc function
   * @name ng.$compileProvider#directive
   * @methodOf ng.$compileProvider
   * @function
   *
   * @description
   * Register a new directives with the compiler.
   *
   * @param {string} name Name of the directive in camel-case. (ie &lt;code&gt;ngBind&lt;/code&gt; which will match as
   *                &lt;code&gt;ng-bind&lt;/code&gt;).
   * @param {function} directiveFactory An injectable directive factory function. See {@link guide/directive} for more
   *                info.
   * @returns {ng.$compileProvider} Self for chaining.
   */
   this.directive = function registerDirective(name, directiveFactory) {
    if (isString(name)) {
      assertArg(directiveFactory, &#x27;directive&#x27;);
      if (!hasDirectives.hasOwnProperty(name)) {
        hasDirectives[name] = [];
        $provide.factory(name + Suffix, [&#x27;$injector&#x27;, &#x27;$exceptionHandler&#x27;,
          function($injector, $exceptionHandler) {
            var directives = [];
            forEach(hasDirectives[name], function(directiveFactory) {
              try {
                var directive = $injector.invoke(directiveFactory);
                if (isFunction(directive)) {
                  directive = { compile: valueFn(directive) };
                } else if (!directive.compile &amp;&amp; directive.link) {
                  directive.compile = valueFn(directive.link);
                }
                directive.priority = directive.priority || 0;
                directive.name = directive.name || name;
                directive.require = directive.require || (directive.controller &amp;&amp; directive.name);
                directive.restrict = directive.restrict || &#x27;A&#x27;;
                directives.push(directive);
              } catch (e) {
                $exceptionHandler(e);
              }
            });
            return directives;
          }]);
      }
      hasDirectives[name].push(directiveFactory);
    } else {
      forEach(name, reverseParams(registerDirective));
    }
    return this;
  };


  /**
   * @ngdoc function
   * @name ng.$compileProvider#urlSanitizationWhitelist
   * @methodOf ng.$compileProvider
   * @function
   *
   * @description
   * Retrieves or overrides the default regular expression that is used for whitelisting of safe
   * urls during a[href] sanitization.
   *
   * The sanitization is a security measure aimed at prevent XSS attacks via html links.
   *
   * Any url about to be assigned to a[href] via data-binding is first normalized and turned into an
   * absolute url. Afterwards the url is matched against the &#x60;urlSanitizationWhitelist&#x60; regular
   * expression. If a match is found the original url is written into the dom. Otherwise the
   * absolute url is prefixed with &#x60;&#x27;unsafe:&#x27;&#x60; string and only then it is written into the DOM.
   *
   * @param {RegExp=} regexp New regexp to whitelist urls with.
   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for
   *    chaining otherwise.
   */
  this.urlSanitizationWhitelist = function(regexp) {
    if (isDefined(regexp)) {
      urlSanitizationWhitelist = regexp;
      return this;
    }
    return urlSanitizationWhitelist;
  };


  this.$get = [
            &#x27;$injector&#x27;, &#x27;$interpolate&#x27;, &#x27;$exceptionHandler&#x27;, &#x27;$http&#x27;, &#x27;$templateCache&#x27;, &#x27;$parse&#x27;,
            &#x27;$controller&#x27;, &#x27;$rootScope&#x27;, &#x27;$document&#x27;,
    function($injector,   $interpolate,   $exceptionHandler,   $http,   $templateCache,   $parse,
             $controller,   $rootScope,   $document) {

    var Attributes = function(element, attr) {
      this.$$element = element;
      this.$attr = attr || {};
    };

    Attributes.prototype = {
      $normalize: directiveNormalize,


      /**
       * Set a normalized attribute on the element in a way such that all directives
       * can share the attribute. This function properly handles boolean attributes.
       * @param {string} key Normalized key. (ie ngAttribute)
       * @param {string|boolean} value The value to set. If &#x60;null&#x60; attribute will be deleted.
       * @param {boolean=} writeAttr If false, does not write the value to DOM element attribute.
       *     Defaults to true.
       * @param {string=} attrName Optional none normalized name. Defaults to key.
       */
      $set: function(key, value, writeAttr, attrName) {
        var booleanKey = getBooleanAttrName(this.$$element[0], key),
            $$observers = this.$$observers,
            normalizedVal;

        if (booleanKey) {
          this.$$element.prop(key, value);
          attrName = booleanKey;
        }

        this[key] = value;

        // translate normalized key to actual key
        if (attrName) {
          this.$attr[key] = attrName;
        } else {
          attrName = this.$attr[key];
          if (!attrName) {
            this.$attr[key] = attrName = snake_case(key, &#x27;-&#x27;);
          }
        }


        // sanitize a[href] values
        if (nodeName_(this.$$element[0]) === &#x27;A&#x27; &amp;&amp; key === &#x27;href&#x27;) {
          urlSanitizationNode.setAttribute(&#x27;href&#x27;, value);

          // href property always returns normalized absolute url, so we can match against that
          normalizedVal = urlSanitizationNode.href;
          if (!normalizedVal.match(urlSanitizationWhitelist)) {
            this[key] = value = &#x27;unsafe:&#x27; + normalizedVal;
          }
        }


        if (writeAttr !== false) {
          if (value === null || value === undefined) {
            this.$$element.removeAttr(attrName);
          } else {
            this.$$element.attr(attrName, value);
          }
        }

        // fire observers
        $$observers &amp;&amp; forEach($$observers[key], function(fn) {
          try {
            fn(value);
          } catch (e) {
            $exceptionHandler(e);
          }
        });
      },


      /**
       * Observe an interpolated attribute.
       * The observer will never be called, if given attribute is not interpolated.
       *
       * @param {string} key Normalized key. (ie ngAttribute) .
       * @param {function(*)} fn Function that will be called whenever the attribute value changes.
       * @returns {function(*)} the &#x60;fn&#x60; Function passed in.
       */
      $observe: function(key, fn) {
        var attrs = this,
            $$observers = (attrs.$$observers || (attrs.$$observers = {})),
            listeners = ($$observers[key] || ($$observers[key] = []));

        listeners.push(fn);
        $rootScope.$evalAsync(function() {
          if (!listeners.$$inter) {
            // no one registered attribute interpolation function, so lets call it manually
            fn(attrs[key]);
          }
        });
        return fn;
      }
    };

    var urlSanitizationNode = $document[0].createElement(&#x27;a&#x27;),
        startSymbol = $interpolate.startSymbol(),
        endSymbol = $interpolate.endSymbol(),
        denormalizeTemplate = (startSymbol == &#x27;{{&#x27; || endSymbol  == &#x27;}}&#x27;)
            ? identity
            : function denormalizeTemplate(template) {
              return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
        },
        NG_ATTR_BINDING = /^ngAttr[A-Z]/;


    return compile;

    //================================

    function compile($compileNodes, transcludeFn, maxPriority) {
      if (!($compileNodes instanceof jqLite)) {
        // jquery always rewraps, whereas we need to preserve the original selector so that we can modify it.
        $compileNodes = jqLite($compileNodes);
      }
      // We can not compile top level text elements since text nodes can be merged and we will
      // not be able to attach scope data to them, so we will wrap them in &lt;span&gt;
      forEach($compileNodes, function(node, index){
        if (node.nodeType == 3 /* text node */ &amp;&amp; node.nodeValue.match(/\S+/) /* non-empty */ ) {
          $compileNodes[index] = jqLite(node).wrap(&#x27;&lt;span&gt;&lt;/span&gt;&#x27;).parent()[0];
        }
      });
      var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority);
      return function publicLinkFn(scope, cloneConnectFn){
        assertArg(scope, &#x27;scope&#x27;);
        // important!!: we must call our jqLite.clone() since the jQuery one is trying to be smart
        // and sometimes changes the structure of the DOM.
        var $linkNode = cloneConnectFn
          ? JQLitePrototype.clone.call($compileNodes) // IMPORTANT!!!
          : $compileNodes;

        // Attach scope only to non-text nodes.
        for(var i = 0, ii = $linkNode.length; i&lt;ii; i++) {
          var node = $linkNode[i];
          if (node.nodeType == 1 /* element */ || node.nodeType == 9 /* document */) {
            $linkNode.eq(i).data(&#x27;$scope&#x27;, scope);
          }
        }
        safeAddClass($linkNode, &#x27;ng-scope&#x27;);
        if (cloneConnectFn) cloneConnectFn($linkNode, scope);
        if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode);
        return $linkNode;
      };
    }

    function wrongMode(localName, mode) {
      throw Error(&quot;Unsupported &#x27;&quot; + mode + &quot;&#x27; for &#x27;&quot; + localName + &quot;&#x27;.&quot;);
    }

    function safeAddClass($element, className) {
      try {
        $element.addClass(className);
      } catch(e) {
        // ignore, since it means that we are trying to set class on
        // SVG element, where class name is read-only.
      }
    }

    /**
     * Compile function matches each node in nodeList against the directives. Once all directives
     * for a particular node are collected their compile functions are executed. The compile
     * functions return values - the linking functions - are combined into a composite linking
     * function, which is the a linking function for the node.
     *
     * @param {NodeList} nodeList an array of nodes or NodeList to compile
     * @param {function(angular.Scope[, cloneAttachFn]} transcludeFn A linking function, where the
     *        scope argument is auto-generated to the new child of the transcluded parent scope.
     * @param {DOMElement=} $rootElement If the nodeList is the root of the compilation tree then the
     *        rootElement must be set the jqLite collection of the compile root. This is
     *        needed so that the jqLite collection items can be replaced with widgets.
     * @param {number=} max directive priority
     * @returns {?function} A composite linking function of all of the matched directives or null.
     */
    function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority) {
      var linkFns = [],
          nodeLinkFn, childLinkFn, directives, attrs, linkFnFound;

      for(var i = 0; i &lt; nodeList.length; i++) {
        attrs = new Attributes();

        // we must always refer to nodeList[i] since the nodes can be replaced underneath us.
        directives = collectDirectives(nodeList[i], [], attrs, maxPriority);

        nodeLinkFn = (directives.length)
            ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement)
            : null;

        childLinkFn = (nodeLinkFn &amp;&amp; nodeLinkFn.terminal || !nodeList[i].childNodes || !nodeList[i].childNodes.length)
            ? null
            : compileNodes(nodeList[i].childNodes,
                 nodeLinkFn ? nodeLinkFn.transclude : transcludeFn);

        linkFns.push(nodeLinkFn);
        linkFns.push(childLinkFn);
        linkFnFound = (linkFnFound || nodeLinkFn || childLinkFn);
      }

      // return a linking function if we have found anything, null otherwise
      return linkFnFound ? compositeLinkFn : null;

      function compositeLinkFn(scope, nodeList, $rootElement, boundTranscludeFn) {
        var nodeLinkFn, childLinkFn, node, childScope, childTranscludeFn, i, ii, n;

        // copy nodeList so that linking doesn&#x27;t break due to live list updates.
        var stableNodeList = [];
        for (i = 0, ii = nodeList.length; i &lt; ii; i++) {
          stableNodeList.push(nodeList[i]);
        }

        for(i = 0, n = 0, ii = linkFns.length; i &lt; ii; n++) {
          node = stableNodeList[n];
          nodeLinkFn = linkFns[i++];
          childLinkFn = linkFns[i++];

          if (nodeLinkFn) {
            if (nodeLinkFn.scope) {
              childScope = scope.$new(isObject(nodeLinkFn.scope));
              jqLite(node).data(&#x27;$scope&#x27;, childScope);
            } else {
              childScope = scope;
            }
            childTranscludeFn = nodeLinkFn.transclude;
            if (childTranscludeFn || (!boundTranscludeFn &amp;&amp; transcludeFn)) {
              nodeLinkFn(childLinkFn, childScope, node, $rootElement,
                  (function(transcludeFn) {
                    return function(cloneFn) {
                      var transcludeScope = scope.$new();
                      transcludeScope.$$transcluded = true;

                      return transcludeFn(transcludeScope, cloneFn).
                          bind(&#x27;$destroy&#x27;, bind(transcludeScope, transcludeScope.$destroy));
                    };
                  })(childTranscludeFn || transcludeFn)
              );
            } else {
              nodeLinkFn(childLinkFn, childScope, node, undefined, boundTranscludeFn);
            }
          } else if (childLinkFn) {
            childLinkFn(scope, node.childNodes, undefined, boundTranscludeFn);
          }
        }
      }
    }


    /**
     * Looks for directives on the given node and adds them to the directive collection which is
     * sorted.
     *
     * @param node Node to search.
     * @param directives An array to which the directives are added to. This array is sorted before
     *        the function returns.
     * @param attrs The shared attrs object which is used to populate the normalized attributes.
     * @param {number=} maxPriority Max directive priority.
     */
    function collectDirectives(node, directives, attrs, maxPriority) {
      var nodeType = node.nodeType,
          attrsMap = attrs.$attr,
          match,
          className;

      switch(nodeType) {
        case 1: /* Element */
          // use the node name: &lt;directive&gt;
          addDirective(directives,
              directiveNormalize(nodeName_(node).toLowerCase()), &#x27;E&#x27;, maxPriority);

          // iterate over the attributes
          for (var attr, name, nName, ngAttrName, value, nAttrs = node.attributes,
                   j = 0, jj = nAttrs &amp;&amp; nAttrs.length; j &lt; jj; j++) {
            attr = nAttrs[j];
            if (attr.specified) {
              name = attr.name;
              // support ngAttr attribute binding
              ngAttrName = directiveNormalize(name);
              if (NG_ATTR_BINDING.test(ngAttrName)) {
                name = ngAttrName.substr(6).toLowerCase();
              }
              nName = directiveNormalize(name.toLowerCase());
              attrsMap[nName] = name;
              attrs[nName] = value = trim((msie &amp;&amp; name == &#x27;href&#x27;)
                ? decodeURIComponent(node.getAttribute(name, 2))
                : attr.value);
              if (getBooleanAttrName(node, nName)) {
                attrs[nName] = true; // presence means true
              }
              addAttrInterpolateDirective(node, directives, value, nName);
              addDirective(directives, nName, &#x27;A&#x27;, maxPriority);
            }
          }

          // use class as directive
          className = node.className;
          if (isString(className) &amp;&amp; className !== &#x27;&#x27;) {
            while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
              nName = directiveNormalize(match[2]);
              if (addDirective(directives, nName, &#x27;C&#x27;, maxPriority)) {
                attrs[nName] = trim(match[3]);
              }
              className = className.substr(match.index + match[0].length);
            }
          }
          break;
        case 3: /* Text Node */
          addTextInterpolateDirective(directives, node.nodeValue);
          break;
        case 8: /* Comment */
          try {
            match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
            if (match) {
              nName = directiveNormalize(match[1]);
              if (addDirective(directives, nName, &#x27;M&#x27;, maxPriority)) {
                attrs[nName] = trim(match[2]);
              }
            }
          } catch (e) {
            // turns out that under some circumstances IE9 throws errors when one attempts to read comment&#x27;s node value.
            // Just ignore it and continue. (Can&#x27;t seem to reproduce in test case.)
          }
          break;
      }

      directives.sort(byPriority);
      return directives;
    }


    /**
     * Once the directives have been collected, their compile functions are executed. This method
     * is responsible for inlining directive templates as well as terminating the application
     * of the directives if the terminal directive has been reached.
     *
     * @param {Array} directives Array of collected directives to execute their compile function.
     *        this needs to be pre-sorted by priority order.
     * @param {Node} compileNode The raw DOM node to apply the compile functions to
     * @param {Object} templateAttrs The shared attribute function
     * @param {function(angular.Scope[, cloneAttachFn]} transcludeFn A linking function, where the
     *        scope argument is auto-generated to the new child of the transcluded parent scope.
     * @param {JQLite} jqCollection If we are working on the root of the compile tree then this
     *        argument has the root jqLite array so that we can replace nodes on it.
     * @returns linkFn
     */
    function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection) {
      var terminalPriority = -Number.MAX_VALUE,
          preLinkFns = [],
          postLinkFns = [],
          newScopeDirective = null,
          newIsolateScopeDirective = null,
          templateDirective = null,
          $compileNode = templateAttrs.$$element = jqLite(compileNode),
          directive,
          directiveName,
          $template,
          transcludeDirective,
          childTranscludeFn = transcludeFn,
          controllerDirectives,
          linkFn,
          directiveValue;

      // executes all directives on the current element
      for(var i = 0, ii = directives.length; i &lt; ii; i++) {
        directive = directives[i];
        $template = undefined;

        if (terminalPriority &gt; directive.priority) {
          break; // prevent further processing of directives
        }

        if (directiveValue = directive.scope) {
          assertNoDuplicate(&#x27;isolated scope&#x27;, newIsolateScopeDirective, directive, $compileNode);
          if (isObject(directiveValue)) {
            safeAddClass($compileNode, &#x27;ng-isolate-scope&#x27;);
            newIsolateScopeDirective = directive;
          }
          safeAddClass($compileNode, &#x27;ng-scope&#x27;);
          newScopeDirective = newScopeDirective || directive;
        }

        directiveName = directive.name;

        if (directiveValue = directive.controller) {
          controllerDirectives = controllerDirectives || {};
          assertNoDuplicate(&quot;&#x27;&quot; + directiveName + &quot;&#x27; controller&quot;,
              controllerDirectives[directiveName], directive, $compileNode);
          controllerDirectives[directiveName] = directive;
        }

        if (directiveValue = directive.transclude) {
          assertNoDuplicate(&#x27;transclusion&#x27;, transcludeDirective, directive, $compileNode);
          transcludeDirective = directive;
          terminalPriority = directive.priority;
          if (directiveValue == &#x27;element&#x27;) {
            $template = jqLite(compileNode);
            $compileNode = templateAttrs.$$element =
                jqLite(document.createComment(&#x27; &#x27; + directiveName + &#x27;: &#x27; + templateAttrs[directiveName] + &#x27; &#x27;));
            compileNode = $compileNode[0];
            replaceWith(jqCollection, jqLite($template[0]), compileNode);
            childTranscludeFn = compile($template, transcludeFn, terminalPriority);
          } else {
            $template = jqLite(JQLiteClone(compileNode)).contents();
            $compileNode.html(&#x27;&#x27;); // clear contents
            childTranscludeFn = compile($template, transcludeFn);
          }
        }

        if (directive.template) {
          assertNoDuplicate(&#x27;template&#x27;, templateDirective, directive, $compileNode);
          templateDirective = directive;

          directiveValue = (isFunction(directive.template))
              ? directive.template($compileNode, templateAttrs)
              : directive.template;

          directiveValue = denormalizeTemplate(directiveValue);

          if (directive.replace) {
            $template = jqLite(&#x27;&lt;div&gt;&#x27; +
                                 trim(directiveValue) +
                               &#x27;&lt;/div&gt;&#x27;).contents();
            compileNode = $template[0];

            if ($template.length != 1 || compileNode.nodeType !== 1) {
              throw new Error(MULTI_ROOT_TEMPLATE_ERROR + directiveValue);
            }

            replaceWith(jqCollection, $compileNode, compileNode);

            var newTemplateAttrs = {$attr: {}};

            // combine directives from the original node and from the template:
            // - take the array of directives for this element
            // - split it into two parts, those that were already applied and those that weren&#x27;t
            // - collect directives from the template, add them to the second group and sort them
            // - append the second group with new directives to the first group
            directives = directives.concat(
                collectDirectives(
                    compileNode,
                    directives.splice(i + 1, directives.length - (i + 1)),
                    newTemplateAttrs
                )
            );
            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);

            ii = directives.length;
          } else {
            $compileNode.html(directiveValue);
          }
        }

        if (directive.templateUrl) {
          assertNoDuplicate(&#x27;template&#x27;, templateDirective, directive, $compileNode);
          templateDirective = directive;
          nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i),
              nodeLinkFn, $compileNode, templateAttrs, jqCollection, directive.replace,
              childTranscludeFn);
          ii = directives.length;
        } else if (directive.compile) {
          try {
            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
            if (isFunction(linkFn)) {
              addLinkFns(null, linkFn);
            } else if (linkFn) {
              addLinkFns(linkFn.pre, linkFn.post);
            }
          } catch (e) {
            $exceptionHandler(e, startingTag($compileNode));
          }
        }

        if (directive.terminal) {
          nodeLinkFn.terminal = true;
          terminalPriority = Math.max(terminalPriority, directive.priority);
        }

      }

      nodeLinkFn.scope = newScopeDirective &amp;&amp; newScopeDirective.scope;
      nodeLinkFn.transclude = transcludeDirective &amp;&amp; childTranscludeFn;

      // might be normal or delayed nodeLinkFn depending on if templateUrl is present
      return nodeLinkFn;

      ////////////////////

      function addLinkFns(pre, post) {
        if (pre) {
          pre.require = directive.require;
          preLinkFns.push(pre);
        }
        if (post) {
          post.require = directive.require;
          postLinkFns.push(post);
        }
      }


      function getControllers(require, $element) {
        var value, retrievalMethod = &#x27;data&#x27;, optional = false;
        if (isString(require)) {
          while((value = require.charAt(0)) == &#x27;^&#x27; || value == &#x27;?&#x27;) {
            require = require.substr(1);
            if (value == &#x27;^&#x27;) {
              retrievalMethod = &#x27;inheritedData&#x27;;
            }
            optional = optional || value == &#x27;?&#x27;;
          }
          value = $element[retrievalMethod](&#x27;$&#x27; + require + &#x27;Controller&#x27;);
          if (!value &amp;&amp; !optional) {
            throw Error(&quot;No controller: &quot; + require);
          }
          return value;
        } else if (isArray(require)) {
          value = [];
          forEach(require, function(require) {
            value.push(getControllers(require, $element));
          });
        }
        return value;
      }


      function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
        var attrs, $element, i, ii, linkFn, controller;

        if (compileNode === linkNode) {
          attrs = templateAttrs;
        } else {
          attrs = shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr));
        }
        $element = attrs.$$element;

        if (newIsolateScopeDirective) {
          var LOCAL_REGEXP = /^\s*([@=&amp;])(\??)\s*(\w*)\s*$/;

          var parentScope = scope.$parent || scope;

          forEach(newIsolateScopeDirective.scope, function(definiton, scopeName) {
            var match = definiton.match(LOCAL_REGEXP) || [],
                attrName = match[3] || scopeName,
                optional = (match[2] == &#x27;?&#x27;),
                mode = match[1], // @, =, or &amp;
                lastValue,
                parentGet, parentSet;

            scope.$$isolateBindings[scopeName] = mode + attrName;

            switch (mode) {

              case &#x27;@&#x27;: {
                attrs.$observe(attrName, function(value) {
                  scope[scopeName] = value;
                });
                attrs.$$observers[attrName].$$scope = parentScope;
                if( attrs[attrName] ) {
                  // If the attribute has been provided then we trigger an interpolation to ensure the value is there for use in the link fn
                  scope[scopeName] = $interpolate(attrs[attrName])(parentScope);
                }
                break;
              }

              case &#x27;=&#x27;: {
                if (optional &amp;&amp; !attrs[attrName]) {
                  return;
                }
                parentGet = $parse(attrs[attrName]);
                parentSet = parentGet.assign || function() {
                  // reset the change, or we will throw this exception on every $digest
                  lastValue = scope[scopeName] = parentGet(parentScope);
                  throw Error(NON_ASSIGNABLE_MODEL_EXPRESSION + attrs[attrName] +
                      &#x27; (directive: &#x27; + newIsolateScopeDirective.name + &#x27;)&#x27;);
                };
                lastValue = scope[scopeName] = parentGet(parentScope);
                scope.$watch(function parentValueWatch() {
                  var parentValue = parentGet(parentScope);

                  if (parentValue !== scope[scopeName]) {
                    // we are out of sync and need to copy
                    if (parentValue !== lastValue) {
                      // parent changed and it has precedence
                      lastValue = scope[scopeName] = parentValue;
                    } else {
                      // if the parent can be assigned then do so
                      parentSet(parentScope, parentValue = lastValue = scope[scopeName]);
                    }
                  }
                  return parentValue;
                });
                break;
              }

              case &#x27;&amp;&#x27;: {
                parentGet = $parse(attrs[attrName]);
                scope[scopeName] = function(locals) {
                  return parentGet(parentScope, locals);
                };
                break;
              }

              default: {
                throw Error(&#x27;Invalid isolate scope definition for directive &#x27; +
                    newIsolateScopeDirective.name + &#x27;: &#x27; + definiton);
              }
            }
          });
        }

        if (controllerDirectives) {
          forEach(controllerDirectives, function(directive) {
            var locals = {
              $scope: scope,
              $element: $element,
              $attrs: attrs,
              $transclude: boundTranscludeFn
            };

            controller = directive.controller;
            if (controller == &#x27;@&#x27;) {
              controller = attrs[directive.name];
            }

            $element.data(
                &#x27;$&#x27; + directive.name + &#x27;Controller&#x27;,
                $controller(controller, locals));
          });
        }

        // PRELINKING
        for(i = 0, ii = preLinkFns.length; i &lt; ii; i++) {
          try {
            linkFn = preLinkFns[i];
            linkFn(scope, $element, attrs,
                linkFn.require &amp;&amp; getControllers(linkFn.require, $element));
          } catch (e) {
            $exceptionHandler(e, startingTag($element));
          }
        }

        // RECURSION
        childLinkFn &amp;&amp; childLinkFn(scope, linkNode.childNodes, undefined, boundTranscludeFn);

        // POSTLINKING
        for(i = 0, ii = postLinkFns.length; i &lt; ii; i++) {
          try {
            linkFn = postLinkFns[i];
            linkFn(scope, $element, attrs,
                linkFn.require &amp;&amp; getControllers(linkFn.require, $element));
          } catch (e) {
            $exceptionHandler(e, startingTag($element));
          }
        }
      }
    }


    /**
     * looks up the directive and decorates it with exception handling and proper parameters. We
     * call this the boundDirective.
     *
     * @param {string} name name of the directive to look up.
     * @param {string} location The directive must be found in specific format.
     *   String containing any of theses characters:
     *
     *   * &#x60;E&#x60;: element name
     *   * &#x60;A&#x27;: attribute
     *   * &#x60;C&#x60;: class
     *   * &#x60;M&#x60;: comment
     * @returns true if directive was added.
     */
    function addDirective(tDirectives, name, location, maxPriority) {
      var match = false;
      if (hasDirectives.hasOwnProperty(name)) {
        for(var directive, directives = $injector.get(name + Suffix),
            i = 0, ii = directives.length; i&lt;ii; i++) {
          try {
            directive = directives[i];
            if ( (maxPriority === undefined || maxPriority &gt; directive.priority) &amp;&amp;
                 directive.restrict.indexOf(location) != -1) {
              tDirectives.push(directive);
              match = true;
            }
          } catch(e) { $exceptionHandler(e); }
        }
      }
      return match;
    }


    /**
     * When the element is replaced with HTML template then the new attributes
     * on the template need to be merged with the existing attributes in the DOM.
     * The desired effect is to have both of the attributes present.
     *
     * @param {object} dst destination attributes (original DOM)
     * @param {object} src source attributes (from the directive template)
     */
    function mergeTemplateAttributes(dst, src) {
      var srcAttr = src.$attr,
          dstAttr = dst.$attr,
          $element = dst.$$element;

      // reapply the old attributes to the new element
      forEach(dst, function(value, key) {
        if (key.charAt(0) != &#x27;$&#x27;) {
          if (src[key]) {
            value += (key === &#x27;style&#x27; ? &#x27;;&#x27; : &#x27; &#x27;) + src[key];
          }
          dst.$set(key, value, true, srcAttr[key]);
        }
      });

      // copy the new attributes on the old attrs object
      forEach(src, function(value, key) {
        if (key == &#x27;class&#x27;) {
          safeAddClass($element, value);
          dst[&#x27;class&#x27;] = (dst[&#x27;class&#x27;] ? dst[&#x27;class&#x27;] + &#x27; &#x27; : &#x27;&#x27;) + value;
        } else if (key == &#x27;style&#x27;) {
          $element.attr(&#x27;style&#x27;, $element.attr(&#x27;style&#x27;) + &#x27;;&#x27; + value);
        } else if (key.charAt(0) != &#x27;$&#x27; &amp;&amp; !dst.hasOwnProperty(key)) {
          dst[key] = value;
          dstAttr[key] = srcAttr[key];
        }
      });
    }


    function compileTemplateUrl(directives, beforeTemplateNodeLinkFn, $compileNode, tAttrs,
        $rootElement, replace, childTranscludeFn) {
      var linkQueue = [],
          afterTemplateNodeLinkFn,
          afterTemplateChildLinkFn,
          beforeTemplateCompileNode = $compileNode[0],
          origAsyncDirective = directives.shift(),
          // The fact that we have to copy and patch the directive seems wrong!
          derivedSyncDirective = extend({}, origAsyncDirective, {
            controller: null, templateUrl: null, transclude: null, scope: null
          }),
          templateUrl = (isFunction(origAsyncDirective.templateUrl))
              ? origAsyncDirective.templateUrl($compileNode, tAttrs)
              : origAsyncDirective.templateUrl;

      $compileNode.html(&#x27;&#x27;);

      $http.get(templateUrl, {cache: $templateCache}).
        success(function(content) {
          var compileNode, tempTemplateAttrs, $template;

          content = denormalizeTemplate(content);

          if (replace) {
            $template = jqLite(&#x27;&lt;div&gt;&#x27; + trim(content) + &#x27;&lt;/div&gt;&#x27;).contents();
            compileNode = $template[0];

            if ($template.length != 1 || compileNode.nodeType !== 1) {
              throw new Error(MULTI_ROOT_TEMPLATE_ERROR + content);
            }

            tempTemplateAttrs = {$attr: {}};
            replaceWith($rootElement, $compileNode, compileNode);
            collectDirectives(compileNode, directives, tempTemplateAttrs);
            mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
          } else {
            compileNode = beforeTemplateCompileNode;
            $compileNode.html(content);
          }

          directives.unshift(derivedSyncDirective);
          afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn);
          afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);


          while(linkQueue.length) {
            var scope = linkQueue.shift(),
                beforeTemplateLinkNode = linkQueue.shift(),
                linkRootElement = linkQueue.shift(),
                controller = linkQueue.shift(),
                linkNode = compileNode;

            if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
              // it was cloned therefore we have to clone as well.
              linkNode = JQLiteClone(compileNode);
              replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
            }

            afterTemplateNodeLinkFn(function() {
              beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, controller);
            }, scope, linkNode, $rootElement, controller);
          }
          linkQueue = null;
        }).
        error(function(response, code, headers, config) {
          throw Error(&#x27;Failed to load template: &#x27; + config.url);
        });

      return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, controller) {
        if (linkQueue) {
          linkQueue.push(scope);
          linkQueue.push(node);
          linkQueue.push(rootElement);
          linkQueue.push(controller);
        } else {
          afterTemplateNodeLinkFn(function() {
            beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, controller);
          }, scope, node, rootElement, controller);
        }
      };
    }


    /**
     * Sorting function for bound directives.
     */
    function byPriority(a, b) {
      return b.priority - a.priority;
    }


    function assertNoDuplicate(what, previousDirective, directive, element) {
      if (previousDirective) {
        throw Error(&#x27;Multiple directives [&#x27; + previousDirective.name + &#x27;, &#x27; +
          directive.name + &#x27;] asking for &#x27; + what + &#x27; on: &#x27; +  startingTag(element));
      }
    }


    function addTextInterpolateDirective(directives, text) {
      var interpolateFn = $interpolate(text, true);
      if (interpolateFn) {
        directives.push({
          priority: 0,
          compile: valueFn(function textInterpolateLinkFn(scope, node) {
            var parent = node.parent(),
                bindings = parent.data(&#x27;$binding&#x27;) || [];
            bindings.push(interpolateFn);
            safeAddClass(parent.data(&#x27;$binding&#x27;, bindings), &#x27;ng-binding&#x27;);
            scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
              node[0].nodeValue = value;
            });
          })
        });
      }
    }


    function addAttrInterpolateDirective(node, directives, value, name) {
      var interpolateFn = $interpolate(value, true);

      // no interpolation found -&gt; ignore
      if (!interpolateFn) return;


      directives.push({
        priority: 100,
        compile: valueFn(function attrInterpolateLinkFn(scope, element, attr) {
          var $$observers = (attr.$$observers || (attr.$$observers = {}));

          // we need to interpolate again, in case the attribute value has been updated
          // (e.g. by another directive&#x27;s compile function)
          interpolateFn = $interpolate(attr[name], true);

          // if attribute was updated so that there is no interpolation going on we don&#x27;t want to
          // register any observers
          if (!interpolateFn) return;

          attr[name] = interpolateFn(scope);
          ($$observers[name] || ($$observers[name] = [])).$$inter = true;
          (attr.$$observers &amp;&amp; attr.$$observers[name].$$scope || scope).
            $watch(interpolateFn, function interpolateFnWatchAction(value) {
              attr.$set(name, value);
            });
        })
      });
    }


    /**
     * This is a special jqLite.replaceWith, which can replace items which
     * have no parents, provided that the containing jqLite collection is provided.
     *
     * @param {JqLite=} $rootElement The root of the compile tree. Used so that we can replace nodes
     *    in the root of the tree.
     * @param {JqLite} $element The jqLite element which we are going to replace. We keep the shell,
     *    but replace its DOM node reference.
     * @param {Node} newNode The new DOM node.
     */
    function replaceWith($rootElement, $element, newNode) {
      var oldNode = $element[0],
          parent = oldNode.parentNode,
          i, ii;

      if ($rootElement) {
        for(i = 0, ii = $rootElement.length; i &lt; ii; i++) {
          if ($rootElement[i] == oldNode) {
            $rootElement[i] = newNode;
            break;
          }
        }
      }

      if (parent) {
        parent.replaceChild(newNode, oldNode);
      }

      newNode[jqLite.expando] = oldNode[jqLite.expando];
      $element[0] = newNode;
    }
  }];
}

var PREFIX_REGEXP = /^(x[\:\-_]|data[\:\-_])/i;
/**
 * Converts all accepted directives format into proper directive name.
 * All of these will become &#x27;myDirective&#x27;:
 *   my:DiRective
 *   my-directive
 *   x-my-directive
 *   data-my:directive
 *
 * Also there is special case for Moz prefix starting with upper case letter.
 * @param name Name to normalize
 */
function directiveNormalize(name) {
  return camelCase(name.replace(PREFIX_REGEXP, &#x27;&#x27;));
}

/**
 * @ngdoc object
 * @name ng.$compile.directive.Attributes
 * @description
 *
 * A shared object between directive compile / linking functions which contains normalized DOM element
 * attributes. The the values reflect current binding state &#x60;{{ }}&#x60;. The normalization is needed
 * since all of these are treated as equivalent in Angular:
 *
 *          &lt;span ng:bind=&quot;a&quot; ng-bind=&quot;a&quot; data-ng-bind=&quot;a&quot; x-ng-bind=&quot;a&quot;&gt;
 */

/**
 * @ngdoc property
 * @name ng.$compile.directive.Attributes#$attr
 * @propertyOf ng.$compile.directive.Attributes
 * @returns {object} A map of DOM element attribute names to the normalized name. This is
 *          needed to do reverse lookup from normalized name back to actual name.
 */


/**
 * @ngdoc function
 * @name ng.$compile.directive.Attributes#$set
 * @methodOf ng.$compile.directive.Attributes
 * @function
 *
 * @description
 * Set DOM element attribute value.
 *
 *
 * @param {string} name Normalized element attribute name of the property to modify. The name is
 *          revers translated using the {@link ng.$compile.directive.Attributes#$attr $attr}
 *          property to the original name.
 * @param {string} value Value to set the attribute to. The value can be an interpolated string.
 */



/**
 * Closure compiler type information
 */

function nodesetLinkingFn(
  /* angular.Scope */ scope,
  /* NodeList */ nodeList,
  /* Element */ rootElement,
  /* function(Function) */ boundTranscludeFn
){}

function directiveLinkingFn(
  /* nodesetLinkingFn */ nodesetLinkingFn,
  /* angular.Scope */ scope,
  /* Node */ node,
  /* Element */ rootElement,
  /* function(Function) */ boundTranscludeFn
){}

/**
 * @ngdoc object
 * @name ng.$controllerProvider
 * @description
 * The {@link ng.$controller $controller service} is used by Angular to create new
 * controllers.
 *
 * This provider allows controller registration via the
 * {@link ng.$controllerProvider#register register} method.
 */
function $ControllerProvider() {
  var controllers = {},
      CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/;


  /**
   * @ngdoc function
   * @name ng.$controllerProvider#register
   * @methodOf ng.$controllerProvider
   * @param {string} name Controller name
   * @param {Function|Array} constructor Controller constructor fn (optionally decorated with DI
   *    annotations in the array notation).
   */
  this.register = function(name, constructor) {
    if (isObject(name)) {
      extend(controllers, name)
    } else {
      controllers[name] = constructor;
    }
  };


  this.$get = [&#x27;$injector&#x27;, &#x27;$window&#x27;, function($injector, $window) {

    /**
     * @ngdoc function
     * @name ng.$controller
     * @requires $injector
     *
     * @param {Function|string} constructor If called with a function then it&#x27;s considered to be the
     *    controller constructor function. Otherwise it&#x27;s considered to be a string which is used
     *    to retrieve the controller constructor using the following steps:
     *
     *    * check if a controller with given name is registered via &#x60;$controllerProvider&#x60;
     *    * check if evaluating the string on the current scope returns a constructor
     *    * check &#x60;window[constructor]&#x60; on the global &#x60;window&#x60; object
     *
     * @param {Object} locals Injection locals for Controller.
     * @return {Object} Instance of given controller.
     *
     * @description
     * &#x60;$controller&#x60; service is responsible for instantiating controllers.
     *
     * It&#x27;s just a simple call to {@link AUTO.$injector $injector}, but extracted into
     * a service, so that one can override this service with {@link https://gist.github.com/1649788
     * BC version}.
     */
    return function(expression, locals) {
      var instance, match, constructor, identifier;

      if(isString(expression)) {
        match = expression.match(CNTRL_REG),
        constructor = match[1],
        identifier = match[3];
        expression = controllers.hasOwnProperty(constructor)
            ? controllers[constructor]
            : getter(locals.$scope, constructor, true) || getter($window, constructor, true);

        assertArgFn(expression, constructor, true);
      }

      instance = $injector.instantiate(expression, locals);

      if (identifier) {
        if (typeof locals.$scope !== &#x27;object&#x27;) {
          throw new Error(&#x27;Can not export controller as &quot;&#x27; + identifier + &#x27;&quot;. &#x27; +
              &#x27;No scope object provided!&#x27;);
        }

        locals.$scope[identifier] = instance;
      }

      return instance;
    };
  }];
}

/**
 * @ngdoc object
 * @name ng.$document
 * @requires $window
 *
 * @description
 * A {@link angular.element jQuery (lite)}-wrapped reference to the browser&#x27;s &#x60;window.document&#x60;
 * element.
 */
function $DocumentProvider(){
  this.$get = [&#x27;$window&#x27;, function(window){
    return jqLite(window.document);
  }];
}

/**
 * @ngdoc function
 * @name ng.$exceptionHandler
 * @requires $log
 *
 * @description
 * Any uncaught exception in angular expressions is delegated to this service.
 * The default implementation simply delegates to &#x60;$log.error&#x60; which logs it into
 * the browser console.
 *
 * In unit tests, if &#x60;angular-mocks.js&#x60; is loaded, this service is overridden by
 * {@link ngMock.$exceptionHandler mock $exceptionHandler} which aids in testing.
 *
 * @param {Error} exception Exception associated with the error.
 * @param {string=} cause optional information about the context in which
 *       the error was thrown.
 *
 */
function $ExceptionHandlerProvider() {
  this.$get = [&#x27;$log&#x27;, function($log) {
    return function(exception, cause) {
      $log.error.apply($log, arguments);
    };
  }];
}

/**
 * @ngdoc object
 * @name ng.$interpolateProvider
 * @function
 *
 * @description
 *
 * Used for configuring the interpolation markup. Defaults to &#x60;{{&#x60; and &#x60;}}&#x60;.
 */
function $InterpolateProvider() {
  var startSymbol = &#x27;{{&#x27;;
  var endSymbol = &#x27;}}&#x27;;

  /**
   * @ngdoc method
   * @name ng.$interpolateProvider#startSymbol
   * @methodOf ng.$interpolateProvider
   * @description
   * Symbol to denote start of expression in the interpolated string. Defaults to &#x60;{{&#x60;.
   *
   * @param {string=} value new value to set the starting symbol to.
   * @returns {string|self} Returns the symbol when used as getter and self if used as setter.
   */
  this.startSymbol = function(value){
    if (value) {
      startSymbol = value;
      return this;
    } else {
      return startSymbol;
    }
  };

  /**
   * @ngdoc method
   * @name ng.$interpolateProvider#endSymbol
   * @methodOf ng.$interpolateProvider
   * @description
   * Symbol to denote the end of expression in the interpolated string. Defaults to &#x60;}}&#x60;.
   *
   * @param {string=} value new value to set the ending symbol to.
   * @returns {string|self} Returns the symbol when used as getter and self if used as setter.
   */
  this.endSymbol = function(value){
    if (value) {
      endSymbol = value;
      return this;
    } else {
      return endSymbol;
    }
  };


  this.$get = [&#x27;$parse&#x27;, &#x27;$exceptionHandler&#x27;, function($parse, $exceptionHandler) {
    var startSymbolLength = startSymbol.length,
        endSymbolLength = endSymbol.length;

    /**
     * @ngdoc function
     * @name ng.$interpolate
     * @function
     *
     * @requires $parse
     *
     * @description
     *
     * Compiles a string with markup into an interpolation function. This service is used by the
     * HTML {@link ng.$compile $compile} service for data binding. See
     * {@link ng.$interpolateProvider $interpolateProvider} for configuring the
     * interpolation markup.
     *
     *
       &lt;pre&gt;
         var $interpolate = ...; // injected
         var exp = $interpolate(&#x27;Hello {{name}}!&#x27;);
         expect(exp({name:&#x27;Angular&#x27;}).toEqual(&#x27;Hello Angular!&#x27;);
       &lt;/pre&gt;
     *
     *
     * @param {string} text The text with markup to interpolate.
     * @param {boolean=} mustHaveExpression if set to true then the interpolation string must have
     *    embedded expression in order to return an interpolation function. Strings with no
     *    embedded expression will return null for the interpolation function.
     * @returns {function(context)} an interpolation function which is used to compute the interpolated
     *    string. The function has these parameters:
     *
     *    * &#x60;context&#x60;: an object against which any expressions embedded in the strings are evaluated
     *      against.
     *
     */
    function $interpolate(text, mustHaveExpression) {
      var startIndex,
          endIndex,
          index = 0,
          parts = [],
          length = text.length,
          hasInterpolation = false,
          fn,
          exp,
          concat = [];

      while(index &lt; length) {
        if ( ((startIndex = text.indexOf(startSymbol, index)) != -1) &amp;&amp;
             ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) ) {
          (index != startIndex) &amp;&amp; parts.push(text.substring(index, startIndex));
          parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex)));
          fn.exp = exp;
          index = endIndex + endSymbolLength;
          hasInterpolation = true;
        } else {
          // we did not find anything, so we have to add the remainder to the parts array
          (index != length) &amp;&amp; parts.push(text.substring(index));
          index = length;
        }
      }

      if (!(length = parts.length)) {
        // we added, nothing, must have been an empty string.
        parts.push(&#x27;&#x27;);
        length = 1;
      }

      if (!mustHaveExpression  || hasInterpolation) {
        concat.length = length;
        fn = function(context) {
          try {
            for(var i = 0, ii = length, part; i&lt;ii; i++) {
              if (typeof (part = parts[i]) == &#x27;function&#x27;) {
                part = part(context);
                if (part == null || part == undefined) {
                  part = &#x27;&#x27;;
                } else if (typeof part != &#x27;string&#x27;) {
                  part = toJson(part);
                }
              }
              concat[i] = part;
            }
            return concat.join(&#x27;&#x27;);
          }
          catch(err) {
            var newErr = new Error(&#x27;Error while interpolating: &#x27; + text + &#x27;\n&#x27; + err.toString());
            $exceptionHandler(newErr);
          }
        };
        fn.exp = text;
        fn.parts = parts;
        return fn;
      }
    }


    /**
     * @ngdoc method
     * @name ng.$interpolate#startSymbol
     * @methodOf ng.$interpolate
     * @description
     * Symbol to denote the start of expression in the interpolated string. Defaults to &#x60;{{&#x60;.
     *
     * Use {@link ng.$interpolateProvider#startSymbol $interpolateProvider#startSymbol} to change
     * the symbol.
     *
     * @returns {string} start symbol.
     */
    $interpolate.startSymbol = function() {
      return startSymbol;
    }


    /**
     * @ngdoc method
     * @name ng.$interpolate#endSymbol
     * @methodOf ng.$interpolate
     * @description
     * Symbol to denote the end of expression in the interpolated string. Defaults to &#x60;}}&#x60;.
     *
     * Use {@link ng.$interpolateProvider#endSymbol $interpolateProvider#endSymbol} to change
     * the symbol.
     *
     * @returns {string} start symbol.
     */
    $interpolate.endSymbol = function() {
      return endSymbol;
    }

    return $interpolate;
  }];
}

var SERVER_MATCH = /^([^:]+):\/\/(\w+:{0,1}\w*@)?(\{?[\w\.-]*\}?)(:([0-9]+))?(\/[^\?#]*)?(\?([^#]*))?(#(.*))?$/,
    PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/,
    DEFAULT_PORTS = {&#x27;http&#x27;: 80, &#x27;https&#x27;: 443, &#x27;ftp&#x27;: 21};


/**
 * Encode path using encodeUriSegment, ignoring forward slashes
 *
 * @param {string} path Path to encode
 * @returns {string}
 */
function encodePath(path) {
  var segments = path.split(&#x27;/&#x27;),
      i = segments.length;

  while (i--) {
    segments[i] = encodeUriSegment(segments[i]);
  }

  return segments.join(&#x27;/&#x27;);
}

function matchUrl(url, obj) {
  var match = SERVER_MATCH.exec(url);

  obj.$$protocol = match[1];
  obj.$$host = match[3];
  obj.$$port = int(match[5]) || DEFAULT_PORTS[match[1]] || null;
}

function matchAppUrl(url, obj) {
  var match = PATH_MATCH.exec(url);

  obj.$$path = decodeURIComponent(match[1]);
  obj.$$search = parseKeyValue(match[3]);
  obj.$$hash = decodeURIComponent(match[5] || &#x27;&#x27;);

  // make sure path starts with &#x27;/&#x27;;
  if (obj.$$path &amp;&amp; obj.$$path.charAt(0) != &#x27;/&#x27;) obj.$$path = &#x27;/&#x27; + obj.$$path;
}


function composeProtocolHostPort(protocol, host, port) {
  return protocol + &#x27;://&#x27; + host + (port == DEFAULT_PORTS[protocol] ? &#x27;&#x27; : &#x27;:&#x27; + port);
}

/**
 *
 * @param {string} begin
 * @param {string} whole
 * @param {string} otherwise
 * @returns {string} returns text from whole after begin or otherwise if it does not begin with expected string.
 */
function beginsWith(begin, whole, otherwise) {
  return whole.indexOf(begin) == 0 ? whole.substr(begin.length) : otherwise;
}


function stripHash(url) {
  var index = url.indexOf(&#x27;#&#x27;);
  return index == -1 ? url : url.substr(0, index);
}


function stripFile(url) {
  return url.substr(0, stripHash(url).lastIndexOf(&#x27;/&#x27;) + 1);
}

/* return the server only */
function serverBase(url) {
  return url.substring(0, url.indexOf(&#x27;/&#x27;, url.indexOf(&#x27;//&#x27;) + 2));
}


/**
 * LocationHtml5Url represents an url
 * This object is exposed as $location service when HTML5 mode is enabled and supported
 *
 * @constructor
 * @param {string} appBase application base URL
 * @param {string} basePrefix url path prefix
 */
function LocationHtml5Url(appBase, basePrefix) {
  basePrefix = basePrefix || &#x27;&#x27;;
  var appBaseNoFile = stripFile(appBase);
  /**
   * Parse given html5 (regular) url string into properties
   * @param {string} newAbsoluteUrl HTML5 url
   * @private
   */
  this.$$parse = function(url) {
    var parsed = {}
    matchUrl(url, parsed);
    var pathUrl = beginsWith(appBaseNoFile, url);
    if (!isString(pathUrl)) {
      throw Error(&#x27;Invalid url &quot;&#x27; + url + &#x27;&quot;, missing path prefix &quot;&#x27; + appBaseNoFile + &#x27;&quot;.&#x27;);
    }
    matchAppUrl(pathUrl, parsed);
    extend(this, parsed);
    if (!this.$$path) {
      this.$$path = &#x27;/&#x27;;
    }

    this.$$compose();
  };

  /**
   * Compose url and update &#x60;absUrl&#x60; property
   * @private
   */
  this.$$compose = function() {
    var search = toKeyValue(this.$$search),
        hash = this.$$hash ? &#x27;#&#x27; + encodeUriSegment(this.$$hash) : &#x27;&#x27;;

    this.$$url = encodePath(this.$$path) + (search ? &#x27;?&#x27; + search : &#x27;&#x27;) + hash;
    this.$$absUrl = appBaseNoFile + this.$$url.substr(1); // first char is always &#x27;/&#x27;
  };

  this.$$rewrite = function(url) {
    var appUrl, prevAppUrl;

    if ( (appUrl = beginsWith(appBase, url)) !== undefined ) {
      prevAppUrl = appUrl;
      if ( (appUrl = beginsWith(basePrefix, appUrl)) !== undefined ) {
        return appBaseNoFile + (beginsWith(&#x27;/&#x27;, appUrl) || appUrl);
      } else {
        return appBase + prevAppUrl;
      }
    } else if ( (appUrl = beginsWith(appBaseNoFile, url)) !== undefined ) {
      return appBaseNoFile + appUrl;
    } else if (appBaseNoFile == url + &#x27;/&#x27;) {
      return appBaseNoFile;
    }
  }
}


/**
 * LocationHashbangUrl represents url
 * This object is exposed as $location service when html5 history api is disabled or not supported
 *
 * @constructor
 * @param {string} appBase application base URL
 * @param {string} hashPrefix hashbang prefix
 */
function LocationHashbangUrl(appBase, hashPrefix) {
  var appBaseNoFile = stripFile(appBase);

  /**
   * Parse given hashbang url into properties
   * @param {string} url Hashbang url
   * @private
   */
  this.$$parse = function(url) {
    matchUrl(url, this);
    var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
    if (!isString(withoutBaseUrl)) {
      throw new Error(&#x27;Invalid url &quot;&#x27; + url + &#x27;&quot;, does not start with &quot;&#x27; + appBase +  &#x27;&quot;.&#x27;);
    }
    var withoutHashUrl = withoutBaseUrl.charAt(0) == &#x27;#&#x27; ? beginsWith(hashPrefix, withoutBaseUrl) : withoutBaseUrl;
    if (!isString(withoutHashUrl)) {
      throw new Error(&#x27;Invalid url &quot;&#x27; + url + &#x27;&quot;, missing hash prefix &quot;&#x27; + hashPrefix + &#x27;&quot;.&#x27;);
    }
    matchAppUrl(withoutHashUrl, this);
    this.$$compose();
  };

  /**
   * Compose hashbang url and update &#x60;absUrl&#x60; property
   * @private
   */
  this.$$compose = function() {
    var search = toKeyValue(this.$$search),
        hash = this.$$hash ? &#x27;#&#x27; + encodeUriSegment(this.$$hash) : &#x27;&#x27;;

    this.$$url = encodePath(this.$$path) + (search ? &#x27;?&#x27; + search : &#x27;&#x27;) + hash;
    this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : &#x27;&#x27;);
  };

  this.$$rewrite = function(url) {
    if(stripHash(appBase) == stripHash(url)) {
      return url;
    }
  }
}


/**
 * LocationHashbangUrl represents url
 * This object is exposed as $location service when html5 history api is enabled but the browser
 * does not support it.
 *
 * @constructor
 * @param {string} appBase application base URL
 * @param {string} hashPrefix hashbang prefix
 */
function LocationHashbangInHtml5Url(appBase, hashPrefix) {
  LocationHashbangUrl.apply(this, arguments);

  var appBaseNoFile = stripFile(appBase);

  this.$$rewrite = function(url) {
    var appUrl;

    if ( appBase == stripHash(url) ) {
      return url;
    } else if ( (appUrl = beginsWith(appBaseNoFile, url)) ) {
      return appBase + hashPrefix + appUrl;
    } else if ( appBaseNoFile === url + &#x27;/&#x27;) {
      return appBaseNoFile;
    }
  }
}


LocationHashbangInHtml5Url.prototype =
  LocationHashbangUrl.prototype =
  LocationHtml5Url.prototype = {

  /**
   * Has any change been replacing ?
   * @private
   */
  $$replace: false,

  /**
   * @ngdoc method
   * @name ng.$location#absUrl
   * @methodOf ng.$location
   *
   * @description
   * This method is getter only.
   *
   * Return full url representation with all segments encoded according to rules specified in
   * {@link http://www.ietf.org/rfc/rfc3986.txt RFC 3986}.
   *
   * @return {string} full url
   */
  absUrl: locationGetter(&#x27;$$absUrl&#x27;),

  /**
   * @ngdoc method
   * @name ng.$location#url
   * @methodOf ng.$location
   *
   * @description
   * This method is getter / setter.
   *
   * Return url (e.g. &#x60;/path?a=b#hash&#x60;) when called without any parameter.
   *
   * Change path, search and hash, when called with parameter and return &#x60;$location&#x60;.
   *
   * @param {string=} url New url without base prefix (e.g. &#x60;/path?a=b#hash&#x60;)
   * @return {string} url
   */
  url: function(url, replace) {
    if (isUndefined(url))
      return this.$$url;

    var match = PATH_MATCH.exec(url);
    if (match[1]) this.path(decodeURIComponent(match[1]));
    if (match[2] || match[1]) this.search(match[3] || &#x27;&#x27;);
    this.hash(match[5] || &#x27;&#x27;, replace);

    return this;
  },

  /**
   * @ngdoc method
   * @name ng.$location#protocol
   * @methodOf ng.$location
   *
   * @description
   * This method is getter only.
   *
   * Return protocol of current url.
   *
   * @return {string} protocol of current url
   */
  protocol: locationGetter(&#x27;$$protocol&#x27;),

  /**
   * @ngdoc method
   * @name ng.$location#host
   * @methodOf ng.$location
   *
   * @description
   * This method is getter only.
   *
   * Return host of current url.
   *
   * @return {string} host of current url.
   */
  host: locationGetter(&#x27;$$host&#x27;),

  /**
   * @ngdoc method
   * @name ng.$location#port
   * @methodOf ng.$location
   *
   * @description
   * This method is getter only.
   *
   * Return port of current url.
   *
   * @return {Number} port
   */
  port: locationGetter(&#x27;$$port&#x27;),

  /**
   * @ngdoc method
   * @name ng.$location#path
   * @methodOf ng.$location
   *
   * @description
   * This method is getter / setter.
   *
   * Return path of current url when called without any parameter.
   *
   * Change path when called with parameter and return &#x60;$location&#x60;.
   *
   * Note: Path should always begin with forward slash (/), this method will add the forward slash
   * if it is missing.
   *
   * @param {string=} path New path
   * @return {string} path
   */
  path: locationGetterSetter(&#x27;$$path&#x27;, function(path) {
    return path.charAt(0) == &#x27;/&#x27; ? path : &#x27;/&#x27; + path;
  }),

  /**
   * @ngdoc method
   * @name ng.$location#search
   * @methodOf ng.$location
   *
   * @description
   * This method is getter / setter.
   *
   * Return search part (as object) of current url when called without any parameter.
   *
   * Change search part when called with parameter and return &#x60;$location&#x60;.
   *
   * @param {string|object&lt;string,string&gt;=} search New search params - string or hash object
   * @param {string=} paramValue If &#x60;search&#x60; is a string, then &#x60;paramValue&#x60; will override only a
   *    single search parameter. If the value is &#x60;null&#x60;, the parameter will be deleted.
   *
   * @return {string} search
   */
  search: function(search, paramValue) {
    if (isUndefined(search))
      return this.$$search;

    if (isDefined(paramValue)) {
      if (paramValue === null) {
        delete this.$$search[search];
      } else {
        this.$$search[search] = paramValue;
      }
    } else {
      this.$$search = isString(search) ? parseKeyValue(search) : search;
    }

    this.$$compose();
    return this;
  },

  /**
   * @ngdoc method
   * @name ng.$location#hash
   * @methodOf ng.$location
   *
   * @description
   * This method is getter / setter.
   *
   * Return hash fragment when called without any parameter.
   *
   * Change hash fragment when called with parameter and return &#x60;$location&#x60;.
   *
   * @param {string=} hash New hash fragment
   * @return {string} hash
   */
  hash: locationGetterSetter(&#x27;$$hash&#x27;, identity),

  /**
   * @ngdoc method
   * @name ng.$location#replace
   * @methodOf ng.$location
   *
   * @description
   * If called, all changes to $location during current &#x60;$digest&#x60; will be replacing current history
   * record, instead of adding new one.
   */
  replace: function() {
    this.$$replace = true;
    return this;
  }
};

function locationGetter(property) {
  return function() {
    return this[property];
  };
}


function locationGetterSetter(property, preprocess) {
  return function(value) {
    if (isUndefined(value))
      return this[property];

    this[property] = preprocess(value);
    this.$$compose();

    return this;
  };
}


/**
 * @ngdoc object
 * @name ng.$location
 *
 * @requires $browser
 * @requires $sniffer
 * @requires $rootElement
 *
 * @description
 * The $location service parses the URL in the browser address bar (based on the
 * {@link https://developer.mozilla.org/en/window.location window.location}) and makes the URL
 * available to your application. Changes to the URL in the address bar are reflected into
 * $location service and changes to $location are reflected into the browser address bar.
 *
 * **The $location service:**
 *
 * - Exposes the current URL in the browser address bar, so you can
 *   - Watch and observe the URL.
 *   - Change the URL.
 * - Synchronizes the URL with the browser when the user
 *   - Changes the address bar.
 *   - Clicks the back or forward button (or clicks a History link).
 *   - Clicks on a link.
 * - Represents the URL object as a set of methods (protocol, host, port, path, search, hash).
 *
 * For more information see {@link guide/dev_guide.services.$location Developer Guide: Angular
 * Services: Using $location}
 */

/**
 * @ngdoc object
 * @name ng.$locationProvider
 * @description
 * Use the &#x60;$locationProvider&#x60; to configure how the application deep linking paths are stored.
 */
function $LocationProvider(){
  var hashPrefix = &#x27;&#x27;,
      html5Mode = false;

  /**
   * @ngdoc property
   * @name ng.$locationProvider#hashPrefix
   * @methodOf ng.$locationProvider
   * @description
   * @param {string=} prefix Prefix for hash part (containing path and search)
   * @returns {*} current value if used as getter or itself (chaining) if used as setter
   */
  this.hashPrefix = function(prefix) {
    if (isDefined(prefix)) {
      hashPrefix = prefix;
      return this;
    } else {
      return hashPrefix;
    }
  };

  /**
   * @ngdoc property
   * @name ng.$locationProvider#html5Mode
   * @methodOf ng.$locationProvider
   * @description
   * @param {string=} mode Use HTML5 strategy if available.
   * @returns {*} current value if used as getter or itself (chaining) if used as setter
   */
  this.html5Mode = function(mode) {
    if (isDefined(mode)) {
      html5Mode = mode;
      return this;
    } else {
      return html5Mode;
    }
  };

  this.$get = [&#x27;$rootScope&#x27;, &#x27;$browser&#x27;, &#x27;$sniffer&#x27;, &#x27;$rootElement&#x27;,
      function( $rootScope,   $browser,   $sniffer,   $rootElement) {
    var $location,
        LocationMode,
        baseHref = $browser.baseHref(),
        initialUrl = $browser.url(),
        appBase;

    if (html5Mode) {
      appBase = baseHref ? serverBase(initialUrl) + baseHref : initialUrl;
      LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
    } else {
      appBase = stripHash(initialUrl);
      LocationMode = LocationHashbangUrl;
    }
    $location = new LocationMode(appBase, &#x27;#&#x27; + hashPrefix);
    $location.$$parse($location.$$rewrite(initialUrl));

    $rootElement.bind(&#x27;click&#x27;, function(event) {
      // TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)
      // currently we open nice url link and redirect then

      if (event.ctrlKey || event.metaKey || event.which == 2) return;

      var elm = jqLite(event.target);

      // traverse the DOM up to find first A tag
      while (lowercase(elm[0].nodeName) !== &#x27;a&#x27;) {
        // ignore rewriting if no A tag (reached root element, or no parent - removed from document)
        if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
      }

      var absHref = elm.prop(&#x27;href&#x27;);
      var rewrittenUrl = $location.$$rewrite(absHref);

      if (absHref &amp;&amp; !elm.attr(&#x27;target&#x27;) &amp;&amp; rewrittenUrl &amp;&amp; !event.isDefaultPrevented()) {
        event.preventDefault();
        if (rewrittenUrl != $browser.url()) {
          // update location manually
          $location.$$parse(rewrittenUrl);
          $rootScope.$apply();
          // hack to work around FF6 bug 684208 when scenario runner clicks on links
          window.angular[&#x27;ff-684208-preventDefault&#x27;] = true;
        }
      }
    });


    // rewrite hashbang url &lt;&gt; html5 url
    if ($location.absUrl() != initialUrl) {
      $browser.url($location.absUrl(), true);
    }

    // update $location when $browser url changes
    $browser.onUrlChange(function(newUrl) {
      if ($location.absUrl() != newUrl) {
        if ($rootScope.$broadcast(&#x27;$locationChangeStart&#x27;, newUrl, $location.absUrl()).defaultPrevented) {
          $browser.url($location.absUrl());
          return;
        }
        $rootScope.$evalAsync(function() {
          var oldUrl = $location.absUrl();

          $location.$$parse(newUrl);
          afterLocationChange(oldUrl);
        });
        if (!$rootScope.$$phase) $rootScope.$digest();
      }
    });

    // update browser
    var changeCounter = 0;
    $rootScope.$watch(function $locationWatch() {
      var oldUrl = $browser.url();
      var currentReplace = $location.$$replace;

      if (!changeCounter || oldUrl != $location.absUrl()) {
        changeCounter++;
        $rootScope.$evalAsync(function() {
          if ($rootScope.$broadcast(&#x27;$locationChangeStart&#x27;, $location.absUrl(), oldUrl).
              defaultPrevented) {
            $location.$$parse(oldUrl);
          } else {
            $browser.url($location.absUrl(), currentReplace);
            afterLocationChange(oldUrl);
          }
        });
      }
      $location.$$replace = false;

      return changeCounter;
    });

    return $location;

    function afterLocationChange(oldUrl) {
      $rootScope.$broadcast(&#x27;$locationChangeSuccess&#x27;, $location.absUrl(), oldUrl);
    }
}];
}

/**
 * @ngdoc object
 * @name ng.$log
 * @requires $window
 *
 * @description
 * Simple service for logging. Default implementation writes the message
 * into the browser&#x27;s console (if present).
 *
 * The main purpose of this service is to simplify debugging and troubleshooting.
 *
 * @example
   &lt;example&gt;
     &lt;file name=&quot;script.js&quot;&gt;
       function LogCtrl($scope, $log) {
         $scope.$log = $log;
         $scope.message = &#x27;Hello World!&#x27;;
       }
     &lt;/file&gt;
     &lt;file name=&quot;index.html&quot;&gt;
       &lt;div ng-controller=&quot;LogCtrl&quot;&gt;
         &lt;p&gt;Reload this page with open console, enter text and hit the log button...&lt;/p&gt;
         Message:
         &lt;input type=&quot;text&quot; ng-model=&quot;message&quot;/&gt;
         &lt;button ng-click=&quot;$log.log(message)&quot;&gt;log&lt;/button&gt;
         &lt;button ng-click=&quot;$log.warn(message)&quot;&gt;warn&lt;/button&gt;
         &lt;button ng-click=&quot;$log.info(message)&quot;&gt;info&lt;/button&gt;
         &lt;button ng-click=&quot;$log.error(message)&quot;&gt;error&lt;/button&gt;
       &lt;/div&gt;
     &lt;/file&gt;
   &lt;/example&gt;
 */

/**
 * @ngdoc object
 * @name ng.$logProvider
 * @description
 * Use the &#x60;$logProvider&#x60; to configure how the application logs messages
 */
function $LogProvider(){
  var debug = true,
      self = this;
  
  /**
   * @ngdoc property
   * @name ng.$logProvider#debugEnabled
   * @methodOf ng.$logProvider
   * @description
   * @param {string=} flag enable or disable debug level messages
   * @returns {*} current value if used as getter or itself (chaining) if used as setter
   */
  this.debugEnabled = function(flag) {
	  if (isDefined(flag)) {
		  debug = flag;
		  return this;
	  } else {
		  return debug;
	  }
  };
  
  this.$get = [&#x27;$window&#x27;, function($window){
    return {
      /**
       * @ngdoc method
       * @name ng.$log#log
       * @methodOf ng.$log
       *
       * @description
       * Write a log message
       */
      log: consoleLog(&#x27;log&#x27;),

      /**
       * @ngdoc method
       * @name ng.$log#warn
       * @methodOf ng.$log
       *
       * @description
       * Write a warning message
       */
      warn: consoleLog(&#x27;warn&#x27;),

      /**
       * @ngdoc method
       * @name ng.$log#info
       * @methodOf ng.$log
       *
       * @description
       * Write an information message
       */
      info: consoleLog(&#x27;info&#x27;),

      /**
       * @ngdoc method
       * @name ng.$log#error
       * @methodOf ng.$log
       *
       * @description
       * Write an error message
       */
      error: consoleLog(&#x27;error&#x27;),
      
      /**
       * @ngdoc method
       * @name ng.$log#debug
       * @methodOf ng.$log
       * 
       * @description
       * Write a debug message
       */
      debug: (function () {
    	var fn = consoleLog(&#x27;debug&#x27;);
    	
    	return function() {
    		if (debug) {
    			fn.apply(self, arguments);
    		}
    	}
      }())
    };

    function formatError(arg) {
      if (arg instanceof Error) {
        if (arg.stack) {
          arg = (arg.message &amp;&amp; arg.stack.indexOf(arg.message) === -1)
              ? &#x27;Error: &#x27; + arg.message + &#x27;\n&#x27; + arg.stack
              : arg.stack;
        } else if (arg.sourceURL) {
          arg = arg.message + &#x27;\n&#x27; + arg.sourceURL + &#x27;:&#x27; + arg.line;
        }
      }
      return arg;
    }

    function consoleLog(type) {
      var console = $window.console || {},
          logFn = console[type] || console.log || noop;

      if (logFn.apply) {
        return function() {
          var args = [];
          forEach(arguments, function(arg) {
            args.push(formatError(arg));
          });
          return logFn.apply(console, args);
        };
      }

      // we are IE which either doesn&#x27;t have window.console =&gt; this is noop and we do nothing,
      // or we are IE where console.log doesn&#x27;t have apply so we log at least first 2 args
      return function(arg1, arg2) {
        logFn(arg1, arg2);
      }
    }
  }];
}

var OPERATORS = {
    &#x27;null&#x27;:function(){return null;},
    &#x27;true&#x27;:function(){return true;},
    &#x27;false&#x27;:function(){return false;},
    undefined:noop,
    &#x27;+&#x27;:function(self, locals, a,b){
      a=a(self, locals); b=b(self, locals);
      if (isDefined(a)) {
        if (isDefined(b)) {
          return a + b;
        }
        return a;
      }
      return isDefined(b)?b:undefined;},
    &#x27;-&#x27;:function(self, locals, a,b){a=a(self, locals); b=b(self, locals); return (isDefined(a)?a:0)-(isDefined(b)?b:0);},
    &#x27;*&#x27;:function(self, locals, a,b){return a(self, locals)*b(self, locals);},
    &#x27;/&#x27;:function(self, locals, a,b){return a(self, locals)/b(self, locals);},
    &#x27;%&#x27;:function(self, locals, a,b){return a(self, locals)%b(self, locals);},
    &#x27;^&#x27;:function(self, locals, a,b){return a(self, locals)^b(self, locals);},
    &#x27;=&#x27;:noop,
    &#x27;===&#x27;:function(self, locals, a, b){return a(self, locals)===b(self, locals);},
    &#x27;!==&#x27;:function(self, locals, a, b){return a(self, locals)!==b(self, locals);},
    &#x27;==&#x27;:function(self, locals, a,b){return a(self, locals)==b(self, locals);},
    &#x27;!=&#x27;:function(self, locals, a,b){return a(self, locals)!=b(self, locals);},
    &#x27;&lt;&#x27;:function(self, locals, a,b){return a(self, locals)&lt;b(self, locals);},
    &#x27;&gt;&#x27;:function(self, locals, a,b){return a(self, locals)&gt;b(self, locals);},
    &#x27;&lt;=&#x27;:function(self, locals, a,b){return a(self, locals)&lt;=b(self, locals);},
    &#x27;&gt;=&#x27;:function(self, locals, a,b){return a(self, locals)&gt;=b(self, locals);},
    &#x27;&amp;&amp;&#x27;:function(self, locals, a,b){return a(self, locals)&amp;&amp;b(self, locals);},
    &#x27;||&#x27;:function(self, locals, a,b){return a(self, locals)||b(self, locals);},
    &#x27;&amp;&#x27;:function(self, locals, a,b){return a(self, locals)&amp;b(self, locals);},
//    &#x27;|&#x27;:function(self, locals, a,b){return a|b;},
    &#x27;|&#x27;:function(self, locals, a,b){return b(self, locals)(self, locals, a(self, locals));},
    &#x27;!&#x27;:function(self, locals, a){return !a(self, locals);}
};
var ESCAPE = {&quot;n&quot;:&quot;\n&quot;, &quot;f&quot;:&quot;\f&quot;, &quot;r&quot;:&quot;\r&quot;, &quot;t&quot;:&quot;\t&quot;, &quot;v&quot;:&quot;\v&quot;, &quot;&#x27;&quot;:&quot;&#x27;&quot;, &#x27;&quot;&#x27;:&#x27;&quot;&#x27;};

function lex(text, csp){
  var tokens = [],
      token,
      index = 0,
      json = [],
      ch,
      lastCh = &#x27;:&#x27;; // can start regexp

  while (index &lt; text.length) {
    ch = text.charAt(index);
    if (is(&#x27;&quot;\&#x27;&#x27;)) {
      readString(ch);
    } else if (isNumber(ch) || is(&#x27;.&#x27;) &amp;&amp; isNumber(peek())) {
      readNumber();
    } else if (isIdent(ch)) {
      readIdent();
      // identifiers can only be if the preceding char was a { or ,
      if (was(&#x27;{,&#x27;) &amp;&amp; json[0]==&#x27;{&#x27; &amp;&amp;
         (token=tokens[tokens.length-1])) {
        token.json = token.text.indexOf(&#x27;.&#x27;) == -1;
      }
    } else if (is(&#x27;(){}[].,;:?&#x27;)) {
      tokens.push({
        index:index,
        text:ch,
        json:(was(&#x27;:[,&#x27;) &amp;&amp; is(&#x27;{[&#x27;)) || is(&#x27;}]:,&#x27;)
      });
      if (is(&#x27;{[&#x27;)) json.unshift(ch);
      if (is(&#x27;}]&#x27;)) json.shift();
      index++;
    } else if (isWhitespace(ch)) {
      index++;
      continue;
    } else {
      var ch2 = ch + peek(),
          ch3 = ch2 + peek(2),
          fn = OPERATORS[ch],
          fn2 = OPERATORS[ch2],
          fn3 = OPERATORS[ch3];
      if (fn3) {
        tokens.push({index:index, text:ch3, fn:fn3});
        index += 3;
      } else if (fn2) {
        tokens.push({index:index, text:ch2, fn:fn2});
        index += 2;
      } else if (fn) {
        tokens.push({index:index, text:ch, fn:fn, json: was(&#x27;[,:&#x27;) &amp;&amp; is(&#x27;+-&#x27;)});
        index += 1;
      } else {
        throwError(&quot;Unexpected next character &quot;, index, index+1);
      }
    }
    lastCh = ch;
  }
  return tokens;

  function is(chars) {
    return chars.indexOf(ch) != -1;
  }

  function was(chars) {
    return chars.indexOf(lastCh) != -1;
  }

  function peek(i) {
    var num = i || 1;
    return index + num &lt; text.length ? text.charAt(index + num) : false;
  }
  function isNumber(ch) {
    return &#x27;0&#x27; &lt;= ch &amp;&amp; ch &lt;= &#x27;9&#x27;;
  }
  function isWhitespace(ch) {
    return ch == &#x27; &#x27; || ch == &#x27;\r&#x27; || ch == &#x27;\t&#x27; ||
           ch == &#x27;\n&#x27; || ch == &#x27;\v&#x27; || ch == &#x27;\u00A0&#x27;; // IE treats non-breaking space as \u00A0
  }
  function isIdent(ch) {
    return &#x27;a&#x27; &lt;= ch &amp;&amp; ch &lt;= &#x27;z&#x27; ||
           &#x27;A&#x27; &lt;= ch &amp;&amp; ch &lt;= &#x27;Z&#x27; ||
           &#x27;_&#x27; == ch || ch == &#x27;$&#x27;;
  }
  function isExpOperator(ch) {
    return ch == &#x27;-&#x27; || ch == &#x27;+&#x27; || isNumber(ch);
  }

  function throwError(error, start, end) {
    end = end || index;
    throw Error(&quot;Lexer Error: &quot; + error + &quot; at column&quot; +
        (isDefined(start)
            ? &quot;s &quot; + start +  &quot;-&quot; + index + &quot; [&quot; + text.substring(start, end) + &quot;]&quot;
            : &quot; &quot; + end) +
        &quot; in expression [&quot; + text + &quot;].&quot;);
  }

  function readNumber() {
    var number = &quot;&quot;;
    var start = index;
    while (index &lt; text.length) {
      var ch = lowercase(text.charAt(index));
      if (ch == &#x27;.&#x27; || isNumber(ch)) {
        number += ch;
      } else {
        var peekCh = peek();
        if (ch == &#x27;e&#x27; &amp;&amp; isExpOperator(peekCh)) {
          number += ch;
        } else if (isExpOperator(ch) &amp;&amp;
            peekCh &amp;&amp; isNumber(peekCh) &amp;&amp;
            number.charAt(number.length - 1) == &#x27;e&#x27;) {
          number += ch;
        } else if (isExpOperator(ch) &amp;&amp;
            (!peekCh || !isNumber(peekCh)) &amp;&amp;
            number.charAt(number.length - 1) == &#x27;e&#x27;) {
          throwError(&#x27;Invalid exponent&#x27;);
        } else {
          break;
        }
      }
      index++;
    }
    number = 1 * number;
    tokens.push({index:start, text:number, json:true,
      fn:function() {return number;}});
  }
  function readIdent() {
    var ident = &quot;&quot;,
        start = index,
        lastDot, peekIndex, methodName, ch;

    while (index &lt; text.length) {
      ch = text.charAt(index);
      if (ch == &#x27;.&#x27; || isIdent(ch) || isNumber(ch)) {
        if (ch == &#x27;.&#x27;) lastDot = index;
        ident += ch;
      } else {
        break;
      }
      index++;
    }

    //check if this is not a method invocation and if it is back out to last dot
    if (lastDot) {
      peekIndex = index;
      while(peekIndex &lt; text.length) {
        ch = text.charAt(peekIndex);
        if (ch == &#x27;(&#x27;) {
          methodName = ident.substr(lastDot - start + 1);
          ident = ident.substr(0, lastDot - start);
          index = peekIndex;
          break;
        }
        if(isWhitespace(ch)) {
          peekIndex++;
        } else {
          break;
        }
      }
    }


    var token = {
      index:start,
      text:ident
    };

    if (OPERATORS.hasOwnProperty(ident)) {
      token.fn = token.json = OPERATORS[ident];
    } else {
      var getter = getterFn(ident, csp);
      token.fn = extend(function(self, locals) {
        return (getter(self, locals));
      }, {
        assign: function(self, value) {
          return setter(self, ident, value);
        }
      });
    }

    tokens.push(token);

    if (methodName) {
      tokens.push({
        index:lastDot,
        text: &#x27;.&#x27;,
        json: false
      });
      tokens.push({
        index: lastDot + 1,
        text: methodName,
        json: false
      });
    }
  }

  function readString(quote) {
    var start = index;
    index++;
    var string = &quot;&quot;;
    var rawString = quote;
    var escape = false;
    while (index &lt; text.length) {
      var ch = text.charAt(index);
      rawString += ch;
      if (escape) {
        if (ch == &#x27;u&#x27;) {
          var hex = text.substring(index + 1, index + 5);
          if (!hex.match(/[\da-f]{4}/i))
            throwError( &quot;Invalid unicode escape [\\u&quot; + hex + &quot;]&quot;);
          index += 4;
          string += String.fromCharCode(parseInt(hex, 16));
        } else {
          var rep = ESCAPE[ch];
          if (rep) {
            string += rep;
          } else {
            string += ch;
          }
        }
        escape = false;
      } else if (ch == &#x27;\\&#x27;) {
        escape = true;
      } else if (ch == quote) {
        index++;
        tokens.push({
          index:start,
          text:rawString,
          string:string,
          json:true,
          fn:function() { return string; }
        });
        return;
      } else {
        string += ch;
      }
      index++;
    }
    throwError(&quot;Unterminated quote&quot;, start);
  }
}

/////////////////////////////////////////

function parser(text, json, $filter, csp){
  var ZERO = valueFn(0),
      value,
      tokens = lex(text, csp),
      assignment = _assignment,
      functionCall = _functionCall,
      fieldAccess = _fieldAccess,
      objectIndex = _objectIndex,
      filterChain = _filterChain;

  if(json){
    // The extra level of aliasing is here, just in case the lexer misses something, so that
    // we prevent any accidental execution in JSON.
    assignment = logicalOR;
    functionCall =
      fieldAccess =
      objectIndex =
      filterChain =
        function() { throwError(&quot;is not valid json&quot;, {text:text, index:0}); };
    value = primary();
  } else {
    value = statements();
  }
  if (tokens.length !== 0) {
    throwError(&quot;is an unexpected token&quot;, tokens[0]);
  }
  value.literal = !!value.literal;
  value.constant = !!value.constant;
  return value;

  ///////////////////////////////////
  function throwError(msg, token) {
    throw Error(&quot;Syntax Error: Token &#x27;&quot; + token.text +
      &quot;&#x27; &quot; + msg + &quot; at column &quot; +
      (token.index + 1) + &quot; of the expression [&quot; +
      text + &quot;] starting at [&quot; + text.substring(token.index) + &quot;].&quot;);
  }

  function peekToken() {
    if (tokens.length === 0)
      throw Error(&quot;Unexpected end of expression: &quot; + text);
    return tokens[0];
  }

  function peek(e1, e2, e3, e4) {
    if (tokens.length &gt; 0) {
      var token = tokens[0];
      var t = token.text;
      if (t==e1 || t==e2 || t==e3 || t==e4 ||
          (!e1 &amp;&amp; !e2 &amp;&amp; !e3 &amp;&amp; !e4)) {
        return token;
      }
    }
    return false;
  }

  function expect(e1, e2, e3, e4){
    var token = peek(e1, e2, e3, e4);
    if (token) {
      if (json &amp;&amp; !token.json) {
        throwError(&quot;is not valid json&quot;, token);
      }
      tokens.shift();
      return token;
    }
    return false;
  }

  function consume(e1){
    if (!expect(e1)) {
      throwError(&quot;is unexpected, expecting [&quot; + e1 + &quot;]&quot;, peek());
    }
  }

  function unaryFn(fn, right) {
    return extend(function(self, locals) {
      return fn(self, locals, right);
    }, {
      constant:right.constant
    });
  }

  function ternaryFn(left, middle, right){
    return extend(function(self, locals){
      return left(self, locals) ? middle(self, locals) : right(self, locals);
    }, {
      constant: left.constant &amp;&amp; middle.constant &amp;&amp; right.constant
    });
  }
  
  function binaryFn(left, fn, right) {
    return extend(function(self, locals) {
      return fn(self, locals, left, right);
    }, {
      constant:left.constant &amp;&amp; right.constant
    });
  }

  function statements() {
    var statements = [];
    while(true) {
      if (tokens.length &gt; 0 &amp;&amp; !peek(&#x27;}&#x27;, &#x27;)&#x27;, &#x27;;&#x27;, &#x27;]&#x27;))
        statements.push(filterChain());
      if (!expect(&#x27;;&#x27;)) {
        // optimize for the common case where there is only one statement.
        // TODO(size): maybe we should not support multiple statements?
        return statements.length == 1
          ? statements[0]
          : function(self, locals){
            var value;
            for ( var i = 0; i &lt; statements.length; i++) {
              var statement = statements[i];
              if (statement)
                value = statement(self, locals);
            }
            return value;
          };
      }
    }
  }

  function _filterChain() {
    var left = expression();
    var token;
    while(true) {
      if ((token = expect(&#x27;|&#x27;))) {
        left = binaryFn(left, token.fn, filter());
      } else {
        return left;
      }
    }
  }

  function filter() {
    var token = expect();
    var fn = $filter(token.text);
    var argsFn = [];
    while(true) {
      if ((token = expect(&#x27;:&#x27;))) {
        argsFn.push(expression());
      } else {
        var fnInvoke = function(self, locals, input){
          var args = [input];
          for ( var i = 0; i &lt; argsFn.length; i++) {
            args.push(argsFn[i](self, locals));
          }
          return fn.apply(self, args);
        };
        return function() {
          return fnInvoke;
        };
      }
    }
  }

  function expression() {
    return assignment();
  }

  function _assignment() {
    var left = ternary();
    var right;
    var token;
    if ((token = expect(&#x27;=&#x27;))) {
      if (!left.assign) {
        throwError(&quot;implies assignment but [&quot; +
          text.substring(0, token.index) + &quot;] can not be assigned to&quot;, token);
      }
      right = ternary();
      return function(scope, locals){
        return left.assign(scope, right(scope, locals), locals);
      };
    } else {
      return left;
    }
  }

  function ternary() {
    var left = logicalOR();
    var middle;
    var token;
    if((token = expect(&#x27;?&#x27;))){
      middle = ternary();
      if((token = expect(&#x27;:&#x27;))){
        return ternaryFn(left, middle, ternary());
      }
      else {
        throwError(&#x27;expected :&#x27;, token);
      }
    }
    else {
      return left;
    }
  }
  
  function logicalOR() {
    var left = logicalAND();
    var token;
    while(true) {
      if ((token = expect(&#x27;||&#x27;))) {
        left = binaryFn(left, token.fn, logicalAND());
      } else {
        return left;
      }
    }
  }

  function logicalAND() {
    var left = equality();
    var token;
    if ((token = expect(&#x27;&amp;&amp;&#x27;))) {
      left = binaryFn(left, token.fn, logicalAND());
    }
    return left;
  }

  function equality() {
    var left = relational();
    var token;
    if ((token = expect(&#x27;==&#x27;,&#x27;!=&#x27;,&#x27;===&#x27;,&#x27;!==&#x27;))) {
      left = binaryFn(left, token.fn, equality());
    }
    return left;
  }

  function relational() {
    var left = additive();
    var token;
    if ((token = expect(&#x27;&lt;&#x27;, &#x27;&gt;&#x27;, &#x27;&lt;=&#x27;, &#x27;&gt;=&#x27;))) {
      left = binaryFn(left, token.fn, relational());
    }
    return left;
  }

  function additive() {
    var left = multiplicative();
    var token;
    while ((token = expect(&#x27;+&#x27;,&#x27;-&#x27;))) {
      left = binaryFn(left, token.fn, multiplicative());
    }
    return left;
  }

  function multiplicative() {
    var left = unary();
    var token;
    while ((token = expect(&#x27;*&#x27;,&#x27;/&#x27;,&#x27;%&#x27;))) {
      left = binaryFn(left, token.fn, unary());
    }
    return left;
  }

  function unary() {
    var token;
    if (expect(&#x27;+&#x27;)) {
      return primary();
    } else if ((token = expect(&#x27;-&#x27;))) {
      return binaryFn(ZERO, token.fn, unary());
    } else if ((token = expect(&#x27;!&#x27;))) {
      return unaryFn(token.fn, unary());
    } else {
      return primary();
    }
  }


  function primary() {
    var primary;
    if (expect(&#x27;(&#x27;)) {
      primary = filterChain();
      consume(&#x27;)&#x27;);
    } else if (expect(&#x27;[&#x27;)) {
      primary = arrayDeclaration();
    } else if (expect(&#x27;{&#x27;)) {
      primary = object();
    } else {
      var token = expect();
      primary = token.fn;
      if (!primary) {
        throwError(&quot;not a primary expression&quot;, token);
      }
      if (token.json) {
        primary.constant = primary.literal = true;
      }
    }

    var next, context;
    while ((next = expect(&#x27;(&#x27;, &#x27;[&#x27;, &#x27;.&#x27;))) {
      if (next.text === &#x27;(&#x27;) {
        primary = functionCall(primary, context);
        context = null;
      } else if (next.text === &#x27;[&#x27;) {
        context = primary;
        primary = objectIndex(primary);
      } else if (next.text === &#x27;.&#x27;) {
        context = primary;
        primary = fieldAccess(primary);
      } else {
        throwError(&quot;IMPOSSIBLE&quot;);
      }
    }
    return primary;
  }

  function _fieldAccess(object) {
    var field = expect().text;
    var getter = getterFn(field, csp);
    return extend(
        function(scope, locals, self) {
          return getter(self || object(scope, locals), locals);
        },
        {
          assign:function(scope, value, locals) {
            return setter(object(scope, locals), field, value);
          }
        }
    );
  }

  function _objectIndex(obj) {
    var indexFn = expression();
    consume(&#x27;]&#x27;);
    return extend(
      function(self, locals){
        var o = obj(self, locals),
            i = indexFn(self, locals),
            v, p;

        if (!o) return undefined;
        v = o[i];
        if (v &amp;&amp; v.then) {
          p = v;
          if (!(&#x27;$$v&#x27; in v)) {
            p.$$v = undefined;
            p.then(function(val) { p.$$v = val; });
          }
          v = v.$$v;
        }
        return v;
      }, {
        assign:function(self, value, locals){
          return obj(self, locals)[indexFn(self, locals)] = value;
        }
      });
  }

  function _functionCall(fn, contextGetter) {
    var argsFn = [];
    if (peekToken().text != &#x27;)&#x27;) {
      do {
        argsFn.push(expression());
      } while (expect(&#x27;,&#x27;));
    }
    consume(&#x27;)&#x27;);
    return function(scope, locals){
      var args = [],
          context = contextGetter ? contextGetter(scope, locals) : scope;

      for ( var i = 0; i &lt; argsFn.length; i++) {
        args.push(argsFn[i](scope, locals));
      }
      var fnPtr = fn(scope, locals, context) || noop;
      // IE stupidity!
      return fnPtr.apply
          ? fnPtr.apply(context, args)
          : fnPtr(args[0], args[1], args[2], args[3], args[4]);
    };
  }

  // This is used with json array declaration
  function arrayDeclaration () {
    var elementFns = [];
    var allConstant = true;
    if (peekToken().text != &#x27;]&#x27;) {
      do {
        var elementFn = expression();
        elementFns.push(elementFn);
        if (!elementFn.constant) {
          allConstant = false;
        }
      } while (expect(&#x27;,&#x27;));
    }
    consume(&#x27;]&#x27;);
    return extend(function(self, locals){
      var array = [];
      for ( var i = 0; i &lt; elementFns.length; i++) {
        array.push(elementFns[i](self, locals));
      }
      return array;
    }, {
      literal:true,
      constant:allConstant
    });
  }

  function object () {
    var keyValues = [];
    var allConstant = true;
    if (peekToken().text != &#x27;}&#x27;) {
      do {
        var token = expect(),
        key = token.string || token.text;
        consume(&quot;:&quot;);
        var value = expression();
        keyValues.push({key:key, value:value});
        if (!value.constant) {
          allConstant = false;
        }
      } while (expect(&#x27;,&#x27;));
    }
    consume(&#x27;}&#x27;);
    return extend(function(self, locals){
      var object = {};
      for ( var i = 0; i &lt; keyValues.length; i++) {
        var keyValue = keyValues[i];
        object[keyValue.key] = keyValue.value(self, locals);
      }
      return object;
    }, {
      literal:true,
      constant:allConstant
    });
  }
}

//////////////////////////////////////////////////
// Parser helper functions
//////////////////////////////////////////////////

function setter(obj, path, setValue) {
  var element = path.split(&#x27;.&#x27;);
  for (var i = 0; element.length &gt; 1; i++) {
    var key = element.shift();
    var propertyObj = obj[key];
    if (!propertyObj) {
      propertyObj = {};
      obj[key] = propertyObj;
    }
    obj = propertyObj;
  }
  obj[element.shift()] = setValue;
  return setValue;
}

/**
 * Return the value accessible from the object by path. Any undefined traversals are ignored
 * @param {Object} obj starting object
 * @param {string} path path to traverse
 * @param {boolean=true} bindFnToScope
 * @returns value as accessible by path
 */
//TODO(misko): this function needs to be removed
function getter(obj, path, bindFnToScope) {
  if (!path) return obj;
  var keys = path.split(&#x27;.&#x27;);
  var key;
  var lastInstance = obj;
  var len = keys.length;

  for (var i = 0; i &lt; len; i++) {
    key = keys[i];
    if (obj) {
      obj = (lastInstance = obj)[key];
    }
  }
  if (!bindFnToScope &amp;&amp; isFunction(obj)) {
    return bind(lastInstance, obj);
  }
  return obj;
}

var getterFnCache = {};

/**
 * Implementation of the &quot;Black Hole&quot; variant from:
 * - http://jsperf.com/angularjs-parse-getter/4
 * - http://jsperf.com/path-evaluation-simplified/7
 */
function cspSafeGetterFn(key0, key1, key2, key3, key4) {
  return function(scope, locals) {
    var pathVal = (locals &amp;&amp; locals.hasOwnProperty(key0)) ? locals : scope,
        promise;

    if (pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key0];
    if (pathVal &amp;&amp; pathVal.then) {
      if (!(&quot;$$v&quot; in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    if (!key1 || pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key1];
    if (pathVal &amp;&amp; pathVal.then) {
      if (!(&quot;$$v&quot; in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    if (!key2 || pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key2];
    if (pathVal &amp;&amp; pathVal.then) {
      if (!(&quot;$$v&quot; in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    if (!key3 || pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key3];
    if (pathVal &amp;&amp; pathVal.then) {
      if (!(&quot;$$v&quot; in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    if (!key4 || pathVal === null || pathVal === undefined) return pathVal;

    pathVal = pathVal[key4];
    if (pathVal &amp;&amp; pathVal.then) {
      if (!(&quot;$$v&quot; in pathVal)) {
        promise = pathVal;
        promise.$$v = undefined;
        promise.then(function(val) { promise.$$v = val; });
      }
      pathVal = pathVal.$$v;
    }
    return pathVal;
  };
}

function getterFn(path, csp) {
  if (getterFnCache.hasOwnProperty(path)) {
    return getterFnCache[path];
  }

  var pathKeys = path.split(&#x27;.&#x27;),
      pathKeysLength = pathKeys.length,
      fn;

  if (csp) {
    fn = (pathKeysLength &lt; 6)
        ? cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4])
        : function(scope, locals) {
          var i = 0, val;
          do {
            val = cspSafeGetterFn(
                    pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++]
                  )(scope, locals);

            locals = undefined; // clear after first iteration
            scope = val;
          } while (i &lt; pathKeysLength);
          return val;
        }
  } else {
    var code = &#x27;var l, fn, p;\n&#x27;;
    forEach(pathKeys, function(key, index) {
      code += &#x27;if(s === null || s === undefined) return s;\n&#x27; +
              &#x27;l=s;\n&#x27; +
              &#x27;s=&#x27;+ (index
                      // we simply dereference &#x27;s&#x27; on any .dot notation
                      ? &#x27;s&#x27;
                      // but if we are first then we check locals first, and if so read it first
                      : &#x27;((k&amp;&amp;k.hasOwnProperty(&quot;&#x27; + key + &#x27;&quot;))?k:s)&#x27;) + &#x27;[&quot;&#x27; + key + &#x27;&quot;]&#x27; + &#x27;;\n&#x27; +
              &#x27;if (s &amp;&amp; s.then) {\n&#x27; +
                &#x27; if (!(&quot;$$v&quot; in s)) {\n&#x27; +
                  &#x27; p=s;\n&#x27; +
                  &#x27; p.$$v = undefined;\n&#x27; +
                  &#x27; p.then(function(v) {p.$$v=v;});\n&#x27; +
                  &#x27;}\n&#x27; +
                &#x27; s=s.$$v\n&#x27; +
              &#x27;}\n&#x27;;
    });
    code += &#x27;return s;&#x27;;
    fn = Function(&#x27;s&#x27;, &#x27;k&#x27;, code); // s=scope, k=locals
    fn.toString = function() { return code; };
  }

  return getterFnCache[path] = fn;
}

///////////////////////////////////

/**
 * @ngdoc function
 * @name ng.$parse
 * @function
 *
 * @description
 *
 * Converts Angular {@link guide/expression expression} into a function.
 *
 * &lt;pre&gt;
 *   var getter = $parse(&#x27;user.name&#x27;);
 *   var setter = getter.assign;
 *   var context = {user:{name:&#x27;angular&#x27;}};
 *   var locals = {user:{name:&#x27;local&#x27;}};
 *
 *   expect(getter(context)).toEqual(&#x27;angular&#x27;);
 *   setter(context, &#x27;newValue&#x27;);
 *   expect(context.user.name).toEqual(&#x27;newValue&#x27;);
 *   expect(getter(context, locals)).toEqual(&#x27;local&#x27;);
 * &lt;/pre&gt;
 *
 *
 * @param {string} expression String expression to compile.
 * @returns {function(context, locals)} a function which represents the compiled expression:
 *
 *    * &#x60;context&#x60;  &#x60;{object}&#x60;  an object against which any expressions embedded in the strings
 *      are evaluated against (typically a scope object).
 *    * &#x60;locals&#x60;  &#x60;{object=}&#x60;  local variables context object, useful for overriding values in
 *      &#x60;context&#x60;.
 *
 *    The returned function also has the following properties:
 *      * &#x60;literal&#x60;  &#x60;{boolean}&#x60;  whether the expression&#x27;s top-level node is a JavaScript
 *        literal.
 *      * &#x60;constant&#x60;  &#x60;{boolean}&#x60;  whether the expression is made entirely of JavaScript
 *        constant literals.
 *      * &#x60;assign&#x60;  &#x60;{?function(context, value)}&#x60;  if the expression is assignable, this will be
 *        set to a function to change its value on the given context.
 *
 */
function $ParseProvider() {
  var cache = {};
  this.$get = [&#x27;$filter&#x27;, &#x27;$sniffer&#x27;, function($filter, $sniffer) {
    return function(exp) {
      switch(typeof exp) {
        case &#x27;string&#x27;:
          return cache.hasOwnProperty(exp)
            ? cache[exp]
            : cache[exp] =  parser(exp, false, $filter, $sniffer.csp);
        case &#x27;function&#x27;:
          return exp;
        default:
          return noop;
      }
    };
  }];
}

/**
 * @ngdoc service
 * @name ng.$q
 * @requires $rootScope
 *
 * @description
 * A promise/deferred implementation inspired by [Kris Kowal&#x27;s Q](https://github.com/kriskowal/q).
 *
 * [The CommonJS Promise proposal](http://wiki.commonjs.org/wiki/Promises) describes a promise as an
 * interface for interacting with an object that represents the result of an action that is
 * performed asynchronously, and may or may not be finished at any given point in time.
 *
 * From the perspective of dealing with error handling, deferred and promise APIs are to
 * asynchronous programming what &#x60;try&#x60;, &#x60;catch&#x60; and &#x60;throw&#x60; keywords are to synchronous programming.
 *
 * &lt;pre&gt;
 *   // for the purpose of this example let&#x27;s assume that variables &#x60;$q&#x60; and &#x60;scope&#x60; are
 *   // available in the current lexical scope (they could have been injected or passed in).
 *
 *   function asyncGreet(name) {
 *     var deferred = $q.defer();
 *
 *     setTimeout(function() {
 *       // since this fn executes async in a future turn of the event loop, we need to wrap
 *       // our code into an $apply call so that the model changes are properly observed.
 *       scope.$apply(function() {
 *         if (okToGreet(name)) {
 *           deferred.resolve(&#x27;Hello, &#x27; + name + &#x27;!&#x27;);
 *         } else {
 *           deferred.reject(&#x27;Greeting &#x27; + name + &#x27; is not allowed.&#x27;);
 *         }
 *       });
 *     }, 1000);
 *
 *     return deferred.promise;
 *   }
 *
 *   var promise = asyncGreet(&#x27;Robin Hood&#x27;);
 *   promise.then(function(greeting) {
 *     alert(&#x27;Success: &#x27; + greeting);
 *   }, function(reason) {
 *     alert(&#x27;Failed: &#x27; + reason);
 *   });
 * &lt;/pre&gt;
 *
 * At first it might not be obvious why this extra complexity is worth the trouble. The payoff
 * comes in the way of
 * [guarantees that promise and deferred APIs make](https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md).
 *
 * Additionally the promise api allows for composition that is very hard to do with the
 * traditional callback ([CPS](http://en.wikipedia.org/wiki/Continuation-passing_style)) approach.
 * For more on this please see the [Q documentation](https://github.com/kriskowal/q) especially the
 * section on serial or parallel joining of promises.
 *
 *
 * # The Deferred API
 *
 * A new instance of deferred is constructed by calling &#x60;$q.defer()&#x60;.
 *
 * The purpose of the deferred object is to expose the associated Promise instance as well as APIs
 * that can be used for signaling the successful or unsuccessful completion of the task.
 *
 * **Methods**
 *
 * - &#x60;resolve(value)&#x60;  resolves the derived promise with the &#x60;value&#x60;. If the value is a rejection
 *   constructed via &#x60;$q.reject&#x60;, the promise will be rejected instead.
 * - &#x60;reject(reason)&#x60;  rejects the derived promise with the &#x60;reason&#x60;. This is equivalent to
 *   resolving it with a rejection constructed via &#x60;$q.reject&#x60;.
 *
 * **Properties**
 *
 * - promise  &#x60;{Promise}&#x60;  promise object associated with this deferred.
 *
 *
 * # The Promise API
 *
 * A new promise instance is created when a deferred instance is created and can be retrieved by
 * calling &#x60;deferred.promise&#x60;.
 *
 * The purpose of the promise object is to allow for interested parties to get access to the result
 * of the deferred task when it completes.
 *
 * **Methods**
 *
 * - &#x60;then(successCallback, errorCallback)&#x60;  regardless of when the promise was or will be resolved
 *   or rejected calls one of the success or error callbacks asynchronously as soon as the result
 *   is available. The callbacks are called with a single argument the result or rejection reason.
 *
 *   This method *returns a new promise* which is resolved or rejected via the return value of the
 *   &#x60;successCallback&#x60; or &#x60;errorCallback&#x60;.
 *
 * - &#x60;always(callback)&#x60;  allows you to observe either the fulfillment or rejection of a promise,
 *   but to do so without modifying the final value. This is useful to release resources or do some
 *   clean-up that needs to be done whether the promise was rejected or resolved. See the [full
 *   specification](https://github.com/kriskowal/q/wiki/API-Reference#promisefinallycallback) for
 *   more information.
 *
 * # Chaining promises
 *
 * Because calling &#x60;then&#x60; api of a promise returns a new derived promise, it is easily possible
 * to create a chain of promises:
 *
 * &lt;pre&gt;
 *   promiseB = promiseA.then(function(result) {
 *     return result + 1;
 *   });
 *
 *   // promiseB will be resolved immediately after promiseA is resolved and its value will be
 *   // the result of promiseA incremented by 1
 * &lt;/pre&gt;
 *
 * It is possible to create chains of any length and since a promise can be resolved with another
 * promise (which will defer its resolution further), it is possible to pause/defer resolution of
 * the promises at any point in the chain. This makes it possible to implement powerful apis like
 * $http&#x27;s response interceptors.
 *
 *
 * # Differences between Kris Kowal&#x27;s Q and $q
 *
 *  There are three main differences:
 *
 * - $q is integrated with the {@link ng.$rootScope.Scope} Scope model observation
 *   mechanism in angular, which means faster propagation of resolution or rejection into your
 *   models and avoiding unnecessary browser repaints, which would result in flickering UI.
 * - $q promises are recognized by the templating engine in angular, which means that in templates
 *   you can treat promises attached to a scope as if they were the resulting values.
 * - Q has many more features than $q, but that comes at a cost of bytes. $q is tiny, but contains
 *   all the important functionality needed for common async tasks.
 * 
 *  # Testing
 * 
 *  &lt;pre&gt;
 *    it(&#x27;should simulate promise&#x27;, inject(function($q, $rootScope) {
 *      var deferred = $q.defer();
 *      var promise = deferred.promise;
 *      var resolvedValue;
 * 
 *      promise.then(function(value) { resolvedValue = value; });
 *      expect(resolvedValue).toBeUndefined();
 * 
 *      // Simulate resolving of promise
 *      deferred.resolve(123);
 *      // Note that the &#x27;then&#x27; function does not get called synchronously.
 *      // This is because we want the promise API to always be async, whether or not
 *      // it got called synchronously or asynchronously.
 *      expect(resolvedValue).toBeUndefined();
 * 
 *      // Propagate promise resolution to &#x27;then&#x27; functions using $apply().
 *      $rootScope.$apply();
 *      expect(resolvedValue).toEqual(123);
 *    });
 *  &lt;/pre&gt;
 */
function $QProvider() {

  this.$get = [&#x27;$rootScope&#x27;, &#x27;$exceptionHandler&#x27;, function($rootScope, $exceptionHandler) {
    return qFactory(function(callback) {
      $rootScope.$evalAsync(callback);
    }, $exceptionHandler);
  }];
}


/**
 * Constructs a promise manager.
 *
 * @param {function(function)} nextTick Function for executing functions in the next turn.
 * @param {function(...*)} exceptionHandler Function into which unexpected exceptions are passed for
 *     debugging purposes.
 * @returns {object} Promise manager.
 */
function qFactory(nextTick, exceptionHandler) {

  /**
   * @ngdoc
   * @name ng.$q#defer
   * @methodOf ng.$q
   * @description
   * Creates a &#x60;Deferred&#x60; object which represents a task which will finish in the future.
   *
   * @returns {Deferred} Returns a new instance of deferred.
   */
  var defer = function() {
    var pending = [],
        value, deferred;

    deferred = {

      resolve: function(val) {
        if (pending) {
          var callbacks = pending;
          pending = undefined;
          value = ref(val);

          if (callbacks.length) {
            nextTick(function() {
              var callback;
              for (var i = 0, ii = callbacks.length; i &lt; ii; i++) {
                callback = callbacks[i];
                value.then(callback[0], callback[1]);
              }
            });
          }
        }
      },


      reject: function(reason) {
        deferred.resolve(reject(reason));
      },


      promise: {
        then: function(callback, errback) {
          var result = defer();

          var wrappedCallback = function(value) {
            try {
              result.resolve((callback || defaultCallback)(value));
            } catch(e) {
              exceptionHandler(e);
              result.reject(e);
            }
          };

          var wrappedErrback = function(reason) {
            try {
              result.resolve((errback || defaultErrback)(reason));
            } catch(e) {
              exceptionHandler(e);
              result.reject(e);
            }
          };

          if (pending) {
            pending.push([wrappedCallback, wrappedErrback]);
          } else {
            value.then(wrappedCallback, wrappedErrback);
          }

          return result.promise;
        },
        always: function(callback) {
          
          function makePromise(value, resolved) {
            var result = defer();
            if (resolved) {
              result.resolve(value);
            } else {
              result.reject(value);
            }
            return result.promise;
          }
          
          function handleCallback(value, isResolved) {
            var callbackOutput = null;            
            try {
              callbackOutput = (callback ||defaultCallback)();
            } catch(e) {
              return makePromise(e, false);
            }            
            if (callbackOutput &amp;&amp; callbackOutput.then) {
              return callbackOutput.then(function() {
                return makePromise(value, isResolved);
              }, function(error) {
                return makePromise(error, false);
              });
            } else {
              return makePromise(value, isResolved);
            }
          }
          
          return this.then(function(value) {
            return handleCallback(value, true);
          }, function(error) {
            return handleCallback(error, false);
          });
        }
      }
    };

    return deferred;
  };


  var ref = function(value) {
    if (value &amp;&amp; value.then) return value;
    return {
      then: function(callback) {
        var result = defer();
        nextTick(function() {
          result.resolve(callback(value));
        });
        return result.promise;
      }
    };
  };


  /**
   * @ngdoc
   * @name ng.$q#reject
   * @methodOf ng.$q
   * @description
   * Creates a promise that is resolved as rejected with the specified &#x60;reason&#x60;. This api should be
   * used to forward rejection in a chain of promises. If you are dealing with the last promise in
   * a promise chain, you don&#x27;t need to worry about it.
   *
   * When comparing deferreds/promises to the familiar behavior of try/catch/throw, think of
   * &#x60;reject&#x60; as the &#x60;throw&#x60; keyword in JavaScript. This also means that if you &quot;catch&quot; an error via
   * a promise error callback and you want to forward the error to the promise derived from the
   * current promise, you have to &quot;rethrow&quot; the error by returning a rejection constructed via
   * &#x60;reject&#x60;.
   *
   * &lt;pre&gt;
   *   promiseB = promiseA.then(function(result) {
   *     // success: do something and resolve promiseB
   *     //          with the old or a new result
   *     return result;
   *   }, function(reason) {
   *     // error: handle the error if possible and
   *     //        resolve promiseB with newPromiseOrValue,
   *     //        otherwise forward the rejection to promiseB
   *     if (canHandle(reason)) {
   *      // handle the error and recover
   *      return newPromiseOrValue;
   *     }
   *     return $q.reject(reason);
   *   });
   * &lt;/pre&gt;
   *
   * @param {*} reason Constant, message, exception or an object representing the rejection reason.
   * @returns {Promise} Returns a promise that was already resolved as rejected with the &#x60;reason&#x60;.
   */
  var reject = function(reason) {
    return {
      then: function(callback, errback) {
        var result = defer();
        nextTick(function() {
          result.resolve((errback || defaultErrback)(reason));
        });
        return result.promise;
      }
    };
  };


  /**
   * @ngdoc
   * @name ng.$q#when
   * @methodOf ng.$q
   * @description
   * Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise.
   * This is useful when you are dealing with an object that might or might not be a promise, or if
   * the promise comes from a source that can&#x27;t be trusted.
   *
   * @param {*} value Value or a promise
   * @returns {Promise} Returns a promise of the passed value or promise
   */
  var when = function(value, callback, errback) {
    var result = defer(),
        done;

    var wrappedCallback = function(value) {
      try {
        return (callback || defaultCallback)(value);
      } catch (e) {
        exceptionHandler(e);
        return reject(e);
      }
    };

    var wrappedErrback = function(reason) {
      try {
        return (errback || defaultErrback)(reason);
      } catch (e) {
        exceptionHandler(e);
        return reject(e);
      }
    };

    nextTick(function() {
      ref(value).then(function(value) {
        if (done) return;
        done = true;
        result.resolve(ref(value).then(wrappedCallback, wrappedErrback));
      }, function(reason) {
        if (done) return;
        done = true;
        result.resolve(wrappedErrback(reason));
      });
    });

    return result.promise;
  };


  function defaultCallback(value) {
    return value;
  }


  function defaultErrback(reason) {
    return reject(reason);
  }


  /**
   * @ngdoc
   * @name ng.$q#all
   * @methodOf ng.$q
   * @description
   * Combines multiple promises into a single promise that is resolved when all of the input
   * promises are resolved.
   *
   * @param {Array.&lt;Promise&gt;|Object.&lt;Promise&gt;} promises An array or hash of promises.
   * @returns {Promise} Returns a single promise that will be resolved with an array/hash of values,
   *   each value corresponding to the promise at the same index/key in the &#x60;promises&#x60; array/hash. If any of
   *   the promises is resolved with a rejection, this resulting promise will be resolved with the
   *   same rejection.
   */
  function all(promises) {
    var deferred = defer(),
        counter = 0,
        results = isArray(promises) ? [] : {};

    forEach(promises, function(promise, key) {
      counter++;
      ref(promise).then(function(value) {
        if (results.hasOwnProperty(key)) return;
        results[key] = value;
        if (!(--counter)) deferred.resolve(results);
      }, function(reason) {
        if (results.hasOwnProperty(key)) return;
        deferred.reject(reason);
      });
    });

    if (counter === 0) {
      deferred.resolve(results);
    }

    return deferred.promise;
  }

  return {
    defer: defer,
    reject: reject,
    when: when,
    all: all
  };
}

/**
 * @ngdoc object
 * @name ng.$routeProvider
 * @function
 *
 * @description
 *
 * Used for configuring routes. See {@link ng.$route $route} for an example.
 */
function $RouteProvider(){
  var routes = {};

  /**
   * @ngdoc method
   * @name ng.$routeProvider#when
   * @methodOf ng.$routeProvider
   *
   * @param {string} path Route path (matched against &#x60;$location.path&#x60;). If &#x60;$location.path&#x60;
   *    contains redundant trailing slash or is missing one, the route will still match and the
   *    &#x60;$location.path&#x60; will be updated to add or drop the trailing slash to exactly match the
   *    route definition.
   *
   *      * &#x60;path&#x60; can contain named groups starting with a colon (&#x60;:name&#x60;). All characters up
   *        to the next slash are matched and stored in &#x60;$routeParams&#x60; under the given &#x60;name&#x60;
   *        when the route matches.
   *      * &#x60;path&#x60; can contain named groups starting with a star (&#x60;*name&#x60;). All characters are
   *        eagerly stored in &#x60;$routeParams&#x60; under the given &#x60;name&#x60; when the route matches.
   *
   *    For example, routes like &#x60;/color/:color/largecode/*largecode/edit&#x60; will match
   *    &#x60;/color/brown/largecode/code/with/slashs/edit&#x60; and extract:
   *
   *      * &#x60;color: brown&#x60;
   *      * &#x60;largecode: code/with/slashs&#x60;.
   *
   *
   * @param {Object} route Mapping information to be assigned to &#x60;$route.current&#x60; on route
   *    match.
   *
   *    Object properties:
   *
   *    - &#x60;controller&#x60;  &#x60;{(string|function()=}&#x60;  Controller fn that should be associated with newly
   *      created scope or the name of a {@link angular.Module#controller registered controller}
   *      if passed as a string.
   *    - &#x60;controllerAs&#x60;  &#x60;{string=}&#x60;  A controller alias name. If present the controller will be
   *      published to scope under the &#x60;controllerAs&#x60; name.
   *    - &#x60;template&#x60;  &#x60;{string=|function()=}&#x60;  html template as a string or function that returns
   *      an html template as a string which should be used by {@link ng.directive:ngView ngView} or
   *      {@link ng.directive:ngInclude ngInclude} directives.
   *      This property takes precedence over &#x60;templateUrl&#x60;.
   *
   *      If &#x60;template&#x60; is a function, it will be called with the following parameters:
   *
   *      - &#x60;{Array.&lt;Object&gt;}&#x60; - route parameters extracted from the current
   *        &#x60;$location.path()&#x60; by applying the current route
   *
   *    - &#x60;templateUrl&#x60;  &#x60;{string=|function()=}&#x60;  path or function that returns a path to an html
   *      template that should be used by {@link ng.directive:ngView ngView}.
   *
   *      If &#x60;templateUrl&#x60; is a function, it will be called with the following parameters:
   *
   *      - &#x60;{Array.&lt;Object&gt;}&#x60; - route parameters extracted from the current
   *        &#x60;$location.path()&#x60; by applying the current route
   *
   *    - &#x60;resolve&#x60; - &#x60;{Object.&lt;string, function&gt;=}&#x60; - An optional map of dependencies which should
   *      be injected into the controller. If any of these dependencies are promises, they will be
   *      resolved and converted to a value before the controller is instantiated and the
   *      &#x60;$routeChangeSuccess&#x60; event is fired. The map object is:
   *
   *      - &#x60;key&#x60;  &#x60;{string}&#x60;: a name of a dependency to be injected into the controller.
   *      - &#x60;factory&#x60; - &#x60;{string|function}&#x60;: If &#x60;string&#x60; then it is an alias for a service.
   *        Otherwise if function, then it is {@link api/AUTO.$injector#invoke injected}
   *        and the return value is treated as the dependency. If the result is a promise, it is resolved
   *        before its value is injected into the controller.
   *
   *    - &#x60;redirectTo&#x60;  {(string|function())=}  value to update
   *      {@link ng.$location $location} path with and trigger route redirection.
   *
   *      If &#x60;redirectTo&#x60; is a function, it will be called with the following parameters:
   *
   *      - &#x60;{Object.&lt;string&gt;}&#x60; - route parameters extracted from the current
   *        &#x60;$location.path()&#x60; by applying the current route templateUrl.
   *      - &#x60;{string}&#x60; - current &#x60;$location.path()&#x60;
   *      - &#x60;{Object}&#x60; - current &#x60;$location.search()&#x60;
   *
   *      The custom &#x60;redirectTo&#x60; function is expected to return a string which will be used
   *      to update &#x60;$location.path()&#x60; and &#x60;$location.search()&#x60;.
   *
   *    - &#x60;[reloadOnSearch=true]&#x60; - {boolean=} - reload route when only $location.search()
   *    changes.
   *
   *      If the option is set to &#x60;false&#x60; and url in the browser changes, then
   *      &#x60;$routeUpdate&#x60; event is broadcasted on the root scope.
   *
   *    - &#x60;[caseInsensitiveMatch=false]&#x60; - {boolean=} - match routes without being case sensitive
   *
   *      If the option is set to &#x60;true&#x60;, then the particular route can be matched without being
   *      case sensitive
   *
   * @returns {Object} self
   *
   * @description
   * Adds a new route definition to the &#x60;$route&#x60; service.
   */
  this.when = function(path, route) {
    routes[path] = extend({reloadOnSearch: true, caseInsensitiveMatch: false}, route);

    // create redirection for trailing slashes
    if (path) {
      var redirectPath = (path[path.length-1] == &#x27;/&#x27;)
          ? path.substr(0, path.length-1)
          : path +&#x27;/&#x27;;

      routes[redirectPath] = {redirectTo: path};
    }

    return this;
  };

  /**
   * @ngdoc method
   * @name ng.$routeProvider#otherwise
   * @methodOf ng.$routeProvider
   *
   * @description
   * Sets route definition that will be used on route change when no other route definition
   * is matched.
   *
   * @param {Object} params Mapping information to be assigned to &#x60;$route.current&#x60;.
   * @returns {Object} self
   */
  this.otherwise = function(params) {
    this.when(null, params);
    return this;
  };


  this.$get = [&#x27;$rootScope&#x27;, &#x27;$location&#x27;, &#x27;$routeParams&#x27;, &#x27;$q&#x27;, &#x27;$injector&#x27;, &#x27;$http&#x27;, &#x27;$templateCache&#x27;,
      function( $rootScope,   $location,   $routeParams,   $q,   $injector,   $http,   $templateCache) {

    /**
     * @ngdoc object
     * @name ng.$route
     * @requires $location
     * @requires $routeParams
     *
     * @property {Object} current Reference to the current route definition.
     * The route definition contains:
     *
     *   - &#x60;controller&#x60;: The controller constructor as define in route definition.
     *   - &#x60;locals&#x60;: A map of locals which is used by {@link ng.$controller $controller} service for
     *     controller instantiation. The &#x60;locals&#x60; contain
     *     the resolved values of the &#x60;resolve&#x60; map. Additionally the &#x60;locals&#x60; also contain:
     *
     *     - &#x60;$scope&#x60; - The current route scope.
     *     - &#x60;$template&#x60; - The current route template HTML.
     *
     * @property {Array.&lt;Object&gt;} routes Array of all configured routes.
     *
     * @description
     * Is used for deep-linking URLs to controllers and views (HTML partials).
     * It watches &#x60;$location.url()&#x60; and tries to map the path to an existing route definition.
     *
     * You can define routes through {@link ng.$routeProvider $routeProvider}&#x27;s API.
     *
     * The &#x60;$route&#x60; service is typically used in conjunction with {@link ng.directive:ngView ngView}
     * directive and the {@link ng.$routeParams $routeParams} service.
     *
     * @example
       This example shows how changing the URL hash causes the &#x60;$route&#x60; to match a route against the
       URL, and the &#x60;ngView&#x60; pulls in the partial.

       Note that this example is using {@link ng.directive:script inlined templates}
       to get it working on jsfiddle as well.

     &lt;example module=&quot;ngView&quot;&gt;
       &lt;file name=&quot;index.html&quot;&gt;
         &lt;div ng-controller=&quot;MainCntl&quot;&gt;
           Choose:
           &lt;a href=&quot;Book/Moby&quot;&gt;Moby&lt;/a&gt; |
           &lt;a href=&quot;Book/Moby/ch/1&quot;&gt;Moby: Ch1&lt;/a&gt; |
           &lt;a href=&quot;Book/Gatsby&quot;&gt;Gatsby&lt;/a&gt; |
           &lt;a href=&quot;Book/Gatsby/ch/4?key=value&quot;&gt;Gatsby: Ch4&lt;/a&gt; |
           &lt;a href=&quot;Book/Scarlet&quot;&gt;Scarlet Letter&lt;/a&gt;&lt;br/&gt;

           &lt;div ng-view&gt;&lt;/div&gt;
           &lt;hr /&gt;

           &lt;pre&gt;$location.path() = {{$location.path()}}&lt;/pre&gt;
           &lt;pre&gt;$route.current.templateUrl = {{$route.current.templateUrl}}&lt;/pre&gt;
           &lt;pre&gt;$route.current.params = {{$route.current.params}}&lt;/pre&gt;
           &lt;pre&gt;$route.current.scope.name = {{$route.current.scope.name}}&lt;/pre&gt;
           &lt;pre&gt;$routeParams = {{$routeParams}}&lt;/pre&gt;
         &lt;/div&gt;
       &lt;/file&gt;

       &lt;file name=&quot;book.html&quot;&gt;
         controller: {{name}}&lt;br /&gt;
         Book Id: {{params.bookId}}&lt;br /&gt;
       &lt;/file&gt;

       &lt;file name=&quot;chapter.html&quot;&gt;
         controller: {{name}}&lt;br /&gt;
         Book Id: {{params.bookId}}&lt;br /&gt;
         Chapter Id: {{params.chapterId}}
       &lt;/file&gt;

       &lt;file name=&quot;script.js&quot;&gt;
         angular.module(&#x27;ngView&#x27;, [], function($routeProvider, $locationProvider) {
           $routeProvider.when(&#x27;/Book/:bookId&#x27;, {
             templateUrl: &#x27;book.html&#x27;,
             controller: BookCntl,
             resolve: {
               // I will cause a 1 second delay
               delay: function($q, $timeout) {
                 var delay = $q.defer();
                 $timeout(delay.resolve, 1000);
                 return delay.promise;
               }
             }
           });
           $routeProvider.when(&#x27;/Book/:bookId/ch/:chapterId&#x27;, {
             templateUrl: &#x27;chapter.html&#x27;,
             controller: ChapterCntl
           });

           // configure html5 to get links working on jsfiddle
           $locationProvider.html5Mode(true);
         });

         function MainCntl($scope, $route, $routeParams, $location) {
           $scope.$route = $route;
           $scope.$location = $location;
           $scope.$routeParams = $routeParams;
         }

         function BookCntl($scope, $routeParams) {
           $scope.name = &quot;BookCntl&quot;;
           $scope.params = $routeParams;
         }

         function ChapterCntl($scope, $routeParams) {
           $scope.name = &quot;ChapterCntl&quot;;
           $scope.params = $routeParams;
         }
       &lt;/file&gt;

       &lt;file name=&quot;scenario.js&quot;&gt;
         it(&#x27;should load and compile correct template&#x27;, function() {
           element(&#x27;a:contains(&quot;Moby: Ch1&quot;)&#x27;).click();
           var content = element(&#x27;.doc-example-live [ng-view]&#x27;).text();
           expect(content).toMatch(/controller\: ChapterCntl/);
           expect(content).toMatch(/Book Id\: Moby/);
           expect(content).toMatch(/Chapter Id\: 1/);

           element(&#x27;a:contains(&quot;Scarlet&quot;)&#x27;).click();
           sleep(2); // promises are not part of scenario waiting
           content = element(&#x27;.doc-example-live [ng-view]&#x27;).text();
           expect(content).toMatch(/controller\: BookCntl/);
           expect(content).toMatch(/Book Id\: Scarlet/);
         });
       &lt;/file&gt;
     &lt;/example&gt;
     */

    /**
     * @ngdoc event
     * @name ng.$route#$routeChangeStart
     * @eventOf ng.$route
     * @eventType broadcast on root scope
     * @description
     * Broadcasted before a route change. At this  point the route services starts
     * resolving all of the dependencies needed for the route change to occurs.
     * Typically this involves fetching the view template as well as any dependencies
     * defined in &#x60;resolve&#x60; route property. Once  all of the dependencies are resolved
     * &#x60;$routeChangeSuccess&#x60; is fired.
     *
     * @param {Route} next Future route information.
     * @param {Route} current Current route information.
     */

    /**
     * @ngdoc event
     * @name ng.$route#$routeChangeSuccess
     * @eventOf ng.$route
     * @eventType broadcast on root scope
     * @description
     * Broadcasted after a route dependencies are resolved.
     * {@link ng.directive:ngView ngView} listens for the directive
     * to instantiate the controller and render the view.
     *
     * @param {Object} angularEvent Synthetic event object.
     * @param {Route} current Current route information.
     * @param {Route|Undefined} previous Previous route information, or undefined if current is first route entered.
     */

    /**
     * @ngdoc event
     * @name ng.$route#$routeChangeError
     * @eventOf ng.$route
     * @eventType broadcast on root scope
     * @description
     * Broadcasted if any of the resolve promises are rejected.
     *
     * @param {Route} current Current route information.
     * @param {Route} previous Previous route information.
     * @param {Route} rejection Rejection of the promise. Usually the error of the failed promise.
     */

    /**
     * @ngdoc event
     * @name ng.$route#$routeUpdate
     * @eventOf ng.$route
     * @eventType broadcast on root scope
     * @description
     *
     * The &#x60;reloadOnSearch&#x60; property has been set to false, and we are reusing the same
     * instance of the Controller.
     */

    var forceReload = false,
        $route = {
          routes: routes,

          /**
           * @ngdoc method
           * @name ng.$route#reload
           * @methodOf ng.$route
           *
           * @description
           * Causes &#x60;$route&#x60; service to reload the current route even if
           * {@link ng.$location $location} hasn&#x27;t changed.
           *
           * As a result of that, {@link ng.directive:ngView ngView}
           * creates new scope, reinstantiates the controller.
           */
          reload: function() {
            forceReload = true;
            $rootScope.$evalAsync(updateRoute);
          }
        };

    $rootScope.$on(&#x27;$locationChangeSuccess&#x27;, updateRoute);

    return $route;

    /////////////////////////////////////////////////////

    /**
     * @param on {string} current url
     * @param when {string} route when template to match the url against
     * @param whenProperties {Object} properties to define when&#x27;s matching behavior
     * @return {?Object}
     */
    function switchRouteMatcher(on, when, whenProperties) {
      // TODO(i): this code is convoluted and inefficient, we should construct the route matching
      //   regex only once and then reuse it

      // Escape regexp special characters.
      when = &#x27;^&#x27; + when.replace(/[-\/\\^$:*+?.()|[\]{}]/g, &quot;\\$&amp;&quot;) + &#x27;$&#x27;;

      var regex = &#x27;&#x27;,
          params = [],
          dst = {};

      var re = /\\([:*])(\w+)/g,
          paramMatch,
          lastMatchedIndex = 0;

      while ((paramMatch = re.exec(when)) !== null) {
        // Find each :param in &#x60;when&#x60; and replace it with a capturing group.
        // Append all other sections of when unchanged.
        regex += when.slice(lastMatchedIndex, paramMatch.index);
        switch(paramMatch[1]) {
          case &#x27;:&#x27;:
            regex += &#x27;([^\\/]*)&#x27;;
            break;
          case &#x27;*&#x27;:
            regex += &#x27;(.*)&#x27;;
            break;
        }
        params.push(paramMatch[2]);
        lastMatchedIndex = re.lastIndex;
      }
      // Append trailing path part.
      regex += when.substr(lastMatchedIndex);

      var match = on.match(new RegExp(regex, whenProperties.caseInsensitiveMatch ? &#x27;i&#x27; : &#x27;&#x27;));
      if (match) {
        forEach(params, function(name, index) {
          dst[name] = match[index + 1];
        });
      }
      return match ? dst : null;
    }

    function updateRoute() {
      var next = parseRoute(),
          last = $route.current;

      if (next &amp;&amp; last &amp;&amp; next.$$route === last.$$route
          &amp;&amp; equals(next.pathParams, last.pathParams) &amp;&amp; !next.reloadOnSearch &amp;&amp; !forceReload) {
        last.params = next.params;
        copy(last.params, $routeParams);
        $rootScope.$broadcast(&#x27;$routeUpdate&#x27;, last);
      } else if (next || last) {
        forceReload = false;
        $rootScope.$broadcast(&#x27;$routeChangeStart&#x27;, next, last);
        $route.current = next;
        if (next) {
          if (next.redirectTo) {
            if (isString(next.redirectTo)) {
              $location.path(interpolate(next.redirectTo, next.params)).search(next.params)
                       .replace();
            } else {
              $location.url(next.redirectTo(next.pathParams, $location.path(), $location.search()))
                       .replace();
            }
          }
        }

        $q.when(next).
          then(function() {
            if (next) {
              var locals = extend({}, next.resolve),
                  template;

              forEach(locals, function(value, key) {
                locals[key] = isString(value) ? $injector.get(value) : $injector.invoke(value);
              });

              if (isDefined(template = next.template)) {
                if (isFunction(template)) {
                  template = template(next.params);
                }
              } else if (isDefined(template = next.templateUrl)) {
                if (isFunction(template)) {
                  template = template(next.params);
                }
                if (isDefined(template)) {
                  next.loadedTemplateUrl = template;
                  template = $http.get(template, {cache: $templateCache}).
                      then(function(response) { return response.data; });
                }
              }
              if (isDefined(template)) {
                locals[&#x27;$template&#x27;] = template;
              }
              return $q.all(locals);
            }
          }).
          // after route change
          then(function(locals) {
            if (next == $route.current) {
              if (next) {
                next.locals = locals;
                copy(next.params, $routeParams);
              }
              $rootScope.$broadcast(&#x27;$routeChangeSuccess&#x27;, next, last);
            }
          }, function(error) {
            if (next == $route.current) {
              $rootScope.$broadcast(&#x27;$routeChangeError&#x27;, next, last, error);
            }
          });
      }
    }


    /**
     * @returns the current active route, by matching it against the URL
     */
    function parseRoute() {
      // Match a route
      var params, match;
      forEach(routes, function(route, path) {
        if (!match &amp;&amp; (params = switchRouteMatcher($location.path(), path, route))) {
          match = inherit(route, {
            params: extend({}, $location.search(), params),
            pathParams: params});
          match.$$route = route;
        }
      });
      // No route matched; fallback to &quot;otherwise&quot; route
      return match || routes[null] &amp;&amp; inherit(routes[null], {params: {}, pathParams:{}});
    }

    /**
     * @returns interpolation of the redirect path with the parameters
     */
    function interpolate(string, params) {
      var result = [];
      forEach((string||&#x27;&#x27;).split(&#x27;:&#x27;), function(segment, i) {
        if (i == 0) {
          result.push(segment);
        } else {
          var segmentMatch = segment.match(/(\w+)(.*)/);
          var key = segmentMatch[1];
          result.push(params[key]);
          result.push(segmentMatch[2] || &#x27;&#x27;);
          delete params[key];
        }
      });
      return result.join(&#x27;&#x27;);
    }
  }];
}

/**
 * @ngdoc object
 * @name ng.$routeParams
 * @requires $route
 *
 * @description
 * Current set of route parameters. The route parameters are a combination of the
 * {@link ng.$location $location} &#x60;search()&#x60;, and &#x60;path()&#x60;. The &#x60;path&#x60; parameters
 * are extracted when the {@link ng.$route $route} path is matched.
 *
 * In case of parameter name collision, &#x60;path&#x60; params take precedence over &#x60;search&#x60; params.
 *
 * The service guarantees that the identity of the &#x60;$routeParams&#x60; object will remain unchanged
 * (but its properties will likely change) even when a route change occurs.
 *
 * @example
 * &lt;pre&gt;
 *  // Given:
 *  // URL: http://server.com/index.html#/Chapter/1/Section/2?search=moby
 *  // Route: /Chapter/:chapterId/Section/:sectionId
 *  //
 *  // Then
 *  $routeParams ==&gt; {chapterId:1, sectionId:2, search:&#x27;moby&#x27;}
 * &lt;/pre&gt;
 */
function $RouteParamsProvider() {
  this.$get = valueFn({});
}

/**
 * DESIGN NOTES
 *
 * The design decisions behind the scope are heavily favored for speed and memory consumption.
 *
 * The typical use of scope is to watch the expressions, which most of the time return the same
 * value as last time so we optimize the operation.
 *
 * Closures construction is expensive in terms of speed as well as memory:
 *   - No closures, instead use prototypical inheritance for API
 *   - Internal state needs to be stored on scope directly, which means that private state is
 *     exposed as $$____ properties
 *
 * Loop operations are optimized by using while(count--) { ... }
 *   - this means that in order to keep the same order of execution as addition we have to add
 *     items to the array at the beginning (shift) instead of at the end (push)
 *
 * Child scopes are created and removed often
 *   - Using an array would be slow since inserts in middle are expensive so we use linked list
 *
 * There are few watches then a lot of observers. This is why you don&#x27;t want the observer to be
 * implemented in the same way as watch. Watch requires return of initialization function which
 * are expensive to construct.
 */


/**
 * @ngdoc object
 * @name ng.$rootScopeProvider
 * @description
 *
 * Provider for the $rootScope service.
 */

/**
 * @ngdoc function
 * @name ng.$rootScopeProvider#digestTtl
 * @methodOf ng.$rootScopeProvider
 * @description
 *
 * Sets the number of digest iterations the scope should attempt to execute before giving up and
 * assuming that the model is unstable.
 *
 * The current default is 10 iterations.
 *
 * @param {number} limit The number of digest iterations.
 */


/**
 * @ngdoc object
 * @name ng.$rootScope
 * @description
 *
 * Every application has a single root {@link ng.$rootScope.Scope scope}.
 * All other scopes are child scopes of the root scope. Scopes provide mechanism for watching the model and provide
 * event processing life-cycle. See {@link guide/scope developer guide on scopes}.
 */
function $RootScopeProvider(){
  var TTL = 10;

  this.digestTtl = function(value) {
    if (arguments.length) {
      TTL = value;
    }
    return TTL;
  };

  this.$get = [&#x27;$injector&#x27;, &#x27;$exceptionHandler&#x27;, &#x27;$parse&#x27;,
      function( $injector,   $exceptionHandler,   $parse) {

    /**
     * @ngdoc function
     * @name ng.$rootScope.Scope
     *
     * @description
     * A root scope can be retrieved using the {@link ng.$rootScope $rootScope} key from the
     * {@link AUTO.$injector $injector}. Child scopes are created using the
     * {@link ng.$rootScope.Scope#$new $new()} method. (Most scopes are created automatically when
     * compiled HTML template is executed.)
     *
     * Here is a simple scope snippet to show how you can interact with the scope.
     * &lt;pre&gt;
     * &lt;file src=&quot;./test/ng/rootScopeSpec.js&quot; tag=&quot;docs1&quot; /&gt;
     * &lt;/pre&gt;
     *
     * # Inheritance
     * A scope can inherit from a parent scope, as in this example:
     * &lt;pre&gt;
         var parent = $rootScope;
         var child = parent.$new();

         parent.salutation = &quot;Hello&quot;;
         child.name = &quot;World&quot;;
         expect(child.salutation).toEqual(&#x27;Hello&#x27;);

         child.salutation = &quot;Welcome&quot;;
         expect(child.salutation).toEqual(&#x27;Welcome&#x27;);
         expect(parent.salutation).toEqual(&#x27;Hello&#x27;);
     * &lt;/pre&gt;
     *
     *
     * @param {Object.&lt;string, function()&gt;=} providers Map of service factory which need to be provided
     *     for the current scope. Defaults to {@link ng}.
     * @param {Object.&lt;string, *&gt;=} instanceCache Provides pre-instantiated services which should
     *     append/override services provided by &#x60;providers&#x60;. This is handy when unit-testing and having
     *     the need to override a default service.
     * @returns {Object} Newly created scope.
     *
     */
    function Scope() {
      this.$id = nextUid();
      this.$$phase = this.$parent = this.$$watchers =
                     this.$$nextSibling = this.$$prevSibling =
                     this.$$childHead = this.$$childTail = null;
      this[&#x27;this&#x27;] = this.$root =  this;
      this.$$destroyed = false;
      this.$$asyncQueue = [];
      this.$$listeners = {};
      this.$$isolateBindings = {};
    }

    /**
     * @ngdoc property
     * @name ng.$rootScope.Scope#$id
     * @propertyOf ng.$rootScope.Scope
     * @returns {number} Unique scope ID (monotonically increasing alphanumeric sequence) useful for
     *   debugging.
     */


    Scope.prototype = {
      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$new
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Creates a new child {@link ng.$rootScope.Scope scope}.
       *
       * The parent scope will propagate the {@link ng.$rootScope.Scope#$digest $digest()} and
       * {@link ng.$rootScope.Scope#$digest $digest()} events. The scope can be removed from the scope
       * hierarchy using {@link ng.$rootScope.Scope#$destroy $destroy()}.
       *
       * {@link ng.$rootScope.Scope#$destroy $destroy()} must be called on a scope when it is desired for
       * the scope and its child scopes to be permanently detached from the parent and thus stop
       * participating in model change detection and listener notification by invoking.
       *
       * @param {boolean} isolate if true then the scope does not prototypically inherit from the
       *         parent scope. The scope is isolated, as it can not see parent scope properties.
       *         When creating widgets it is useful for the widget to not accidentally read parent
       *         state.
       *
       * @returns {Object} The newly created child scope.
       *
       */
      $new: function(isolate) {
        var Child,
            child;

        if (isFunction(isolate)) {
          // TODO: remove at some point
          throw Error(&#x27;API-CHANGE: Use $controller to instantiate controllers.&#x27;);
        }
        if (isolate) {
          child = new Scope();
          child.$root = this.$root;
        } else {
          Child = function() {}; // should be anonymous; This is so that when the minifier munges
            // the name it does not become random set of chars. These will then show up as class
            // name in the debugger.
          Child.prototype = this;
          child = new Child();
          child.$id = nextUid();
        }
        child[&#x27;this&#x27;] = child;
        child.$$listeners = {};
        child.$parent = this;
        child.$$watchers = child.$$nextSibling = child.$$childHead = child.$$childTail = null;
        child.$$prevSibling = this.$$childTail;
        if (this.$$childHead) {
          this.$$childTail.$$nextSibling = child;
          this.$$childTail = child;
        } else {
          this.$$childHead = this.$$childTail = child;
        }
        return child;
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$watch
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Registers a &#x60;listener&#x60; callback to be executed whenever the &#x60;watchExpression&#x60; changes.
       *
       * - The &#x60;watchExpression&#x60; is called on every call to {@link ng.$rootScope.Scope#$digest $digest()} and
       *   should return the value which will be watched. (Since {@link ng.$rootScope.Scope#$digest $digest()}
       *   reruns when it detects changes the &#x60;watchExpression&#x60; can execute multiple times per
       *   {@link ng.$rootScope.Scope#$digest $digest()} and should be idempotent.)
       * - The &#x60;listener&#x60; is called only when the value from the current &#x60;watchExpression&#x60; and the
       *   previous call to &#x60;watchExpression&#x60; are not equal (with the exception of the initial run,
       *   see below). The inequality is determined according to
       *   {@link angular.equals} function. To save the value of the object for later comparison, the
       *   {@link angular.copy} function is used. It also means that watching complex options will
       *   have adverse memory and performance implications.
       * - The watch &#x60;listener&#x60; may change the model, which may trigger other &#x60;listener&#x60;s to fire. This
       *   is achieved by rerunning the watchers until no changes are detected. The rerun iteration
       *   limit is 10 to prevent an infinite loop deadlock.
       *
       *
       * If you want to be notified whenever {@link ng.$rootScope.Scope#$digest $digest} is called,
       * you can register a &#x60;watchExpression&#x60; function with no &#x60;listener&#x60;. (Since &#x60;watchExpression&#x60;
       * can execute multiple times per {@link ng.$rootScope.Scope#$digest $digest} cycle when a change is
       * detected, be prepared for multiple calls to your listener.)
       *
       * After a watcher is registered with the scope, the &#x60;listener&#x60; fn is called asynchronously
       * (via {@link ng.$rootScope.Scope#$evalAsync $evalAsync}) to initialize the
       * watcher. In rare cases, this is undesirable because the listener is called when the result
       * of &#x60;watchExpression&#x60; didn&#x27;t change. To detect this scenario within the &#x60;listener&#x60; fn, you
       * can compare the &#x60;newVal&#x60; and &#x60;oldVal&#x60;. If these two values are identical (&#x60;===&#x60;) then the
       * listener was called due to initialization.
       *
       *
       * # Example
       * &lt;pre&gt;
           // let&#x27;s assume that scope was dependency injected as the $rootScope
           var scope = $rootScope;
           scope.name = &#x27;misko&#x27;;
           scope.counter = 0;

           expect(scope.counter).toEqual(0);
           scope.$watch(&#x27;name&#x27;, function(newValue, oldValue) { scope.counter = scope.counter + 1; });
           expect(scope.counter).toEqual(0);

           scope.$digest();
           // no variable change
           expect(scope.counter).toEqual(0);

           scope.name = &#x27;adam&#x27;;
           scope.$digest();
           expect(scope.counter).toEqual(1);
       * &lt;/pre&gt;
       *
       *
       *
       * @param {(function()|string)} watchExpression Expression that is evaluated on each
       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. A change in the return value triggers a
       *    call to the &#x60;listener&#x60;.
       *
       *    - &#x60;string&#x60;: Evaluated as {@link guide/expression expression}
       *    - &#x60;function(scope)&#x60;: called with current &#x60;scope&#x60; as a parameter.
       * @param {(function()|string)=} listener Callback called whenever the return value of
       *   the &#x60;watchExpression&#x60; changes.
       *
       *    - &#x60;string&#x60;: Evaluated as {@link guide/expression expression}
       *    - &#x60;function(newValue, oldValue, scope)&#x60;: called with current and previous values as parameters.
       *
       * @param {boolean=} objectEquality Compare object for equality rather than for reference.
       * @returns {function()} Returns a deregistration function for this listener.
       */
      $watch: function(watchExp, listener, objectEquality) {
        var scope = this,
            get = compileToFn(watchExp, &#x27;watch&#x27;),
            array = scope.$$watchers,
            watcher = {
              fn: listener,
              last: initWatchVal,
              get: get,
              exp: watchExp,
              eq: !!objectEquality
            };

        // in the case user pass string, we need to compile it, do we really need this ?
        if (!isFunction(listener)) {
          var listenFn = compileToFn(listener || noop, &#x27;listener&#x27;);
          watcher.fn = function(newVal, oldVal, scope) {listenFn(scope);};
        }

        if (typeof watchExp == &#x27;string&#x27; &amp;&amp; get.constant) {
          var originalFn = watcher.fn;
          watcher.fn = function(newVal, oldVal, scope) {
            originalFn.call(this, newVal, oldVal, scope);
            arrayRemove(array, watcher);
          };
        }

        if (!array) {
          array = scope.$$watchers = [];
        }
        // we use unshift since we use a while loop in $digest for speed.
        // the while loop reads in reverse order.
        array.unshift(watcher);

        return function() {
          arrayRemove(array, watcher);
        };
      },


      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$watchCollection
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Shallow watches the properties of an object and fires whenever any of the properties change
       * (for arrays this implies watching the array items, for object maps this implies watching the properties).
       * If a change is detected the &#x60;listener&#x60; callback is fired.
       *
       * - The &#x60;obj&#x60; collection is observed via standard $watch operation and is examined on every call to $digest() to
       *   see if any items have been added, removed, or moved.
       * - The &#x60;listener&#x60; is called whenever anything within the &#x60;obj&#x60; has changed. Examples include adding new items
       *   into the object or array, removing and moving items around.
       *
       *
       * # Example
       * &lt;pre&gt;
          $scope.names = [&#x27;igor&#x27;, &#x27;matias&#x27;, &#x27;misko&#x27;, &#x27;james&#x27;];
          $scope.dataCount = 4;

          $scope.$watchCollection(&#x27;names&#x27;, function(newNames, oldNames) {
            $scope.dataCount = newNames.length;
          });

          expect($scope.dataCount).toEqual(4);
          $scope.$digest();

          //still at 4 ... no changes
          expect($scope.dataCount).toEqual(4);

          $scope.names.pop();
          $scope.$digest();

          //now there&#x27;s been a change
          expect($scope.dataCount).toEqual(3);
       * &lt;/pre&gt;
       *
       *
       * @param {string|Function(scope)} obj Evaluated as {@link guide/expression expression}. The expression value
       *    should evaluate to an object or an array which is observed on each
       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. Any shallow change within the collection will trigger
       *    a call to the &#x60;listener&#x60;.
       *
       * @param {function(newCollection, oldCollection, scope)} listener a callback function that is fired with both
       *    the &#x60;newCollection&#x60; and &#x60;oldCollection&#x60; as parameters.
       *    The &#x60;newCollection&#x60; object is the newly modified data obtained from the &#x60;obj&#x60; expression and the
       *    &#x60;oldCollection&#x60; object is a copy of the former collection data.
       *    The &#x60;scope&#x60; refers to the current scope.
       *
       * @returns {function()} Returns a de-registration function for this listener. When the de-registration function is executed
       * then the internal watch operation is terminated.
       */
      $watchCollection: function(obj, listener) {
        var self = this;
        var oldValue;
        var newValue;
        var changeDetected = 0;
        var objGetter = $parse(obj);
        var internalArray = [];
        var internalObject = {};
        var oldLength = 0;

        function $watchCollectionWatch() {
          newValue = objGetter(self);
          var newLength, key;

          if (!isObject(newValue)) {
            if (oldValue !== newValue) {
              oldValue = newValue;
              changeDetected++;
            }
          } else if (isArrayLike(newValue)) {
            if (oldValue !== internalArray) {
              // we are transitioning from something which was not an array into array.
              oldValue = internalArray;
              oldLength = oldValue.length = 0;
              changeDetected++;
            }

            newLength = newValue.length;

            if (oldLength !== newLength) {
              // if lengths do not match we need to trigger change notification
              changeDetected++;
              oldValue.length = oldLength = newLength;
            }
            // copy the items to oldValue and look for changes.
            for (var i = 0; i &lt; newLength; i++) {
              if (oldValue[i] !== newValue[i]) {
                changeDetected++;
                oldValue[i] = newValue[i];
              }
            }
          } else {
            if (oldValue !== internalObject) {
              // we are transitioning from something which was not an object into object.
              oldValue = internalObject = {};
              oldLength = 0;
              changeDetected++;
            }
            // copy the items to oldValue and look for changes.
            newLength = 0;
            for (key in newValue) {
              if (newValue.hasOwnProperty(key)) {
                newLength++;
                if (oldValue.hasOwnProperty(key)) {
                  if (oldValue[key] !== newValue[key]) {
                    changeDetected++;
                    oldValue[key] = newValue[key];
                  }
                } else {
                  oldLength++;
                  oldValue[key] = newValue[key];
                  changeDetected++;
                }
              }
            }
            if (oldLength &gt; newLength) {
              // we used to have more keys, need to find them and destroy them.
              changeDetected++;
              for(key in oldValue) {
                if (oldValue.hasOwnProperty(key) &amp;&amp; !newValue.hasOwnProperty(key)) {
                  oldLength--;
                  delete oldValue[key];
                }
              }
            }
          }
          return changeDetected;
        }

        function $watchCollectionAction() {
          listener(newValue, oldValue, self);
        }

        return this.$watch($watchCollectionWatch, $watchCollectionAction);
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$digest
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Processes all of the {@link ng.$rootScope.Scope#$watch watchers} of the current scope and its children.
       * Because a {@link ng.$rootScope.Scope#$watch watcher}&#x27;s listener can change the model, the
       * &#x60;$digest()&#x60; keeps calling the {@link ng.$rootScope.Scope#$watch watchers} until no more listeners are
       * firing. This means that it is possible to get into an infinite loop. This function will throw
       * &#x60;&#x27;Maximum iteration limit exceeded.&#x27;&#x60; if the number of iterations exceeds 10.
       *
       * Usually you don&#x27;t call &#x60;$digest()&#x60; directly in
       * {@link ng.directive:ngController controllers} or in
       * {@link ng.$compileProvider#directive directives}.
       * Instead a call to {@link ng.$rootScope.Scope#$apply $apply()} (typically from within a
       * {@link ng.$compileProvider#directive directives}) will force a &#x60;$digest()&#x60;.
       *
       * If you want to be notified whenever &#x60;$digest()&#x60; is called,
       * you can register a &#x60;watchExpression&#x60; function  with {@link ng.$rootScope.Scope#$watch $watch()}
       * with no &#x60;listener&#x60;.
       *
       * You may have a need to call &#x60;$digest()&#x60; from within unit-tests, to simulate the scope
       * life-cycle.
       *
       * # Example
       * &lt;pre&gt;
           var scope = ...;
           scope.name = &#x27;misko&#x27;;
           scope.counter = 0;

           expect(scope.counter).toEqual(0);
           scope.$watch(&#x27;name&#x27;, function(newValue, oldValue) {
             scope.counter = scope.counter + 1;
           });
           expect(scope.counter).toEqual(0);

           scope.$digest();
           // no variable change
           expect(scope.counter).toEqual(0);

           scope.name = &#x27;adam&#x27;;
           scope.$digest();
           expect(scope.counter).toEqual(1);
       * &lt;/pre&gt;
       *
       */
      $digest: function() {
        var watch, value, last,
            watchers,
            asyncQueue = this.$$asyncQueue,
            length,
            dirty, ttl = TTL,
            next, current, target = this,
            watchLog = [],
            logIdx, logMsg;

        beginPhase(&#x27;$digest&#x27;);

        do { // &quot;while dirty&quot; loop
          dirty = false;
          current = target;

          while(asyncQueue.length) {
            try {
              current.$eval(asyncQueue.shift());
            } catch (e) {
              $exceptionHandler(e);
            }
          }

          do { // &quot;traverse the scopes&quot; loop
            if ((watchers = current.$$watchers)) {
              // process our watches
              length = watchers.length;
              while (length--) {
                try {
                  watch = watchers[length];
                  // Most common watches are on primitives, in which case we can short
                  // circuit it with === operator, only when === fails do we use .equals
                  if ((value = watch.get(current)) !== (last = watch.last) &amp;&amp;
                      !(watch.eq
                          ? equals(value, last)
                          : (typeof value == &#x27;number&#x27; &amp;&amp; typeof last == &#x27;number&#x27;
                             &amp;&amp; isNaN(value) &amp;&amp; isNaN(last)))) {
                    dirty = true;
                    watch.last = watch.eq ? copy(value) : value;
                    watch.fn(value, ((last === initWatchVal) ? value : last), current);
                    if (ttl &lt; 5) {
                      logIdx = 4 - ttl;
                      if (!watchLog[logIdx]) watchLog[logIdx] = [];
                      logMsg = (isFunction(watch.exp))
                          ? &#x27;fn: &#x27; + (watch.exp.name || watch.exp.toString())
                          : watch.exp;
                      logMsg += &#x27;; newVal: &#x27; + toJson(value) + &#x27;; oldVal: &#x27; + toJson(last);
                      watchLog[logIdx].push(logMsg);
                    }
                  }
                } catch (e) {
                  $exceptionHandler(e);
                }
              }
            }

            // Insanity Warning: scope depth-first traversal
            // yes, this code is a bit crazy, but it works and we have tests to prove it!
            // this piece should be kept in sync with the traversal in $broadcast
            if (!(next = (current.$$childHead || (current !== target &amp;&amp; current.$$nextSibling)))) {
              while(current !== target &amp;&amp; !(next = current.$$nextSibling)) {
                current = current.$parent;
              }
            }
          } while ((current = next));

          if(dirty &amp;&amp; !(ttl--)) {
            clearPhase();
            throw Error(TTL + &#x27; $digest() iterations reached. Aborting!\n&#x27; +
                &#x27;Watchers fired in the last 5 iterations: &#x27; + toJson(watchLog));
          }
        } while (dirty || asyncQueue.length);

        clearPhase();
      },


      /**
       * @ngdoc event
       * @name ng.$rootScope.Scope#$destroy
       * @eventOf ng.$rootScope.Scope
       * @eventType broadcast on scope being destroyed
       *
       * @description
       * Broadcasted when a scope and its children are being destroyed.
       */

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$destroy
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Removes the current scope (and all of its children) from the parent scope. Removal implies
       * that calls to {@link ng.$rootScope.Scope#$digest $digest()} will no longer
       * propagate to the current scope and its children. Removal also implies that the current
       * scope is eligible for garbage collection.
       *
       * The &#x60;$destroy()&#x60; is usually used by directives such as
       * {@link ng.directive:ngRepeat ngRepeat} for managing the
       * unrolling of the loop.
       *
       * Just before a scope is destroyed a &#x60;$destroy&#x60; event is broadcasted on this scope.
       * Application code can register a &#x60;$destroy&#x60; event handler that will give it chance to
       * perform any necessary cleanup.
       */
      $destroy: function() {
        // we can&#x27;t destroy the root scope or a scope that has been already destroyed
        if ($rootScope == this || this.$$destroyed) return;
        var parent = this.$parent;

        this.$broadcast(&#x27;$destroy&#x27;);
        this.$$destroyed = true;

        if (parent.$$childHead == this) parent.$$childHead = this.$$nextSibling;
        if (parent.$$childTail == this) parent.$$childTail = this.$$prevSibling;
        if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
        if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;

        // This is bogus code that works around Chrome&#x27;s GC leak
        // see: https://github.com/angular/angular.js/issues/1313#issuecomment-10378451
        this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead =
            this.$$childTail = null;
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$eval
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Executes the &#x60;expression&#x60; on the current scope returning the result. Any exceptions in the
       * expression are propagated (uncaught). This is useful when evaluating Angular expressions.
       *
       * # Example
       * &lt;pre&gt;
           var scope = ng.$rootScope.Scope();
           scope.a = 1;
           scope.b = 2;

           expect(scope.$eval(&#x27;a+b&#x27;)).toEqual(3);
           expect(scope.$eval(function(scope){ return scope.a + scope.b; })).toEqual(3);
       * &lt;/pre&gt;
       *
       * @param {(string|function())=} expression An angular expression to be executed.
       *
       *    - &#x60;string&#x60;: execute using the rules as defined in  {@link guide/expression expression}.
       *    - &#x60;function(scope)&#x60;: execute the function with the current &#x60;scope&#x60; parameter.
       *
       * @returns {*} The result of evaluating the expression.
       */
      $eval: function(expr, locals) {
        return $parse(expr)(this, locals);
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$evalAsync
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Executes the expression on the current scope at a later point in time.
       *
       * The &#x60;$evalAsync&#x60; makes no guarantees as to when the &#x60;expression&#x60; will be executed, only that:
       *
       *   - it will execute in the current script execution context (before any DOM rendering).
       *   - at least one {@link ng.$rootScope.Scope#$digest $digest cycle} will be performed after
       *     &#x60;expression&#x60; execution.
       *
       * Any exceptions from the execution of the expression are forwarded to the
       * {@link ng.$exceptionHandler $exceptionHandler} service.
       *
       * @param {(string|function())=} expression An angular expression to be executed.
       *
       *    - &#x60;string&#x60;: execute using the rules as defined in  {@link guide/expression expression}.
       *    - &#x60;function(scope)&#x60;: execute the function with the current &#x60;scope&#x60; parameter.
       *
       */
      $evalAsync: function(expr) {
        this.$$asyncQueue.push(expr);
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$apply
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * &#x60;$apply()&#x60; is used to execute an expression in angular from outside of the angular framework.
       * (For example from browser DOM events, setTimeout, XHR or third party libraries).
       * Because we are calling into the angular framework we need to perform proper scope life-cycle
       * of {@link ng.$exceptionHandler exception handling},
       * {@link ng.$rootScope.Scope#$digest executing watches}.
       *
       * ## Life cycle
       *
       * # Pseudo-Code of &#x60;$apply()&#x60;
       * &lt;pre&gt;
           function $apply(expr) {
             try {
               return $eval(expr);
             } catch (e) {
               $exceptionHandler(e);
             } finally {
               $root.$digest();
             }
           }
       * &lt;/pre&gt;
       *
       *
       * Scope&#x27;s &#x60;$apply()&#x60; method transitions through the following stages:
       *
       * 1. The {@link guide/expression expression} is executed using the
       *    {@link ng.$rootScope.Scope#$eval $eval()} method.
       * 2. Any exceptions from the execution of the expression are forwarded to the
       *    {@link ng.$exceptionHandler $exceptionHandler} service.
       * 3. The {@link ng.$rootScope.Scope#$watch watch} listeners are fired immediately after the expression
       *    was executed using the {@link ng.$rootScope.Scope#$digest $digest()} method.
       *
       *
       * @param {(string|function())=} exp An angular expression to be executed.
       *
       *    - &#x60;string&#x60;: execute using the rules as defined in {@link guide/expression expression}.
       *    - &#x60;function(scope)&#x60;: execute the function with current &#x60;scope&#x60; parameter.
       *
       * @returns {*} The result of evaluating the expression.
       */
      $apply: function(expr) {
        try {
          beginPhase(&#x27;$apply&#x27;);
          return this.$eval(expr);
        } catch (e) {
          $exceptionHandler(e);
        } finally {
          clearPhase();
          try {
            $rootScope.$digest();
          } catch (e) {
            $exceptionHandler(e);
            throw e;
          }
        }
      },

      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$on
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Listens on events of a given type. See {@link ng.$rootScope.Scope#$emit $emit} for discussion of
       * event life cycle.
       *
       * The event listener function format is: &#x60;function(event, args...)&#x60;. The &#x60;event&#x60; object
       * passed into the listener has the following attributes:
       *
       *   - &#x60;targetScope&#x60; - &#x60;{Scope}&#x60;: the scope on which the event was &#x60;$emit&#x60;-ed or &#x60;$broadcast&#x60;-ed.
       *   - &#x60;currentScope&#x60; - &#x60;{Scope}&#x60;: the current scope which is handling the event.
       *   - &#x60;name&#x60; - &#x60;{string}&#x60;: Name of the event.
       *   - &#x60;stopPropagation&#x60; - &#x60;{function=}&#x60;: calling &#x60;stopPropagation&#x60; function will cancel further event
       *     propagation (available only for events that were &#x60;$emit&#x60;-ed).
       *   - &#x60;preventDefault&#x60; - &#x60;{function}&#x60;: calling &#x60;preventDefault&#x60; sets &#x60;defaultPrevented&#x60; flag to true.
       *   - &#x60;defaultPrevented&#x60; - &#x60;{boolean}&#x60;: true if &#x60;preventDefault&#x60; was called.
       *
       * @param {string} name Event name to listen on.
       * @param {function(event, args...)} listener Function to call when the event is emitted.
       * @returns {function()} Returns a deregistration function for this listener.
       */
      $on: function(name, listener) {
        var namedListeners = this.$$listeners[name];
        if (!namedListeners) {
          this.$$listeners[name] = namedListeners = [];
        }
        namedListeners.push(listener);

        return function() {
          namedListeners[indexOf(namedListeners, listener)] = null;
        };
      },


      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$emit
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Dispatches an event &#x60;name&#x60; upwards through the scope hierarchy notifying the
       * registered {@link ng.$rootScope.Scope#$on} listeners.
       *
       * The event life cycle starts at the scope on which &#x60;$emit&#x60; was called. All
       * {@link ng.$rootScope.Scope#$on listeners} listening for &#x60;name&#x60; event on this scope get notified.
       * Afterwards, the event traverses upwards toward the root scope and calls all registered
       * listeners along the way. The event will stop propagating if one of the listeners cancels it.
       *
       * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed
       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.
       *
       * @param {string} name Event name to emit.
       * @param {...*} args Optional set of arguments which will be passed onto the event listeners.
       * @return {Object} Event object, see {@link ng.$rootScope.Scope#$on}
       */
      $emit: function(name, args) {
        var empty = [],
            namedListeners,
            scope = this,
            stopPropagation = false,
            event = {
              name: name,
              targetScope: scope,
              stopPropagation: function() {stopPropagation = true;},
              preventDefault: function() {
                event.defaultPrevented = true;
              },
              defaultPrevented: false
            },
            listenerArgs = concat([event], arguments, 1),
            i, length;

        do {
          namedListeners = scope.$$listeners[name] || empty;
          event.currentScope = scope;
          for (i=0, length=namedListeners.length; i&lt;length; i++) {

            // if listeners were deregistered, defragment the array
            if (!namedListeners[i]) {
              namedListeners.splice(i, 1);
              i--;
              length--;
              continue;
            }
            try {
              namedListeners[i].apply(null, listenerArgs);
              if (stopPropagation) return event;
            } catch (e) {
              $exceptionHandler(e);
            }
          }
          //traverse upwards
          scope = scope.$parent;
        } while (scope);

        return event;
      },


      /**
       * @ngdoc function
       * @name ng.$rootScope.Scope#$broadcast
       * @methodOf ng.$rootScope.Scope
       * @function
       *
       * @description
       * Dispatches an event &#x60;name&#x60; downwards to all child scopes (and their children) notifying the
       * registered {@link ng.$rootScope.Scope#$on} listeners.
       *
       * The event life cycle starts at the scope on which &#x60;$broadcast&#x60; was called. All
       * {@link ng.$rootScope.Scope#$on listeners} listening for &#x60;name&#x60; event on this scope get notified.
       * Afterwards, the event propagates to all direct and indirect scopes of the current scope and
       * calls all registered listeners along the way. The event cannot be canceled.
       *
       * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed
       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.
       *
       * @param {string} name Event name to broadcast.
       * @param {...*} args Optional set of arguments which will be passed onto the event listeners.
       * @return {Object} Event object, see {@link ng.$rootScope.Scope#$on}
       */
      $broadcast: function(name, args) {
        var target = this,
            current = target,
            next = target,
            event = {
              name: name,
              targetScope: target,
              preventDefault: function() {
                event.defaultPrevented = true;
              },
              defaultPrevented: false
            },
            listenerArgs = concat([event], arguments, 1),
            listeners, i, length;

        //down while you can, then up and next sibling or up and next sibling until back at root
        do {
          current = next;
          event.currentScope = current;
          listeners = current.$$listeners[name] || [];
          for (i=0, length = listeners.length; i&lt;length; i++) {
            // if listeners were deregistered, defragment the array
            if (!listeners[i]) {
              listeners.splice(i, 1);
              i--;
              length--;
              continue;
            }

            try {
              listeners[i].apply(null, listenerArgs);
            } catch(e) {
              $exceptionHandler(e);
            }
          }

          // Insanity Warning: scope depth-first traversal
          // yes, this code is a bit crazy, but it works and we have tests to prove it!
          // this piece should be kept in sync with the traversal in $digest
          if (!(next = (current.$$childHead || (current !== target &amp;&amp; current.$$nextSibling)))) {
            while(current !== target &amp;&amp; !(next = current.$$nextSibling)) {
              current = current.$parent;
            }
          }
        } while ((current = next));

        return event;
      }
    };

    var $rootScope = new Scope();

    return $rootScope;


    function beginPhase(phase) {
      if ($rootScope.$$phase) {
        throw Error($rootScope.$$phase + &#x27; already in progress&#x27;);
      }

      $rootScope.$$phase = phase;
    }

    function clearPhase() {
      $rootScope.$$phase = null;
    }

    function compileToFn(exp, name) {
      var fn = $parse(exp);
      assertArgFn(fn, name);
      return fn;
    }

    /**
     * function used as an initial value for watchers.
     * because it&#x27;s unique we can easily tell it apart from other values
     */
    function initWatchVal() {}
  }];
}

/**
 * !!! This is an undocumented &quot;private&quot; service !!!
 *
 * @name ng.$sniffer
 * @requires $window
 * @requires $document
 *
 * @property {boolean} history Does the browser support html5 history api ?
 * @property {boolean} hashchange Does the browser support hashchange event ?
 * @property {boolean} transitions Does the browser support CSS transition events ?
 * @property {boolean} animations Does the browser support CSS animation events ?
 *
 * @description
 * This is very simple implementation of testing browser&#x27;s features.
 */
function $SnifferProvider() {
  this.$get = [&#x27;$window&#x27;, &#x27;$document&#x27;, function($window, $document) {
    var eventSupport = {},
        android = int((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
        document = $document[0] || {},
        vendorPrefix,
        vendorRegex = /^(Moz|webkit|O|ms)(?=[A-Z])/,
        bodyStyle = document.body &amp;&amp; document.body.style,
        transitions = false,
        animations = false,
        match;

    if (bodyStyle) {
      for(var prop in bodyStyle) {
        if(match = vendorRegex.exec(prop)) {
          vendorPrefix = match[0];
          vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
          break;
        }
      }
      transitions = !!((&#x27;transition&#x27; in bodyStyle) || (vendorPrefix + &#x27;Transition&#x27; in bodyStyle));
      animations  = !!((&#x27;animation&#x27; in bodyStyle) || (vendorPrefix + &#x27;Animation&#x27; in bodyStyle));
    }


    return {
      // Android has history.pushState, but it does not update location correctly
      // so let&#x27;s not use the history API at all.
      // http://code.google.com/p/android/issues/detail?id=17471
      // https://github.com/angular/angular.js/issues/904
      history: !!($window.history &amp;&amp; $window.history.pushState &amp;&amp; !(android &lt; 4)),
      hashchange: &#x27;onhashchange&#x27; in $window &amp;&amp;
                  // IE8 compatible mode lies
                  (!document.documentMode || document.documentMode &gt; 7),
      hasEvent: function(event) {
        // IE9 implements &#x27;input&#x27; event it&#x27;s so fubared that we rather pretend that it doesn&#x27;t have
        // it. In particular the event is not fired when backspace or delete key are pressed or
        // when cut operation is performed.
        if (event == &#x27;input&#x27; &amp;&amp; msie == 9) return false;

        if (isUndefined(eventSupport[event])) {
          var divElm = document.createElement(&#x27;div&#x27;);
          eventSupport[event] = &#x27;on&#x27; + event in divElm;
        }

        return eventSupport[event];
      },
      csp: document.securityPolicy ? document.securityPolicy.isActive : false,
      vendorPrefix: vendorPrefix,
      transitions : transitions,
      animations : animations
    };
  }];
}

/**
 * @ngdoc object
 * @name ng.$window
 *
 * @description
 * A reference to the browser&#x27;s &#x60;window&#x60; object. While &#x60;window&#x60;
 * is globally available in JavaScript, it causes testability problems, because
 * it is a global variable. In angular we always refer to it through the
 * &#x60;$window&#x60; service, so it may be overridden, removed or mocked for testing.
 *
 * All expressions are evaluated with respect to current scope so they don&#x27;t
 * suffer from window globality.
 *
 * @example
   &lt;doc:example&gt;
     &lt;doc:source&gt;
       &lt;script&gt;
         function Ctrl($scope, $window) {
           $scope.$window = $window;
           $scope.greeting = &#x27;Hello, World!&#x27;;
         }
       &lt;/script&gt;
       &lt;div ng-controller=&quot;Ctrl&quot;&gt;
         &lt;input type=&quot;text&quot; ng-model=&quot;greeting&quot; /&gt;
         &lt;button ng-click=&quot;$window.alert(greeting)&quot;&gt;ALERT&lt;/button&gt;
       &lt;/div&gt;
     &lt;/doc:source&gt;
     &lt;doc:scenario&gt;
      it(&#x27;should display the greeting in the input box&#x27;, function() {
       input(&#x27;greeting&#x27;).enter(&#x27;Hello, E2E Tests&#x27;);
       // If we click the button it will block the test runner
       // element(&#x27;:button&#x27;).click();
      });
     &lt;/doc:scenario&gt;
   &lt;/doc:example&gt;
 */
function $WindowProvider(){
  this.$get = valueFn(window);
}

/**
 * Parse headers into key value object
 *
 * @param {string} headers Raw headers as a string
 * @returns {Object} Parsed headers as key value object
 */
function parseHeaders(headers) {
  var parsed = {}, key, val, i;

  if (!headers) return parsed;

  forEach(headers.split(&#x27;\n&#x27;), function(line) {
    i = line.indexOf(&#x27;:&#x27;);
    key = lowercase(trim(line.substr(0, i)));
    val = trim(line.substr(i + 1));

    if (key) {
      if (parsed[key]) {
        parsed[key] += &#x27;, &#x27; + val;
      } else {
        parsed[key] = val;
      }
    }
  });

  return parsed;
}


var IS_SAME_DOMAIN_URL_MATCH = /^(([^:]+):)?\/\/(\w+:{0,1}\w*@)?([\w\.-]*)?(:([0-9]+))?(.*)$/;


/**
 * Parse a request and location URL and determine whether this is a same-domain request.
 *
 * @param {string} requestUrl The url of the request.
 * @param {string} locationUrl The current browser location url.
 * @returns {boolean} Whether the request is for the same domain.
 */
function isSameDomain(requestUrl, locationUrl) {
  var match = IS_SAME_DOMAIN_URL_MATCH.exec(requestUrl);
  // if requestUrl is relative, the regex does not match.
  if (match == null) return true;

  var domain1 = {
      protocol: match[2],
      host: match[4],
      port: int(match[6]) || DEFAULT_PORTS[match[2]] || null,
      // IE8 sets unmatched groups to &#x27;&#x27; instead of undefined.
      relativeProtocol: match[2] === undefined || match[2] === &#x27;&#x27;
    };

  match = SERVER_MATCH.exec(locationUrl);
  var domain2 = {
      protocol: match[1],
      host: match[3],
      port: int(match[5]) || DEFAULT_PORTS[match[1]] || null
    };

  return (domain1.protocol == domain2.protocol || domain1.relativeProtocol) &amp;&amp;
         domain1.host == domain2.host &amp;&amp;
         (domain1.port == domain2.port || (domain1.relativeProtocol &amp;&amp;
             domain2.port == DEFAULT_PORTS[domain2.protocol]));
}


/**
 * Returns a function that provides access to parsed headers.
 *
 * Headers are lazy parsed when first requested.
 * @see parseHeaders
 *
 * @param {(string|Object)} headers Headers to provide access to.
 * @returns {function(string=)} Returns a getter function which if called with:
 *
 *   - if called with single an argument returns a single header value or null
 *   - if called with no arguments returns an object containing all headers.
 */
function headersGetter(headers) {
  var headersObj = isObject(headers) ? headers : undefined;

  return function(name) {
    if (!headersObj) headersObj =  parseHeaders(headers);

    if (name) {
      return headersObj[lowercase(name)] || null;
    }

    return headersObj;
  };
}


/**
 * Chain all given functions
 *
 * This function is used for both request and response transforming
 *
 * @param {*} data Data to transform.
 * @param {function(string=)} headers Http headers getter fn.
 * @param {(function|Array.&lt;function&gt;)} fns Function or an array of functions.
 * @returns {*} Transformed data.
 */
function transformData(data, headers, fns) {
  if (isFunction(fns))
    return fns(data, headers);

  forEach(fns, function(fn) {
    data = fn(data, headers);
  });

  return data;
}


function isSuccess(status) {
  return 200 &lt;= status &amp;&amp; status &lt; 300;
}


function $HttpProvider() {
  var JSON_START = /^\s*(\[|\{[^\{])/,
      JSON_END = /[\}\]]\s*$/,
      PROTECTION_PREFIX = /^\)\]\}&#x27;,?\n/,
      CONTENT_TYPE_APPLICATION_JSON = {&#x27;Content-Type&#x27;: &#x27;application/json;charset=utf-8&#x27;};

  var defaults = this.defaults = {
    // transform incoming response data
    transformResponse: [function(data) {
      if (isString(data)) {
        // strip json vulnerability protection prefix
        data = data.replace(PROTECTION_PREFIX, &#x27;&#x27;);
        if (JSON_START.test(data) &amp;&amp; JSON_END.test(data))
          data = fromJson(data, true);
      }
      return data;
    }],

    // transform outgoing request data
    transformRequest: [function(d) {
      return isObject(d) &amp;&amp; !isFile(d) ? toJson(d) : d;
    }],

    // default headers
    headers: {
      common: {
        &#x27;Accept&#x27;: &#x27;application/json, text/plain, */*&#x27;
      },
      post:   CONTENT_TYPE_APPLICATION_JSON,
      put:    CONTENT_TYPE_APPLICATION_JSON,
      patch:  CONTENT_TYPE_APPLICATION_JSON
    },

    xsrfCookieName: &#x27;XSRF-TOKEN&#x27;,
    xsrfHeaderName: &#x27;X-XSRF-TOKEN&#x27;
  };

  /**
   * Are order by request. I.E. they are applied in the same order as
   * array on request, but revers order on response.
   */
  var interceptorFactories = this.interceptors = [];
  /**
   * For historical reasons, response interceptors ordered by the order in which
   * they are applied to response. (This is in revers to interceptorFactories)
   */
  var responseInterceptorFactories = this.responseInterceptors = [];

  this.$get = [&#x27;$httpBackend&#x27;, &#x27;$browser&#x27;, &#x27;$cacheFactory&#x27;, &#x27;$rootScope&#x27;, &#x27;$q&#x27;, &#x27;$injector&#x27;,
      function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {

    var defaultCache = $cacheFactory(&#x27;$http&#x27;);

    /**
     * Interceptors stored in reverse order. Inner interceptors before outer interceptors.
     * The reversal is needed so that we can build up the interception chain around the
     * server request.
     */
    var reversedInterceptors = [];

    forEach(interceptorFactories, function(interceptorFactory) {
      reversedInterceptors.unshift(isString(interceptorFactory)
          ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
    });

    forEach(responseInterceptorFactories, function(interceptorFactory, index) {
      var responseFn = isString(interceptorFactory)
          ? $injector.get(interceptorFactory)
          : $injector.invoke(interceptorFactory);

      /**
       * Response interceptors go before &quot;around&quot; interceptors (no real reason, just
       * had to pick one.) But they are already revesed, so we can&#x27;t use unshift, hence
       * the splice.
       */
      reversedInterceptors.splice(index, 0, {
        response: function(response) {
          return responseFn($q.when(response));
        },
        responseError: function(response) {
          return responseFn($q.reject(response));
        }
      });
    });


    /**
     * @ngdoc function
     * @name ng.$http
     * @requires $httpBackend
     * @requires $browser
     * @requires $cacheFactory
     * @requires $rootScope
     * @requires $q
     * @requires $injector
     *
     * @description
     * The &#x60;$http&#x60; service is a core Angular service that facilitates communication with the remote
     * HTTP servers via the browser&#x27;s {@link https://developer.mozilla.org/en/xmlhttprequest
     * XMLHttpRequest} object or via {@link http://en.wikipedia.org/wiki/JSONP JSONP}.
     *
     * For unit testing applications that use &#x60;$http&#x60; service, see
     * {@link ngMock.$httpBackend $httpBackend mock}.
     *
     * For a higher level of abstraction, please check out the {@link ngResource.$resource
     * $resource} service.
     *
     * The $http API is based on the {@link ng.$q deferred/promise APIs} exposed by
     * the $q service. While for simple usage patterns this doesn&#x27;t matter much, for advanced usage
     * it is important to familiarize yourself with these APIs and the guarantees they provide.
     *
     *
     * # General usage
     * The &#x60;$http&#x60; service is a function which takes a single argument  a configuration object 
     * that is used to generate an HTTP request and returns  a {@link ng.$q promise}
     * with two $http specific methods: &#x60;success&#x60; and &#x60;error&#x60;.
     *
     * &lt;pre&gt;
     *   $http({method: &#x27;GET&#x27;, url: &#x27;/someUrl&#x27;}).
     *     success(function(data, status, headers, config) {
     *       // this callback will be called asynchronously
     *       // when the response is available
     *     }).
     *     error(function(data, status, headers, config) {
     *       // called asynchronously if an error occurs
     *       // or server returns response with an error status.
     *     });
     * &lt;/pre&gt;
     *
     * Since the returned value of calling the $http function is a &#x60;promise&#x60;, you can also use
     * the &#x60;then&#x60; method to register callbacks, and these callbacks will receive a single argument 
     * an object representing the response. See the API signature and type info below for more
     * details.
     *
     * A response status code between 200 and 299 is considered a success status and
     * will result in the success callback being called. Note that if the response is a redirect,
     * XMLHttpRequest will transparently follow it, meaning that the error callback will not be
     * called for such responses.
     *
     * # Shortcut methods
     *
     * Since all invocations of the $http service require passing in an HTTP method and URL, and
     * POST/PUT requests require request data to be provided as well, shortcut methods
     * were created:
     *
     * &lt;pre&gt;
     *   $http.get(&#x27;/someUrl&#x27;).success(successCallback);
     *   $http.post(&#x27;/someUrl&#x27;, data).success(successCallback);
     * &lt;/pre&gt;
     *
     * Complete list of shortcut methods:
     *
     * - {@link ng.$http#get $http.get}
     * - {@link ng.$http#head $http.head}
     * - {@link ng.$http#post $http.post}
     * - {@link ng.$http#put $http.put}
     * - {@link ng.$http#delete $http.delete}
     * - {@link ng.$http#jsonp $http.jsonp}
     *
     *
     * # Setting HTTP Headers
     *
     * The $http service will automatically add certain HTTP headers to all requests. These defaults
     * can be fully configured by accessing the &#x60;$httpProvider.defaults.headers&#x60; configuration
     * object, which currently contains this default configuration:
     *
     * - &#x60;$httpProvider.defaults.headers.common&#x60; (headers that are common for all requests):
     *   - &#x60;Accept: application/json, text/plain, * / *&#x60;
     * - &#x60;$httpProvider.defaults.headers.post&#x60;: (header defaults for POST requests)
     *   - &#x60;Content-Type: application/json&#x60;
     * - &#x60;$httpProvider.defaults.headers.put&#x60; (header defaults for PUT requests)
     *   - &#x60;Content-Type: application/json&#x60;
     *
     * To add or overwrite these defaults, simply add or remove a property from these configuration
     * objects. To add headers for an HTTP method other than POST or PUT, simply add a new object
     * with the lowercased HTTP method name as the key, e.g.
     * &#x60;$httpProvider.defaults.headers.get[&#x27;My-Header&#x27;]=&#x27;value&#x27;&#x60;.
     *
     * Additionally, the defaults can be set at runtime via the &#x60;$http.defaults&#x60; object in the same
     * fashion.
     *
     *
     * # Transforming Requests and Responses
     *
     * Both requests and responses can be transformed using transform functions. By default, Angular
     * applies these transformations:
     *
     * Request transformations:
     *
     * - If the &#x60;data&#x60; property of the request configuration object contains an object, serialize it into
     *   JSON format.
     *
     * Response transformations:
     *
     *  - If XSRF prefix is detected, strip it (see Security Considerations section below).
     *  - If JSON response is detected, deserialize it using a JSON parser.
     *
     * To globally augment or override the default transforms, modify the &#x60;$httpProvider.defaults.transformRequest&#x60; and
     * &#x60;$httpProvider.defaults.transformResponse&#x60; properties. These properties are by default an
     * array of transform functions, which allows you to &#x60;push&#x60; or &#x60;unshift&#x60; a new transformation function into the
     * transformation chain. You can also decide to completely override any default transformations by assigning your
     * transformation functions to these properties directly without the array wrapper.
     *
     * Similarly, to locally override the request/response transforms, augment the &#x60;transformRequest&#x60; and/or
     * &#x60;transformResponse&#x60; properties of the configuration object passed into &#x60;$http&#x60;.
     *
     *
     * # Caching
     *
     * To enable caching, set the configuration property &#x60;cache&#x60; to &#x60;true&#x60;. When the cache is
     * enabled, &#x60;$http&#x60; stores the response from the server in local cache. Next time the
     * response is served from the cache without sending a request to the server.
     *
     * Note that even if the response is served from cache, delivery of the data is asynchronous in
     * the same way that real requests are.
     *
     * If there are multiple GET requests for the same URL that should be cached using the same
     * cache, but the cache is not populated yet, only one request to the server will be made and
     * the remaining requests will be fulfilled using the response from the first request.
     *
     * A custom default cache built with $cacheFactory can be provided in $http.defaults.cache.
     * To skip it, set configuration property &#x60;cache&#x60; to &#x60;false&#x60;.
     *
     *
     * # Interceptors
     *
     * Before you start creating interceptors, be sure to understand the
     * {@link ng.$q $q and deferred/promise APIs}.
     *
     * For purposes of global error handling, authentication, or any kind of synchronous or
     * asynchronous pre-processing of request or postprocessing of responses, it is desirable to be
     * able to intercept requests before they are handed to the server and
     * responses before they are handed over to the application code that
     * initiated these requests. The interceptors leverage the {@link ng.$q
     * promise APIs} to fulfill this need for both synchronous and asynchronous pre-processing.
     *
     * The interceptors are service factories that are registered with the &#x60;$httpProvider&#x60; by
     * adding them to the &#x60;$httpProvider.interceptors&#x60; array. The factory is called and
     * injected with dependencies (if specified) and returns the interceptor.
     *
     * There are two kinds of interceptors (and two kinds of rejection interceptors):
     *
     *   * &#x60;request&#x60;: interceptors get called with http &#x60;config&#x60; object. The function is free to modify
     *     the &#x60;config&#x60; or create a new one. The function needs to return the &#x60;config&#x60; directly or as a
     *     promise.
     *   * &#x60;requestError&#x60;: interceptor gets called when a previous interceptor threw an error or resolved
     *      with a rejection.
     *   * &#x60;response&#x60;: interceptors get called with http &#x60;response&#x60; object. The function is free to modify
     *     the &#x60;response&#x60; or create a new one. The function needs to return the &#x60;response&#x60; directly or as a
     *     promise.
     *   * &#x60;responseError&#x60;: interceptor gets called when a previous interceptor threw an error or resolved
     *      with a rejection.
     *
     *
     * &lt;pre&gt;
     *   // register the interceptor as a service
     *   $provide.factory(&#x27;myHttpInterceptor&#x27;, function($q, dependency1, dependency2) {
     *     return {
     *       // optional method
     *       &#x27;request&#x27;: function(config) {
     *         // do something on success
     *         return config || $q.when(config);
     *       },
     *
     *       // optional method
     *      &#x27;requestError&#x27;: function(rejection) {
     *         // do something on error
     *         if (canRecover(rejection)) {
     *           return responseOrNewPromise
     *         }
     *         return $q.reject(rejection);
     *       },
     *
     *
     *
     *       // optional method
     *       &#x27;response&#x27;: function(response) {
     *         // do something on success
     *         return response || $q.when(response);
     *       },
     *
     *       // optional method
     *      &#x27;responseError&#x27;: function(rejection) {
     *         // do something on error
     *         if (canRecover(rejection)) {
     *           return responseOrNewPromise
     *         }
     *         return $q.reject(rejection);
     *       };
     *     }
     *   });
     *
     *   $httpProvider.interceptors.push(&#x27;myHttpInterceptor&#x27;);
     *
     *
     *   // register the interceptor via an anonymous factory
     *   $httpProvider.interceptors.push(function($q, dependency1, dependency2) {
     *     return {
     *      &#x27;request&#x27;: function(config) {
     *          // same as above
     *       },
     *       &#x27;response&#x27;: function(response) {
     *          // same as above
     *       }
     *   });
     * &lt;/pre&gt;
     *
     * # Response interceptors (DEPRECATED)
     *
     * Before you start creating interceptors, be sure to understand the
     * {@link ng.$q $q and deferred/promise APIs}.
     *
     * For purposes of global error handling, authentication or any kind of synchronous or
     * asynchronous preprocessing of received responses, it is desirable to be able to intercept
     * responses for http requests before they are handed over to the application code that
     * initiated these requests. The response interceptors leverage the {@link ng.$q
     * promise apis} to fulfil this need for both synchronous and asynchronous preprocessing.
     *
     * The interceptors are service factories that are registered with the $httpProvider by
     * adding them to the &#x60;$httpProvider.responseInterceptors&#x60; array. The factory is called and
     * injected with dependencies (if specified) and returns the interceptor   a function that
     * takes a {@link ng.$q promise} and returns the original or a new promise.
     *
     * &lt;pre&gt;
     *   // register the interceptor as a service
     *   $provide.factory(&#x27;myHttpInterceptor&#x27;, function($q, dependency1, dependency2) {
     *     return function(promise) {
     *       return promise.then(function(response) {
     *         // do something on success
     *       }, function(response) {
     *         // do something on error
     *         if (canRecover(response)) {
     *           return responseOrNewPromise
     *         }
     *         return $q.reject(response);
     *       });
     *     }
     *   });
     *
     *   $httpProvider.responseInterceptors.push(&#x27;myHttpInterceptor&#x27;);
     *
     *
     *   // register the interceptor via an anonymous factory
     *   $httpProvider.responseInterceptors.push(function($q, dependency1, dependency2) {
     *     return function(promise) {
     *       // same as above
     *     }
     *   });
     * &lt;/pre&gt;
     *
     *
     * # Security Considerations
     *
     * When designing web applications, consider security threats from:
     *
     * - {@link http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx
     *   JSON vulnerability}
     * - {@link http://en.wikipedia.org/wiki/Cross-site_request_forgery XSRF}
     *
     * Both server and the client must cooperate in order to eliminate these threats. Angular comes
     * pre-configured with strategies that address these issues, but for this to work backend server
     * cooperation is required.
     *
     * ## JSON Vulnerability Protection
     *
     * A {@link http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx
     * JSON vulnerability} allows third party website to turn your JSON resource URL into
     * {@link http://en.wikipedia.org/wiki/JSONP JSONP} request under some conditions. To
     * counter this your server can prefix all JSON requests with following string &#x60;&quot;)]}&#x27;,\n&quot;&#x60;.
     * Angular will automatically strip the prefix before processing it as JSON.
     *
     * For example if your server needs to return:
     * &lt;pre&gt;
     * [&#x27;one&#x27;,&#x27;two&#x27;]
     * &lt;/pre&gt;
     *
     * which is vulnerable to attack, your server can return:
     * &lt;pre&gt;
     * )]}&#x27;,
     * [&#x27;one&#x27;,&#x27;two&#x27;]
     * &lt;/pre&gt;
     *
     * Angular will strip the prefix, before processing the JSON.
     *
     *
     * ## Cross Site Request Forgery (XSRF) Protection
     *
     * {@link http://en.wikipedia.org/wiki/Cross-site_request_forgery XSRF} is a technique by which
     * an unauthorized site can gain your user&#x27;s private data. Angular provides a mechanism
     * to counter XSRF. When performing XHR requests, the $http service reads a token from a cookie
     * (by default, &#x60;XSRF-TOKEN&#x60;) and sets it as an HTTP header (&#x60;X-XSRF-TOKEN&#x60;). Since only
     * JavaScript that runs on your domain could read the cookie, your server can be assured that
     * the XHR came from JavaScript running on your domain. The header will not be set for
     * cross-domain requests.
     *
     * To take advantage of this, your server needs to set a token in a JavaScript readable session
     * cookie called &#x60;XSRF-TOKEN&#x60; on the first HTTP GET request. On subsequent XHR requests the
     * server can verify that the cookie matches &#x60;X-XSRF-TOKEN&#x60; HTTP header, and therefore be sure
     * that only JavaScript running on your domain could have sent the request. The token must be
     * unique for each user and must be verifiable by the server (to prevent the JavaScript from making
     * up its own tokens). We recommend that the token is a digest of your site&#x27;s authentication
     * cookie with a {@link https://en.wikipedia.org/wiki/Salt_(cryptography) salt} for added security.
     *
     * The name of the headers can be specified using the xsrfHeaderName and xsrfCookieName
     * properties of either $httpProvider.defaults, or the per-request config object.
     *
     *
     * @param {object} config Object describing the request to be made and how it should be
     *    processed. The object has following properties:
     *
     *    - **method**  &#x60;{string}&#x60;  HTTP method (e.g. &#x27;GET&#x27;, &#x27;POST&#x27;, etc)
     *    - **url**  &#x60;{string}&#x60;  Absolute or relative URL of the resource that is being requested.
     *    - **params**  &#x60;{Object.&lt;string|Object&gt;}&#x60;  Map of strings or objects which will be turned to
     *      &#x60;?key1=value1&amp;key2=value2&#x60; after the url. If the value is not a string, it will be JSONified.
     *    - **data**  &#x60;{string|Object}&#x60;  Data to be sent as the request message data.
     *    - **headers**  &#x60;{Object}&#x60;  Map of strings representing HTTP headers to send to the server.
     *    - **xsrfHeaderName**  &#x60;{string}&#x60;  Name of HTTP header to populate with the XSRF token.
     *    - **xsrfCookieName**  &#x60;{string}&#x60;  Name of cookie containing the XSRF token.
     *    - **transformRequest**  &#x60;{function(data, headersGetter)|Array.&lt;function(data, headersGetter)&gt;}&#x60; 
     *      transform function or an array of such functions. The transform function takes the http
     *      request body and headers and returns its transformed (typically serialized) version.
     *    - **transformResponse**  &#x60;{function(data, headersGetter)|Array.&lt;function(data, headersGetter)&gt;}&#x60; 
     *      transform function or an array of such functions. The transform function takes the http
     *      response body and headers and returns its transformed (typically deserialized) version.
     *    - **cache**  &#x60;{boolean|Cache}&#x60;  If true, a default $http cache will be used to cache the
     *      GET request, otherwise if a cache instance built with
     *      {@link ng.$cacheFactory $cacheFactory}, this cache will be used for
     *      caching.
     *    - **timeout**  &#x60;{number|Promise}&#x60;  timeout in milliseconds, or {@link ng.$q promise}
     *      that should abort the request when resolved.
     *    - **withCredentials** - &#x60;{boolean}&#x60; - whether to to set the &#x60;withCredentials&#x60; flag on the
     *      XHR object. See {@link https://developer.mozilla.org/en/http_access_control#section_5
     *      requests with credentials} for more information.
     *    - **responseType** - &#x60;{string}&#x60; - see {@link
     *      https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType requestType}.
     *
     * @returns {HttpPromise} Returns a {@link ng.$q promise} object with the
     *   standard &#x60;then&#x60; method and two http specific methods: &#x60;success&#x60; and &#x60;error&#x60;. The &#x60;then&#x60;
     *   method takes two arguments a success and an error callback which will be called with a
     *   response object. The &#x60;success&#x60; and &#x60;error&#x60; methods take a single argument - a function that
     *   will be called when the request succeeds or fails respectively. The arguments passed into
     *   these functions are destructured representation of the response object passed into the
     *   &#x60;then&#x60; method. The response object has these properties:
     *
     *   - **data**  &#x60;{string|Object}&#x60;  The response body transformed with the transform functions.
     *   - **status**  &#x60;{number}&#x60;  HTTP status code of the response.
     *   - **headers**  &#x60;{function([headerName])}&#x60;  Header getter function.
     *   - **config**  &#x60;{Object}&#x60;  The configuration object that was used to generate the request.
     *
     * @property {Array.&lt;Object&gt;} pendingRequests Array of config objects for currently pending
     *   requests. This is primarily meant to be used for debugging purposes.
     *
     *
     * @example
      &lt;example&gt;
        &lt;file name=&quot;index.html&quot;&gt;
          &lt;div ng-controller=&quot;FetchCtrl&quot;&gt;
            &lt;select ng-model=&quot;method&quot;&gt;
              &lt;option&gt;GET&lt;/option&gt;
              &lt;option&gt;JSONP&lt;/option&gt;
            &lt;/select&gt;
            &lt;input type=&quot;text&quot; ng-model=&quot;url&quot; size=&quot;80&quot;/&gt;
            &lt;button ng-click=&quot;fetch()&quot;&gt;fetch&lt;/button&gt;&lt;br&gt;
            &lt;button ng-click=&quot;updateModel(&#x27;GET&#x27;, &#x27;http-hello.html&#x27;)&quot;&gt;Sample GET&lt;/button&gt;
            &lt;button ng-click=&quot;updateModel(&#x27;JSONP&#x27;, &#x27;http://angularjs.org/greet.php?callback=JSON_CALLBACK&amp;name=Super%20Hero&#x27;)&quot;&gt;Sample JSONP&lt;/button&gt;
            &lt;button ng-click=&quot;updateModel(&#x27;JSONP&#x27;, &#x27;http://angularjs.org/doesntexist&amp;callback=JSON_CALLBACK&#x27;)&quot;&gt;Invalid JSONP&lt;/button&gt;
            &lt;pre&gt;http status code: {{status}}&lt;/pre&gt;
            &lt;pre&gt;http response data: {{data}}&lt;/pre&gt;
          &lt;/div&gt;
        &lt;/file&gt;
        &lt;file name=&quot;script.js&quot;&gt;
          function FetchCtrl($scope, $http, $templateCache) {
            $scope.method = &#x27;GET&#x27;;
            $scope.url = &#x27;http-hello.html&#x27;;

            $scope.fetch = function() {
              $scope.code = null;
              $scope.response = null;

              $http({method: $scope.method, url: $scope.url, cache: $templateCache}).
                success(function(data, status) {
                  $scope.status = status;
                  $scope.data = data;
                }).
                error(function(data, status) {
                  $scope.data = data || &quot;Request failed&quot;;
                  $scope.status = status;
              });
            };

            $scope.updateModel = function(method, url) {
              $scope.method = method;
              $scope.url = url;
            };
          }
        &lt;/file&gt;
        &lt;file name=&quot;http-hello.html&quot;&gt;
          Hello, $http!
        &lt;/file&gt;
        &lt;file name=&quot;scenario.js&quot;&gt;
          it(&#x27;should make an xhr GET request&#x27;, function() {
            element(&#x27;:button:contains(&quot;Sample GET&quot;)&#x27;).click();
            element(&#x27;:button:contains(&quot;fetch&quot;)&#x27;).click();
            expect(binding(&#x27;status&#x27;)).toBe(&#x27;200&#x27;);
            expect(binding(&#x27;data&#x27;)).toMatch(/Hello, \$http!/);
          });

          it(&#x27;should make a JSONP request to angularjs.org&#x27;, function() {
            element(&#x27;:button:contains(&quot;Sample JSONP&quot;)&#x27;).click();
            element(&#x27;:button:contains(&quot;fetch&quot;)&#x27;).click();
            expect(binding(&#x27;status&#x27;)).toBe(&#x27;200&#x27;);
            expect(binding(&#x27;data&#x27;)).toMatch(/Super Hero!/);
          });

          it(&#x27;should make JSONP request to invalid URL and invoke the error handler&#x27;,
              function() {
            element(&#x27;:button:contains(&quot;Invalid JSONP&quot;)&#x27;).click();
            element(&#x27;:button:contains(&quot;fetch&quot;)&#x27;).click();
            expect(binding(&#x27;status&#x27;)).toBe(&#x27;0&#x27;);
            expect(binding(&#x27;data&#x27;)).toBe(&#x27;Request failed&#x27;);
          });
        &lt;/file&gt;
      &lt;/example&gt;
     */
    function $http(requestConfig) {
      var config = {
        transformRequest: defaults.transformRequest,
        transformResponse: defaults.transformResponse
      };
      var headers = {};

      extend(config, requestConfig);
      config.headers = headers;
      config.method = uppercase(config.method);

      extend(headers,
          defaults.headers.common,
          defaults.headers[lowercase(config.method)],
          requestConfig.headers);

      var xsrfValue = isSameDomain(config.url, $browser.url())
          ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName]
          : undefined;
      if (xsrfValue) {
        headers[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;
      }


      var serverRequest = function(config) {
        var reqData = transformData(config.data, headersGetter(headers), config.transformRequest);

        // strip content-type if data is undefined
        if (isUndefined(config.data)) {
          delete headers[&#x27;Content-Type&#x27;];
        }

        if (isUndefined(config.withCredentials) &amp;&amp; !isUndefined(defaults.withCredentials)) {
          config.withCredentials = defaults.withCredentials;
        }

        // send request
        return sendReq(config, reqData, headers).then(transformResponse, transformResponse);
      };

      var chain = [serverRequest, undefined];
      var promise = $q.when(config);

      // apply interceptors
      forEach(reversedInterceptors, function(interceptor) {
        if (interceptor.request || interceptor.requestError) {
          chain.unshift(interceptor.request, interceptor.requestError);
        }
        if (interceptor.response || interceptor.responseError) {
          chain.push(interceptor.response, interceptor.responseError);
        }
      });

      while(chain.length) {
        var thenFn = chain.shift();
        var rejectFn = chain.shift();

        promise = promise.then(thenFn, rejectFn);
      }

      promise.success = function(fn) {
        promise.then(function(response) {
          fn(response.data, response.status, response.headers, config);
        });
        return promise;
      };

      promise.error = function(fn) {
        promise.then(null, function(response) {
          fn(response.data, response.status, response.headers, config);
        });
        return promise;
      };

      return promise;

      function transformResponse(response) {
        // make a copy since the response must be cacheable
        var resp = extend({}, response, {
          data: transformData(response.data, response.headers, config.transformResponse)
        });
        return (isSuccess(response.status))
          ? resp
          : $q.reject(resp);
      }
    }

    $http.pendingRequests = [];

    /**
     * @ngdoc method
     * @name ng.$http#get
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform &#x60;GET&#x60; request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */

    /**
     * @ngdoc method
     * @name ng.$http#delete
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform &#x60;DELETE&#x60; request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */

    /**
     * @ngdoc method
     * @name ng.$http#head
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform &#x60;HEAD&#x60; request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */

    /**
     * @ngdoc method
     * @name ng.$http#jsonp
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform &#x60;JSONP&#x60; request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request.
     *                     Should contain &#x60;JSON_CALLBACK&#x60; string.
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */
    createShortMethods(&#x27;get&#x27;, &#x27;delete&#x27;, &#x27;head&#x27;, &#x27;jsonp&#x27;);

    /**
     * @ngdoc method
     * @name ng.$http#post
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform &#x60;POST&#x60; request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request
     * @param {*} data Request content
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */

    /**
     * @ngdoc method
     * @name ng.$http#put
     * @methodOf ng.$http
     *
     * @description
     * Shortcut method to perform &#x60;PUT&#x60; request.
     *
     * @param {string} url Relative or absolute URL specifying the destination of the request
     * @param {*} data Request content
     * @param {Object=} config Optional configuration object
     * @returns {HttpPromise} Future object
     */
    createShortMethodsWithData(&#x27;post&#x27;, &#x27;put&#x27;);

        /**
         * @ngdoc property
         * @name ng.$http#defaults
         * @propertyOf ng.$http
         *
         * @description
         * Runtime equivalent of the &#x60;$httpProvider.defaults&#x60; property. Allows configuration of
         * default headers, withCredentials as well as request and response transformations.
         *
         * See &quot;Setting HTTP Headers&quot; and &quot;Transforming Requests and Responses&quot; sections above.
         */
    $http.defaults = defaults;


    return $http;


    function createShortMethods(names) {
      forEach(arguments, function(name) {
        $http[name] = function(url, config) {
          return $http(extend(config || {}, {
            method: name,
            url: url
          }));
        };
      });
    }


    function createShortMethodsWithData(name) {
      forEach(arguments, function(name) {
        $http[name] = function(url, data, config) {
          return $http(extend(config || {}, {
            method: name,
            url: url,
            data: data
          }));
        };
      });
    }


    /**
     * Makes the request.
     *
     * !!! ACCESSES CLOSURE VARS:
     * $httpBackend, defaults, $log, $rootScope, defaultCache, $http.pendingRequests
     */
    function sendReq(config, reqData, reqHeaders) {
      var deferred = $q.defer(),
          promise = deferred.promise,
          cache,
          cachedResp,
          url = buildUrl(config.url, config.params);

      $http.pendingRequests.push(config);
      promise.then(removePendingReq, removePendingReq);


      if ((config.cache || defaults.cache) &amp;&amp; config.cache !== false &amp;&amp; config.method == &#x27;GET&#x27;) {
        cache = isObject(config.cache) ? config.cache
              : isObject(defaults.cache) ? defaults.cache
              : defaultCache;
      }

      if (cache) {
        cachedResp = cache.get(url);
        if (cachedResp) {
          if (cachedResp.then) {
            // cached request has already been sent, but there is no response yet
            cachedResp.then(removePendingReq, removePendingReq);
            return cachedResp;
          } else {
            // serving from cache
            if (isArray(cachedResp)) {
              resolvePromise(cachedResp[1], cachedResp[0], copy(cachedResp[2]));
            } else {
              resolvePromise(cachedResp, 200, {});
            }
          }
        } else {
          // put the promise for the non-transformed response into cache as a placeholder
          cache.put(url, promise);
        }
      }

      // if we won&#x27;t have the response in cache, send the request to the backend
      if (!cachedResp) {
        $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout,
            config.withCredentials, config.responseType);
      }

      return promise;


      /**
       * Callback registered to $httpBackend():
       *  - caches the response if desired
       *  - resolves the raw $http promise
       *  - calls $apply
       */
      function done(status, response, headersString) {
        if (cache) {
          if (isSuccess(status)) {
            cache.put(url, [status, response, parseHeaders(headersString)]);
          } else {
            // remove promise from the cache
            cache.remove(url);
          }
        }

        resolvePromise(response, status, headersString);
        if (!$rootScope.$$phase) $rootScope.$apply();
      }


      /**
       * Resolves the raw $http promise.
       */
      function resolvePromise(response, status, headers) {
        // normalize internal statuses to 0
        status = Math.max(status, 0);

        (isSuccess(status) ? deferred.resolve : deferred.reject)({
          data: response,
          status: status,
          headers: headersGetter(headers),
          config: config
        });
      }


      function removePendingReq() {
        var idx = indexOf($http.pendingRequests, config);
        if (idx !== -1) $http.pendingRequests.splice(idx, 1);
      }
    }


    function buildUrl(url, params) {
          if (!params) return url;
          var parts = [];
          forEachSorted(params, function(value, key) {
            if (value == null || value == undefined) return;
            if (!isArray(value)) value = [value];

            forEach(value, function(v) {
              if (isObject(v)) {
                v = toJson(v);
              }
              parts.push(encodeUriQuery(key) + &#x27;=&#x27; +
                         encodeUriQuery(v));
            });
          });
          return url + ((url.indexOf(&#x27;?&#x27;) == -1) ? &#x27;?&#x27; : &#x27;&amp;&#x27;) + parts.join(&#x27;&amp;&#x27;);
        }


  }];
}

var XHR = window.XMLHttpRequest || function() {
  try { return new ActiveXObject(&quot;Msxml2.XMLHTTP.6.0&quot;); } catch (e1) {}
  try { return new ActiveXObject(&quot;Msxml2.XMLHTTP.3.0&quot;); } catch (e2) {}
  try { return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); } catch (e3) {}
  throw new Error(&quot;This browser does not support XMLHttpRequest.&quot;);
};


/**
 * @ngdoc object
 * @name ng.$httpBackend
 * @requires $browser
 * @requires $window
 * @requires $document
 *
 * @description
 * HTTP backend used by the {@link ng.$http service} that delegates to
 * XMLHttpRequest object or JSONP and deals with browser incompatibilities.
 *
 * You should never need to use this service directly, instead use the higher-level abstractions:
 * {@link ng.$http $http} or {@link ngResource.$resource $resource}.
 *
 * During testing this implementation is swapped with {@link ngMock.$httpBackend mock
 * $httpBackend} which can be trained with responses.
 */
function $HttpBackendProvider() {
  this.$get = [&#x27;$browser&#x27;, &#x27;$window&#x27;, &#x27;$document&#x27;, function($browser, $window, $document) {
    return createHttpBackend($browser, XHR, $browser.defer, $window.angular.callbacks,
        $document[0], $window.location.protocol.replace(&#x27;:&#x27;, &#x27;&#x27;));
  }];
}

function createHttpBackend($browser, XHR, $browserDefer, callbacks, rawDocument, locationProtocol) {
  // TODO(vojta): fix the signature
  return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
    var status;
    $browser.$$incOutstandingRequestCount();
    url = url || $browser.url();

    if (lowercase(method) == &#x27;jsonp&#x27;) {
      var callbackId = &#x27;_&#x27; + (callbacks.counter++).toString(36);
      callbacks[callbackId] = function(data) {
        callbacks[callbackId].data = data;
      };

      var jsonpDone = jsonpReq(url.replace(&#x27;JSON_CALLBACK&#x27;, &#x27;angular.callbacks.&#x27; + callbackId),
          function() {
        if (callbacks[callbackId].data) {
          completeRequest(callback, 200, callbacks[callbackId].data);
        } else {
          completeRequest(callback, status || -2);
        }
        delete callbacks[callbackId];
      });
    } else {
      var xhr = new XHR();
      xhr.open(method, url, true);
      forEach(headers, function(value, key) {
        if (value) xhr.setRequestHeader(key, value);
      });

      // In IE6 and 7, this might be called synchronously when xhr.send below is called and the
      // response is in the cache. the promise api will ensure that to the app code the api is
      // always async
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          var responseHeaders = xhr.getAllResponseHeaders();

          // TODO(vojta): remove once Firefox 21 gets released.
          // begin: workaround to overcome Firefox CORS http response headers bug
          // https://bugzilla.mozilla.org/show_bug.cgi?id=608735
          // Firefox already patched in nightly. Should land in Firefox 21.

          // CORS &quot;simple response headers&quot; http://www.w3.org/TR/cors/
          var value,
              simpleHeaders = [&quot;Cache-Control&quot;, &quot;Content-Language&quot;, &quot;Content-Type&quot;,
                                  &quot;Expires&quot;, &quot;Last-Modified&quot;, &quot;Pragma&quot;];
          if (!responseHeaders) {
            responseHeaders = &quot;&quot;;
            forEach(simpleHeaders, function (header) {
              var value = xhr.getResponseHeader(header);
              if (value) {
                  responseHeaders += header + &quot;: &quot; + value + &quot;\n&quot;;
              }
            });
          }
          // end of the workaround.

          // responseText is the old-school way of retrieving response (supported by IE8 &amp; 9)
          // response and responseType properties were introduced in XHR Level2 spec (supported by IE10)
          completeRequest(callback,
              status || xhr.status,
              (xhr.responseType ? xhr.response : xhr.responseText),
              responseHeaders);
        }
      };

      if (withCredentials) {
        xhr.withCredentials = true;
      }

      if (responseType) {
        xhr.responseType = responseType;
      }

      xhr.send(post || &#x27;&#x27;);
    }

    if (timeout &gt; 0) {
      var timeoutId = $browserDefer(timeoutRequest, timeout);
    } else if (timeout &amp;&amp; timeout.then) {
      timeout.then(timeoutRequest);
    }


    function timeoutRequest() {
      status = -1;
      jsonpDone &amp;&amp; jsonpDone();
      xhr &amp;&amp; xhr.abort();
    }

    function completeRequest(callback, status, response, headersString) {
      // URL_MATCH is defined in src/service/location.js
      var protocol = (url.match(SERVER_MATCH) || [&#x27;&#x27;, locationProtocol])[1];

      // cancel timeout and subsequent timeout promise resolution
      timeoutId &amp;&amp; $browserDefer.cancel(timeoutId);
      jsonpDone = xhr = null;

      // fix status code for file protocol (it&#x27;s always 0)
      status = (protocol == &#x27;file&#x27;) ? (response ? 200 : 404) : status;

      // normalize IE bug (http://bugs.jquery.com/ticket/1450)
      status = status == 1223 ? 204 : status;

      callback(status, response, headersString);
      $browser.$$completeOutstandingRequest(noop);
    }
  };

  function jsonpReq(url, done) {
    // we can&#x27;t use jQuery/jqLite here because jQuery does crazy shit with script elements, e.g.:
    // - fetches local scripts via XHR and evals them
    // - adds and immediately removes script elements from the document
    var script = rawDocument.createElement(&#x27;script&#x27;),
        doneWrapper = function() {
          rawDocument.body.removeChild(script);
          if (done) done();
        };

    script.type = &#x27;text/javascript&#x27;;
    script.src = url;

    if (msie) {
      script.onreadystatechange = function() {
        if (/loaded|complete/.test(script.readyState)) doneWrapper();
      };
    } else {
      script.onload = script.onerror = doneWrapper;
    }

    rawDocument.body.appendChild(script);
    return doneWrapper;
  }
}

/**
 * @ngdoc object
 * @name ng.$locale
 *
 * @description
 * $locale service provides localization rules for various Angular components. As of right now the
 * only public api is:
 *
 * * &#x60;id&#x60;  &#x60;{string}&#x60;  locale id formatted as &#x60;languageId-countryId&#x60; (e.g. &#x60;en-us&#x60;)
 */
function $LocaleProvider(){
  this.$get = function() {
    return {
      id: &#x27;en-us&#x27;,

      NUMBER_FORMATS: {
        DECIMAL_SEP: &#x27;.&#x27;,
        GROUP_SEP: &#x27;,&#x27;,
        PATTERNS: [
          { // Decimal Pattern
            minInt: 1,
            minFrac: 0,
            maxFrac: 3,
            posPre: &#x27;&#x27;,
            posSuf: &#x27;&#x27;,
            negPre: &#x27;-&#x27;,
            negSuf: &#x27;&#x27;,
            gSize: 3,
            lgSize: 3
          },{ //Currency Pattern
            minInt: 1,
            minFrac: 2,
            maxFrac: 2,
            posPre: &#x27;\u00A4&#x27;,
            posSuf: &#x27;&#x27;,
            negPre: &#x27;(\u00A4&#x27;,
            negSuf: &#x27;)&#x27;,
            gSize: 3,
            lgSize: 3
          }
        ],
        CURRENCY_SYM: &#x27;$&#x27;
      },

      DATETIME_FORMATS: {
        MONTH: &#x27;January,February,March,April,May,June,July,August,September,October,November,December&#x27;
                .split(&#x27;,&#x27;),
        SHORTMONTH:  &#x27;Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec&#x27;.split(&#x27;,&#x27;),
        DAY: &#x27;Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday&#x27;.split(&#x27;,&#x27;),
        SHORTDAY: &#x27;Sun,Mon,Tue,Wed,Thu,Fri,Sat&#x27;.split(&#x27;,&#x27;),
        AMPMS: [&#x27;AM&#x27;,&#x27;PM&#x27;],
        medium: &#x27;MMM d, y h:mm:ss a&#x27;,
        short: &#x27;M/d/yy h:mm a&#x27;,
        fullDate: &#x27;EEEE, MMMM d, y&#x27;,
        longDate: &#x27;MMMM d, y&#x27;,
        mediumDate: &#x27;MMM d, y&#x27;,
        shortDate: &#x27;M/d/yy&#x27;,
        mediumTime: &#x27;h:mm:ss a&#x27;,
        shortTime: &#x27;h:mm a&#x27;
      },

      pluralCat: function(num) {
        if (num === 1) {
          return &#x27;one&#x27;;
        }
        return &#x27;other&#x27;;
      }
    };
  };
}

function $TimeoutProvider() {
  this.$get = [&#x27;$rootScope&#x27;, &#x27;$browser&#x27;, &#x27;$q&#x27;, &#x27;$exceptionHandler&#x27;,
       function($rootScope,   $browser,   $q,   $exceptionHandler) {
    var deferreds = {};


     /**
      * @ngdoc function
      * @name ng.$timeout
      * @requires $browser
      *
      * @description
      * Angular&#x27;s wrapper for &#x60;window.setTimeout&#x60;. The &#x60;fn&#x60; function is wrapped into a try/catch
      * block and delegates any exceptions to
      * {@link ng.$exceptionHandler $exceptionHandler} service.
      *
      * The return value of registering a timeout function is a promise, which will be resolved when
      * the timeout is reached and the timeout function is executed.
      *
      * To cancel a timeout request, call &#x60;$timeout.cancel(promise)&#x60;.
      *
      * In tests you can use {@link ngMock.$timeout &#x60;$timeout.flush()&#x60;} to
      * synchronously flush the queue of deferred functions.
      *
      * @param {function()} fn A function, whose execution should be delayed.
      * @param {number=} [delay=0] Delay in milliseconds.
      * @param {boolean=} [invokeApply=true] If set to &#x60;false&#x60; skips model dirty checking, otherwise
      *   will invoke &#x60;fn&#x60; within the {@link ng.$rootScope.Scope#$apply $apply} block.
      * @returns {Promise} Promise that will be resolved when the timeout is reached. The value this
      *   promise will be resolved with is the return value of the &#x60;fn&#x60; function.
      */
    function timeout(fn, delay, invokeApply) {
      var deferred = $q.defer(),
          promise = deferred.promise,
          skipApply = (isDefined(invokeApply) &amp;&amp; !invokeApply),
          timeoutId, cleanup;

      timeoutId = $browser.defer(function() {
        try {
          deferred.resolve(fn());
        } catch(e) {
          deferred.reject(e);
          $exceptionHandler(e);
        }

        if (!skipApply) $rootScope.$apply();
      }, delay);

      cleanup = function() {
        delete deferreds[promise.$$timeoutId];
      };

      promise.$$timeoutId = timeoutId;
      deferreds[timeoutId] = deferred;
      promise.then(cleanup, cleanup);

      return promise;
    }


     /**
      * @ngdoc function
      * @name ng.$timeout#cancel
      * @methodOf ng.$timeout
      *
      * @description
      * Cancels a task associated with the &#x60;promise&#x60;. As a result of this, the promise will be
      * resolved with a rejection.
      *
      * @param {Promise=} promise Promise returned by the &#x60;$timeout&#x60; function.
      * @returns {boolean} Returns &#x60;true&#x60; if the task hasn&#x27;t executed yet and was successfully
      *   canceled.
      */
    timeout.cancel = function(promise) {
      if (promise &amp;&amp; promise.$$timeoutId in deferreds) {
        deferreds[promise.$$timeoutId].reject(&#x27;canceled&#x27;);
        return $browser.defer.cancel(promise.$$timeoutId);
      }
      return false;
    };

    return timeout;
  }];
}

/**
 * @ngdoc object
 * @name ng.$filterProvider
 * @description
 *
 * Filters are just functions which transform input to an output. However filters need to be Dependency Injected. To
 * achieve this a filter definition consists of a factory function which is annotated with dependencies and is
 * responsible for creating a filter function.
 *
 * &lt;pre&gt;
 *   // Filter registration
 *   function MyModule($provide, $filterProvider) {
 *     // create a service to demonstrate injection (not always needed)
 *     $provide.value(&#x27;greet&#x27;, function(name){
 *       return &#x27;Hello &#x27; + name + &#x27;!&#x27;;
 *     });
 *
 *     // register a filter factory which uses the
 *     // greet service to demonstrate DI.
 *     $filterProvider.register(&#x27;greet&#x27;, function(greet){
 *       // return the filter function which uses the greet service
 *       // to generate salutation
 *       return function(text) {
 *         // filters need to be forgiving so check input validity
 *         return text &amp;&amp; greet(text) || text;
 *       };
 *     });
 *   }
 * &lt;/pre&gt;
 *
 * The filter function is registered with the &#x60;$injector&#x60; under the filter name suffixe with &#x60;Filter&#x60;.
 * &lt;pre&gt;
 *   it(&#x27;should be the same instance&#x27;, inject(
 *     function($filterProvider) {
 *       $filterProvider.register(&#x27;reverse&#x27;, function(){
 *         return ...;
 *       });
 *     },
 *     function($filter, reverseFilter) {
 *       expect($filter(&#x27;reverse&#x27;)).toBe(reverseFilter);
 *     });
 * &lt;/pre&gt;
 *
 *
 * For more information about how angular filters work, and how to create your own filters, see
 * {@link guide/dev_guide.templates.filters Understanding Angular Filters} in the angular Developer
 * Guide.
 */
/**
 * @ngdoc method
 * @name ng.$filterProvider#register
 * @methodOf ng.$filterProvider
 * @description
 * Register filter factory function.
 *
 * @param {String} name Name of the filter.
 * @param {function} fn The filter factory function which is injectable.
 */


/**
 * @ngdoc function
 * @name ng.$filter
 * @function
 * @description
 * Filters are used for formatting data displayed to the user.
 *
 * The general syntax in templates is as follows:
 *
 *         {{ expression [| filter_name[:parameter_value] ... ] }}
 *
 * @param {String} name Name of the filter function to retrieve
 * @return {Function} the filter function
 */
$FilterProvider.$inject = [&#x27;$provide&#x27;];
function $FilterProvider($provide) {
  var suffix = &#x27;Filter&#x27;;

  function register(name, factory) {
    return $provide.factory(name + suffix, factory);
  }
  this.register = register;

  this.$get = [&#x27;$injector&#x27;, function($injector) {
    return function(name) {
      return $injector.get(name + suffix);
    }
  }];

  ////////////////////////////////////////

  register(&#x27;currency&#x27;, currencyFilter);
  register(&#x27;date&#x27;, dateFilter);
  register(&#x27;filter&#x27;, filterFilter);
  register(&#x27;json&#x27;, jsonFilter);
  register(&#x27;limitTo&#x27;, limitToFilter);
  register(&#x27;lowercase&#x27;, lowercaseFilter);
  register(&#x27;number&#x27;, numberFilter);
  register(&#x27;orderBy&#x27;, orderByFilter);
  register(&#x27;uppercase&#x27;, uppercaseFilter);
}

/**
 * @ngdoc filter
 * @name ng.filter:filter
 * @function
 *
 * @description
 * Selects a subset of items from &#x60;array&#x60; and returns it as a new array.
 *
 * Note: This function is used to augment the &#x60;Array&#x60; type in Angular expressions. See
 * {@link ng.$filter} for more information about Angular arrays.
 *
 * @param {Array} array The source array.
 * @param {string|Object|function()} expression The predicate to be used for selecting items from
 *   &#x60;array&#x60;.
 *
 *   Can be one of:
 *
 *   - &#x60;string&#x60;: Predicate that results in a substring match using the value of &#x60;expression&#x60;
 *     string. All strings or objects with string properties in &#x60;array&#x60; that contain this string
 *     will be returned. The predicate can be negated by prefixing the string with &#x60;!&#x60;.
 *
 *   - &#x60;Object&#x60;: A pattern object can be used to filter specific properties on objects contained
 *     by &#x60;array&#x60;. For example &#x60;{name:&quot;M&quot;, phone:&quot;1&quot;}&#x60; predicate will return an array of items
 *     which have property &#x60;name&#x60; containing &quot;M&quot; and property &#x60;phone&#x60; containing &quot;1&quot;. A special
 *     property name &#x60;$&#x60; can be used (as in &#x60;{$:&quot;text&quot;}&#x60;) to accept a match against any
 *     property of the object. That&#x27;s equivalent to the simple substring match with a &#x60;string&#x60;
 *     as described above.
 *
 *   - &#x60;function&#x60;: A predicate function can be used to write arbitrary filters. The function is
 *     called for each element of &#x60;array&#x60;. The final result is an array of those elements that
 *     the predicate returned true for.
 *
 * @param {function(expected, actual)|true|undefined} comparator Comparator which is used in
 *     determining if the expected value (from the filter expression) and actual value (from
 *     the object in the array) should be considered a match.
 *
 *   Can be one of:
 *
 *     - &#x60;function(expected, actual)&#x60;:
 *       The function will be given the object value and the predicate value to compare and
 *       should return true if the item should be included in filtered result.
 *
 *     - &#x60;true&#x60;: A shorthand for &#x60;function(expected, actual) { return angular.equals(expected, actual)}&#x60;.
 *       this is essentially strict comparison of expected and actual.
 *
 *     - &#x60;false|undefined&#x60;: A short hand for a function which will look for a substring match in case
 *       insensitive way.
 *
 * @example
   &lt;doc:example&gt;
     &lt;doc:source&gt;
       &lt;div ng-init=&quot;friends = [{name:&#x27;John&#x27;, phone:&#x27;555-1276&#x27;},
                                {name:&#x27;Mary&#x27;, phone:&#x27;800-BIG-MARY&#x27;},
                                {name:&#x27;Mike&#x27;, phone:&#x27;555-4321&#x27;},
                                {name:&#x27;Adam&#x27;, phone:&#x27;555-5678&#x27;},
                                {name:&#x27;Julie&#x27;, phone:&#x27;555-8765&#x27;},
                                {name:&#x27;Juliette&#x27;, phone:&#x27;555-5678&#x27;}]&quot;&gt;&lt;/div&gt;

       Search: &lt;input ng-model=&quot;searchText&quot;&gt;
       &lt;table id=&quot;searchTextResults&quot;&gt;
         &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Phone&lt;/th&gt;&lt;/tr&gt;
         &lt;tr ng-repeat=&quot;friend in friends | filter:searchText&quot;&gt;
           &lt;td&gt;{{friend.name}}&lt;/td&gt;
           &lt;td&gt;{{friend.phone}}&lt;/td&gt;
         &lt;/tr&gt;
       &lt;/table&gt;
       &lt;hr&gt;
       Any: &lt;input ng-model=&quot;search.$&quot;&gt; &lt;br&gt;
       Name only &lt;input ng-model=&quot;search.name&quot;&gt;&lt;br&gt;
       Phone only &lt;input ng-model=&quot;search.phone&quot;&gt;&lt;br&gt;
       Equality &lt;input type=&quot;checkbox&quot; ng-model=&quot;strict&quot;&gt;&lt;br&gt;
       &lt;table id=&quot;searchObjResults&quot;&gt;
         &lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Phone&lt;/th&gt;&lt;/tr&gt;
         &lt;tr ng-repeat=&quot;friend in friends | filter:search:strict&quot;&gt;
           &lt;td&gt;{{friend.name}}&lt;/td&gt;
           &lt;td&gt;{{friend.phone}}&lt;/td&gt;
         &lt;/tr&gt;
       &lt;/table&gt;
     &lt;/doc:source&gt;
     &lt;doc:scenario&gt;
       it(&#x27;should search across all fields when filtering with a string&#x27;, function() {
         input(&#x27;searchText&#x27;).enter(&#x27;m&#x27;);
         expect(repeater(&#x27;#searchTextResults tr&#x27;, &#x27;friend in friends&#x27;).column(&#x27;friend.name&#x27;)).
           toEqual([&#x27;Mary&#x27;, &#x27;Mike&#x27;, &#x27;Adam&#x27;]);

         input(&#x27;searchText&#x27;).enter(&#x27;76&#x27;);
         expect(repeater(&#x27;#searchTextResults tr&#x27;, &#x27;friend in friends&#x27;).column(&#x27;friend.name&#x27;)).
           toEqual([&#x27;John&#x27;, &#x27;Julie&#x27;]);
       });

       it(&#x27;should search in specific fields when filtering with a predicate object&#x27;, function() {
         input(&#x27;search.$&#x27;).enter(&#x27;i&#x27;);
         expect(repeater(&#x27;#searchObjResults tr&#x27;, &#x27;friend in friends&#x27;).column(&#x27;friend.name&#x27;)).
           toEqual([&#x27;Mary&#x27;, &#x27;Mike&#x27;, &#x27;Julie&#x27;, &#x27;Juliette&#x27;]);
       });
       it(&#x27;should use a equal comparison when comparator is true&#x27;, function() {
         input(&#x27;search.name&#x27;).enter(&#x27;Julie&#x27;);
         input(&#x27;strict&#x27;).check();
         expect(repeater(&#x27;#searchObjResults tr&#x27;, &#x27;friend in friends&#x27;).column(&#x27;friend.name&#x27;)).
           toEqual([&#x27;Julie&#x27;]);
       });
     &lt;/doc:scenario&gt;
   &lt;/doc:example&gt;
 */
function filterFilter() {
  return function(array, expression, comperator) {
    if (!isArray(array)) return array;
    var predicates = [];
    predicates.check = function(value) {
      for (var j = 0; j &lt; predicates.length; j++) {
        if(!predicates[j](value)) {
          return false;
        }
      }
      return true;
    };
    switch(typeof comperator) {
      case &quot;function&quot;:
        break;
      case &quot;boolean&quot;:
        if(comperator == true) {
          comperator = function(obj, text) {
            return angular.equals(obj, text);
          }
          break;
        }
      default:
        comperator = function(obj, text) {
          text = (&#x27;&#x27;+text).toLowerCase();
          return (&#x27;&#x27;+obj).toLowerCase().indexOf(text) &gt; -1
        };
    }
    var search = function(obj, text){
      if (typeof text == &#x27;string&#x27; &amp;&amp; text.charAt(0) === &#x27;!&#x27;) {
        return !search(obj, text.substr(1));
      }
      switch (typeof obj) {
        case &quot;boolean&quot;:
        case &quot;number&quot;:
        case &quot;string&quot;:
          return comperator(obj, text);
        case &quot;object&quot;:
          switch (typeof text) {
            case &quot;object&quot;:
              return comperator(obj, text);
              break;
            default:
              for ( var objKey in obj) {
                if (objKey.charAt(0) !== &#x27;$&#x27; &amp;&amp; search(obj[objKey], text)) {
                  return true;
                }
              }
              break;
          }
          return false;
        case &quot;array&quot;:
          for ( var i = 0; i &lt; obj.length; i++) {
            if (search(obj[i], text)) {
              return true;
            }
          }
          return false;
        default:
          return false;
      }
    };
    switch (typeof expression) {
      case &quot;boolean&quot;:
      case &quot;number&quot;:
      case &quot;string&quot;:
        expression = {$:expression};
      case &quot;object&quot;:
        for (var key in expression) {
          if (key == &#x27;$&#x27;) {
            (function() {
              if (!expression[key]) return;
              var path = key
              predicates.push(function(value) {
                return search(value, expression[path]);
              });
            })();
          } else {
            (function() {
              if (!expression[key]) return;
              var path = key;
              predicates.push(function(value) {
                return search(getter(value,path), expression[path]);
              });
            })();
          }
        }
        break;
      case &#x27;function&#x27;:
        predicates.push(expression);
        break;
      default:
        return array;
    }
    var filtered = [];
    for ( var j = 0; j &lt; array.length; j++) {
      var value = array[j];
      if (predicates.check(value)) {
        filtered.push(value);
      }
    }
    return filtered;
  }
}

/**
 * @ngdoc filter
 * @name ng.filter:currency
 * @function
 *
 * @description
 * Formats a number as a currency (ie $1,234.56). When no currency symbol is provided, default
 * symbol for current locale is used.
 *
 * @param {number} amount Input to filter.
 * @param {string=} symbol Currency symbol or identifier to be displayed.
 * @returns {string} Formatted number.
 *
 *
 * @example
   &lt;doc:example&gt;
     &lt;doc:source&gt;
       &lt;script&gt;
         function Ctrl($scope) {
           $scope.amount = 1234.56;
         }
       &lt;/script&gt;
       &lt;div ng-controller=&quot;Ctrl&quot;&gt;
         &lt;input type=&quot;number&quot; ng-model=&quot;amount&quot;&gt; &lt;br&gt;
         default currency symbol ($): {{amount | currency}}&lt;br&gt;
         custom currency identifier (USD$): {{amount | currency:&quot;USD$&quot;}}
       &lt;/div&gt;
     &lt;/doc:source&gt;
     &lt;doc:scenario&gt;
       it(&#x27;should init with 1234.56&#x27;, function() {
         expect(binding(&#x27;amount | currency&#x27;)).toBe(&#x27;$1,234.56&#x27;);
         expect(binding(&#x27;amount | currency:&quot;USD$&quot;&#x27;)).toBe(&#x27;USD$1,234.56&#x27;);
       });
       it(&#x27;should update&#x27;, function() {
         input(&#x27;amount&#x27;).enter(&#x27;-1234&#x27;);
         expect(binding(&#x27;amount | currency&#x27;)).toBe(&#x27;($1,234.00)&#x27;);
         expect(binding(&#x27;amount | currency:&quot;USD$&quot;&#x27;)).toBe(&#x27;(USD$1,234.00)&#x27;);
       });
     &lt;/doc:scenario&gt;
   &lt;/doc:example&gt;
 */
currencyFilter.$inject = [&#x27;$locale&#x27;];
function currencyFilter($locale) {
  var formats = $locale.NUMBER_FORMATS;
  return function(amount, currencySymbol){
    if (isUndefined(currencySymbol)) currencySymbol = formats.CURRENCY_SYM;
    return formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, 2).
                replace(/\u00A4/g, currencySymbol);
  };
}

/**
 * @ngdoc filter
 * @name ng.filter:number
 * @function
 *
 * @description
 * Formats a number as text.
 *
 * If the input is not a number an empty string is returned.
 *
 * @param {number|string} number Number to format.
 * @param {(number|string)=} [fractionSize=2] Number of decimal places to round the number to.
 * @returns {string} Number rounded to decimalPlaces and places a , after each third digit.
 *
 * @example
   &lt;doc:example&gt;
     &lt;doc:source&gt;
       &lt;script&gt;
         function Ctrl($scope) {
           $scope.val = 1234.56789;
         }
       &lt;/script&gt;
       &lt;div ng-controller=&quot;Ctrl&quot;&gt;
         Enter number: &lt;input ng-model=&#x27;val&#x27;&gt;&lt;br&gt;
         Default formatting: {{val | number}}&lt;br&gt;
         No fractions: {{val | number:0}}&lt;br&gt;
         Negative number: {{-val | number:4}}
       &lt;/div&gt;
     &lt;/doc:source&gt;
     &lt;doc:scenario&gt;
       it(&#x27;should format numbers&#x27;, function() {
         expect(binding(&#x27;val | number&#x27;)).toBe(&#x27;1,234.568&#x27;);
         expect(binding(&#x27;val | number:0&#x27;)).toBe(&#x27;1,235&#x27;);
         expect(binding(&#x27;-val | number:4&#x27;)).toBe(&#x27;-1,234.5679&#x27;);
       });

       it(&#x27;should update&#x27;, function() {
         input(&#x27;val&#x27;).enter(&#x27;3374.333&#x27;);
         expect(binding(&#x27;val | number&#x27;)).toBe(&#x27;3,374.333&#x27;);
         expect(binding(&#x27;val | number:0&#x27;)).toBe(&#x27;3,374&#x27;);
         expect(binding(&#x27;-val | number:4&#x27;)).toBe(&#x27;-3,374.3330&#x27;);
       });
     &lt;/doc:scenario&gt;
   &lt;/doc:example&gt;
 */


numberFilter.$inject = [&#x27;$locale&#x27;];
function numberFilter($locale) {
  var formats = $locale.NUMBER_FORMATS;
  return function(number, fractionSize) {
    return formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP,
      fractionSize);
  };
}

var DECIMAL_SEP = &#x27;.&#x27;;
function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
  if (isNaN(number) || !isFinite(number)) return &#x27;&#x27;;

  var isNegative = number &lt; 0;
  number = Math.abs(number);
  var numStr = number + &#x27;&#x27;,
      formatedText = &#x27;&#x27;,
      parts = [];

  var hasExponent = false;
  if (numStr.indexOf(&#x27;e&#x27;) !== -1) {
    var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
    if (match &amp;&amp; match[2] == &#x27;-&#x27; &amp;&amp; match[3] &gt; fractionSize + 1) {
      numStr = &#x27;0&#x27;;
    } else {
      formatedText = numStr;
      hasExponent = true;
    }
  }

  if (!hasExponent) {
    var fractionLen = (numStr.split(DECIMAL_SEP)[1] || &#x27;&#x27;).length;

    // determine fractionSize if it is not specified
    if (isUndefined(fractionSize)) {
      fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
    }

    var pow = Math.pow(10, fractionSize);
    number = Math.round(number * pow) / pow;
    var fraction = (&#x27;&#x27; + number).split(DECIMAL_SEP);
    var whole = fraction[0];
    fraction = fraction[1] || &#x27;&#x27;;

    var pos = 0,
        lgroup = pattern.lgSize,
        group = pattern.gSize;

    if (whole.length &gt;= (lgroup + group)) {
      pos = whole.length - lgroup;
      for (var i = 0; i &lt; pos; i++) {
        if ((pos - i)%group === 0 &amp;&amp; i !== 0) {
          formatedText += groupSep;
        }
        formatedText += whole.charAt(i);
      }
    }

    for (i = pos; i &lt; whole.length; i++) {
      if ((whole.length - i)%lgroup === 0 &amp;&amp; i !== 0) {
        formatedText += groupSep;
      }
      formatedText += whole.charAt(i);
    }

    // format fraction part.
    while(fraction.length &lt; fractionSize) {
      fraction += &#x27;0&#x27;;
    }

    if (fractionSize &amp;&amp; fractionSize !== &quot;0&quot;) formatedText += decimalSep + fraction.substr(0, fractionSize);
  }

  parts.push(isNegative ? pattern.negPre : pattern.posPre);
  parts.push(formatedText);
  parts.push(isNegative ? pattern.negSuf : pattern.posSuf);
  return parts.join(&#x27;&#x27;);
}

function padNumber(num, digits, trim) {
  var neg = &#x27;&#x27;;
  if (num &lt; 0) {
    neg =  &#x27;-&#x27;;
    num = -num;
  }
  num = &#x27;&#x27; + num;
  while(num.length &lt; digits) num = &#x27;0&#x27; + num;
  if (trim)
    num = num.substr(num.length - digits);
  return neg + num;
}


function dateGetter(name, size, offset, trim) {
  offset = offset || 0;
  return function(date) {
    var value = date[&#x27;get&#x27; + name]();
    if (offset &gt; 0 || value &gt; -offset)
      value += offset;
    if (value === 0 &amp;&amp; offset == -12 ) value = 12;
    return padNumber(value, size, trim);
  };
}

function dateStrGetter(name, shortForm) {
  return function(date, formats) {
    var value = date[&#x27;get&#x27; + name]();
    var get = uppercase(shortForm ? (&#x27;SHORT&#x27; + name) : name);

    return formats[get][value];
  };
}

function timeZoneGetter(date) {
  var zone = -1 * date.getTimezoneOffset();
  var paddedZone = (zone &gt;= 0) ? &quot;+&quot; : &quot;&quot;;

  paddedZone += padNumber(Math[zone &gt; 0 ? &#x27;floor&#x27; : &#x27;ceil&#x27;](zone / 60), 2) +
                padNumber(Math.abs(zone % 60), 2);

  return paddedZone;
}

function ampmGetter(date, formats) {
  return date.getHours() &lt; 12 ? formats.AMPMS[0] : formats.AMPMS[1];
}

var DATE_FORMATS = {
  yyyy: dateGetter(&#x27;FullYear&#x27;, 4),
    yy: dateGetter(&#x27;FullYear&#x27;, 2, 0, true),
     y: dateGetter(&#x27;FullYear&#x27;, 1),
  MMMM: dateStrGetter(&#x27;Month&#x27;),
   MMM: dateStrGetter(&#x27;Month&#x27;, true),
    MM: dateGetter(&#x27;Month&#x27;, 2, 1),
     M: dateGetter(&#x27;Month&#x27;, 1, 1),
    dd: dateGetter(&#x27;Date&#x27;, 2),
     d: dateGetter(&#x27;Date&#x27;, 1),
    HH: dateGetter(&#x27;Hours&#x27;, 2),
     H: dateGetter(&#x27;Hours&#x27;, 1),
    hh: dateGetter(&#x27;Hours&#x27;, 2, -12),
     h: dateGetter(&#x27;Hours&#x27;, 1, -12),
    mm: dateGetter(&#x27;Minutes&#x27;, 2),
     m: dateGetter(&#x27;Minutes&#x27;, 1),
    ss: dateGetter(&#x27;Seconds&#x27;, 2),
     s: dateGetter(&#x27;Seconds&#x27;, 1),
     // while ISO 8601 requires fractions to be prefixed with &#x60;.&#x60; or &#x60;,&#x60; 
     // we can be just safely rely on using &#x60;sss&#x60; since we currently don&#x27;t support single or two digit fractions
   sss: dateGetter(&#x27;Milliseconds&#x27;, 3),
  EEEE: dateStrGetter(&#x27;Day&#x27;),
   EEE: dateStrGetter(&#x27;Day&#x27;, true),
     a: ampmGetter,
     Z: timeZoneGetter
};

var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE&#x27;]+)|(?:&#x27;(?:[^&#x27;]|&#x27;&#x27;)*&#x27;)|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/,
    NUMBER_STRING = /^\d+$/;

/**
 * @ngdoc filter
 * @name ng.filter:date
 * @function
 *
 * @description
 *   Formats &#x60;date&#x60; to a string based on the requested &#x60;format&#x60;.
 *
 *   &#x60;format&#x60; string can be composed of the following elements:
 *
 *   * &#x60;&#x27;yyyy&#x27;&#x60;: 4 digit representation of year (e.g. AD 1 =&gt; 0001, AD 2010 =&gt; 2010)
 *   * &#x60;&#x27;yy&#x27;&#x60;: 2 digit representation of year, padded (00-99). (e.g. AD 2001 =&gt; 01, AD 2010 =&gt; 10)
 *   * &#x60;&#x27;y&#x27;&#x60;: 1 digit representation of year, e.g. (AD 1 =&gt; 1, AD 199 =&gt; 199)
 *   * &#x60;&#x27;MMMM&#x27;&#x60;: Month in year (January-December)
 *   * &#x60;&#x27;MMM&#x27;&#x60;: Month in year (Jan-Dec)
 *   * &#x60;&#x27;MM&#x27;&#x60;: Month in year, padded (01-12)
 *   * &#x60;&#x27;M&#x27;&#x60;: Month in year (1-12)
 *   * &#x60;&#x27;dd&#x27;&#x60;: Day in month, padded (01-31)
 *   * &#x60;&#x27;d&#x27;&#x60;: Day in month (1-31)
 *   * &#x60;&#x27;EEEE&#x27;&#x60;: Day in Week,(Sunday-Saturday)
 *   * &#x60;&#x27;EEE&#x27;&#x60;: Day in Week, (Sun-Sat)
 *   * &#x60;&#x27;HH&#x27;&#x60;: Hour in day, padded (00-23)
 *   * &#x60;&#x27;H&#x27;&#x60;: Hour in day (0-23)
 *   * &#x60;&#x27;hh&#x27;&#x60;: Hour in am/pm, padded (01-12)
 *   * &#x60;&#x27;h&#x27;&#x60;: Hour in am/pm, (1-12)
 *   * &#x60;&#x27;mm&#x27;&#x60;: Minute in hour, padded (00-59)
 *   * &#x60;&#x27;m&#x27;&#x60;: Minute in hour (0-59)
 *   * &#x60;&#x27;ss&#x27;&#x60;: Second in minute, padded (00-59)
 *   * &#x60;&#x27;s&#x27;&#x60;: Second in minute (0-59)
 *   * &#x60;&#x27;.sss&#x27; or &#x27;,sss&#x27;&#x60;: Millisecond in second, padded (000-999)
 *   * &#x60;&#x27;a&#x27;&#x60;: am/pm marker
 *   * &#x60;&#x27;Z&#x27;&#x60;: 4 digit (+sign) representation of the timezone offset (-1200-+1200)
 *
 *   &#x60;format&#x60; string can also be one of the following predefined
 *   {@link guide/i18n localizable formats}:
 *
 *   * &#x60;&#x27;medium&#x27;&#x60;: equivalent to &#x60;&#x27;MMM d, y h:mm:ss a&#x27;&#x60; for en_US locale
 *     (e.g. Sep 3, 2010 12:05:08 pm)
 *   * &#x60;&#x27;short&#x27;&#x60;: equivalent to &#x60;&#x27;M/d/yy h:mm a&#x27;&#x60; for en_US  locale (e.g. 9/3/10 12:05 pm)
 *   * &#x60;&#x27;fullDate&#x27;&#x60;: equivalent to &#x60;&#x27;EEEE, MMMM d,y&#x27;&#x60; for en_US  locale
 *     (e.g. Friday, September 3, 2010)
 *   * &#x60;&#x27;longDate&#x27;&#x60;: equivalent to &#x60;&#x27;MMMM d, y&#x27;&#x60; for en_US  locale (e.g. September 3, 2010
 *   * &#x60;&#x27;mediumDate&#x27;&#x60;: equivalent to &#x60;&#x27;MMM d, y&#x27;&#x60; for en_US  locale (e.g. Sep 3, 2010)
 *   * &#x60;&#x27;shortDate&#x27;&#x60;: equivalent to &#x60;&#x27;M/d/yy&#x27;&#x60; for en_US locale (e.g. 9/3/10)
 *   * &#x60;&#x27;mediumTime&#x27;&#x60;: equivalent to &#x60;&#x27;h:mm:ss a&#x27;&#x60; for en_US locale (e.g. 12:05:08 pm)
 *   * &#x60;&#x27;shortTime&#x27;&#x60;: equivalent to &#x60;&#x27;h:mm a&#x27;&#x60; for en_US locale (e.g. 12:05 pm)
 *
 *   &#x60;format&#x60; string can contain literal values. These need to be quoted with single quotes (e.g.
 *   &#x60;&quot;h &#x27;in the morning&#x27;&quot;&#x60;). In order to output single quote, use two single quotes in a sequence
 *   (e.g. &#x60;&quot;h o&#x27;&#x27;clock&quot;&#x60;).
 *
 * @param {(Date|number|string)} date Date to format either as Date object, milliseconds (string or
 *    number) or various ISO 8601 datetime string formats (e.g. yyyy-MM-ddTHH:mm:ss.SSSZ and its
 *    shorter versions like yyyy-MM-ddTHH:mmZ, yyyy-MM-dd or yyyyMMddTHHmmssZ). If no timezone is
 *    specified in the string input, the time is considered to be in the local timezone.
 * @param {string=} format Formatting rules (see Description). If not specified,
 *    &#x60;mediumDate&#x60; is used.
 * @returns {string} Formatted string or the input if input is not recognized as date/millis.
 *
 * @example
   &lt;doc:example&gt;
     &lt;doc:source&gt;
       &lt;span ng-non-bindable&gt;{{1288323623006 | date:&#x27;medium&#x27;}}&lt;/span&gt;:
           {{1288323623006 | date:&#x27;medium&#x27;}}&lt;br&gt;
       &lt;span ng-non-bindable&gt;{{1288323623006 | date:&#x27;yyyy-MM-dd HH:mm:ss Z&#x27;}}&lt;/span&gt;:
          {{1288323623006 | date:&#x27;yyyy-MM-dd HH:mm:ss Z&#x27;}}&lt;br&gt;
       &lt;span ng-non-bindable&gt;{{1288323623006 | date:&#x27;MM/dd/yyyy @ h:mma&#x27;}}&lt;/span&gt;:
          {{&#x27;1288323623006&#x27; | date:&#x27;MM/dd/yyyy @ h:mma&#x27;}}&lt;br&gt;
     &lt;/doc:source&gt;
     &lt;doc:scenario&gt;
       it(&#x27;should format date&#x27;, function() {
         expect(binding(&quot;1288323623006 | date:&#x27;medium&#x27;&quot;)).
            toMatch(/Oct 2\d, 2010 \d{1,2}:\d{2}:\d{2} (AM|PM)/);
         expect(binding(&quot;1288323623006 | date:&#x27;yyyy-MM-dd HH:mm:ss Z&#x27;&quot;)).
            toMatch(/2010\-10\-2\d \d{2}:\d{2}:\d{2} (\-|\+)?\d{4}/);
         expect(binding(&quot;&#x27;1288323623006&#x27; | date:&#x27;MM/dd/yyyy @ h:mma&#x27;&quot;)).
            toMatch(/10\/2\d\/2010 @ \d{1,2}:\d{2}(AM|PM)/);
       });
     &lt;/doc:scenario&gt;
   &lt;/doc:example&gt;
 */
dateFilter.$inject = [&#x27;$locale&#x27;];
function dateFilter($locale) {


  var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
                     // 1        2       3         4          5          6          7          8  9     10      11
  function jsonStringToDate(string) {
    var match;
    if (match = string.match(R_ISO8601_STR)) {
      var date = new Date(0),
          tzHour = 0,
          tzMin  = 0,
          dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
          timeSetter = match[8] ? date.setUTCHours : date.setHours;

      if (match[9]) {
        tzHour = int(match[9] + match[10]);
        tzMin = int(match[9] + match[11]);
      }
      dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));
      var h = int(match[4]||0) - tzHour;
      var m = int(match[5]||0) - tzMin
      var s = int(match[6]||0);
      var ms = Math.round(parseFloat(&#x27;0.&#x27; + (match[7]||0)) * 1000);
      timeSetter.call(date, h, m, s, ms);
      return date;
    }
    return string;
  }


  return function(date, format) {
    var text = &#x27;&#x27;,
        parts = [],
        fn, match;

    format = format || &#x27;mediumDate&#x27;;
    format = $locale.DATETIME_FORMATS[format] || format;
    if (isString(date)) {
      if (NUMBER_STRING.test(date)) {
        date = int(date);
      } else {
        date = jsonStringToDate(date);
      }
    }

    if (isNumber(date)) {
      date = new Date(date);
    }

    if (!isDate(date)) {
      return date;
    }

    while(format) {
      match = DATE_FORMATS_SPLIT.exec(format);
      if (match) {
        parts = concat(parts, match, 1);
        format = parts.pop();
      } else {
        parts.push(format);
        format = null;
      }
    }

    forEach(parts, function(value){
      fn = DATE_FORMATS[value];
      text += fn ? fn(date, $locale.DATETIME_FORMATS)
                 : value.replace(/(^&#x27;|&#x27;$)/g, &#x27;&#x27;).replace(/&#x27;&#x27;/g, &quot;&#x27;&quot;);
    });

    return text;
  };
}


/**
 * @ngdoc filter
 * @name ng.filter:json
 * @function
 *
 * @description
 *   Allows you to convert a JavaScript object into JSON string.
 *
 *   This filter is mostly useful for debugging. When using the double curly {{value}} notation
 *   the binding is automatically converted to JSON.
 *
 * @param {*} object Any JavaScript object (including arrays and primitive types) to filter.
 * @returns {string} JSON string.
 *
 *
 * @example:
   &lt;doc:example&gt;
     &lt;doc:source&gt;
       &lt;pre&gt;{{ {&#x27;name&#x27;:&#x27;value&#x27;} | json }}&lt;/pre&gt;
     &lt;/doc:source&gt;
     &lt;doc:scenario&gt;
       it(&#x27;should jsonify filtered objects&#x27;, function() {
         expect(binding(&quot;{&#x27;name&#x27;:&#x27;value&#x27;}&quot;)).toMatch(/\{\n  &quot;name&quot;: ?&quot;value&quot;\n}/);
       });
     &lt;/doc:scenario&gt;
   &lt;/doc:example&gt;
 *
 */
function jsonFilter() {
  return function(object) {
    return toJson(object, true);
  };
}


/**
 * @ngdoc filter
 * @name ng.filter:lowercase
 * @function
 * @description
 * Converts string to lowercase.
 * @see angular.lowercase
 */
var lowercaseFilter = valueFn(lowercase);


/**
 * @ngdoc filter
 * @name ng.filter:uppercase
 * @function
 * @description
 * Converts string to uppercase.
 * @see angular.uppercase
 */
var uppercaseFilter = valueFn(uppercase);

/**
 * @ngdoc function
 * @name ng.filter:limitTo
 * @function
 *
 * @description
 * Creates a new array or string containing only a specified number of elements. The elements
 * are taken from either the beginning or the end of the source array or string, as specified by
 * the value and sign (positive or negative) of &#x60;limit&#x60;.
 *
 * Note: This function is used to augment the &#x60;Array&#x60; type in Angular expressions. See
 * {@link ng.$filter} for more information about Angular arrays.
 *
 * @param {Array|string} input Source array or string to be limited.
 * @param {string|number} limit The length of the returned array or string. If the &#x60;limit&#x60; number 
 *     is positive, &#x60;limit&#x60; number of items from the beginning of the source array/string are copied.
 *     If the number is negative, &#x60;limit&#x60; number  of items from the end of the source array/string 
 *     are copied. The &#x60;limit&#x60; will be trimmed if it exceeds &#x60;array.length&#x60;
 * @returns {Array|string} A new sub-array or substring of length &#x60;limit&#x60; or less if input array
 *     had less than &#x60;limit&#x60; elements.
 *
 * @example
   &lt;doc:example&gt;
     &lt;doc:source&gt;
       &lt;script&gt;
         function Ctrl($scope) {
           $scope.numbers = [1,2,3,4,5,6,7,8,9];
           $scope.letters = &quot;abcdefghi&quot;;
           $scope.numLimit = 3;
           $scope.letterLimit = 3;
         }
       &lt;/script&gt;
       &lt;div ng-controller=&quot;Ctrl&quot;&gt;
         Limit {{numbers}} to: &lt;input type=&quot;integer&quot; ng-model=&quot;numLimit&quot;&gt;
         &lt;p&gt;Output numbers: {{ numbers | limitTo:numLimit }}&lt;/p&gt;
         Limit {{letters}} to: &lt;input type=&quot;integer&quot; ng-model=&quot;letterLimit&quot;&gt;
         &lt;p&gt;Output letters: {{ letters | limitTo:letterLimit }}&lt;/p&gt;
       &lt;/div&gt;
     &lt;/doc:source&gt;
     &lt;doc:scenario&gt;
       it(&#x27;should limit the number array to first three items&#x27;, function() {
         expect(element(&#x27;.doc-example-live input[ng-model=numLimit]&#x27;).val()).toBe(&#x27;3&#x27;);
         expect(element(&#x27;.doc-example-live input[ng-model=letterLimit]&#x27;).val()).toBe(&#x27;3&#x27;);
         expect(binding(&#x27;numbers | limitTo:numLimit&#x27;)).toEqual(&#x27;[1,2,3]&#x27;);
         expect(binding(&#x27;letters | limitTo:letterLimit&#x27;)).toEqual(&#x27;abc&#x27;);
       });

       it(&#x27;should update the output when -3 is entered&#x27;, function() {
         input(&#x27;numLimit&#x27;).enter(-3);
         input(&#x27;letterLimit&#x27;).enter(-3);
         expect(binding(&#x27;numbers | limitTo:numLimit&#x27;)).toEqual(&#x27;[7,8,9]&#x27;);
         expect(binding(&#x27;letters | limitTo:letterLimit&#x27;)).toEqual(&#x27;ghi&#x27;);
       });

       it(&#x27;should not exceed the maximum size of input array&#x27;, function() {
         input(&#x27;numLimit&#x27;).enter(100);
         input(&#x27;letterLimit&#x27;).enter(100);
         expect(binding(&#x27;numbers | limitTo:numLimit&#x27;)).toEqual(&#x27;[1,2,3,4,5,6,7,8,9]&#x27;);
         expect(binding(&#x27;letters | limitTo:letterLimit&#x27;)).toEqual(&#x27;abcdefghi&#x27;);
       });
     &lt;/doc:scenario&gt;
   &lt;/doc:example&gt;
 */
function limitToFilter(){
  return function(input, limit) {
    if (!isArray(input) &amp;&amp; !isString(input)) return input;
    
    limit = int(limit);

    if (isString(input)) {
      //NaN check on limit
      if (limit) {
        return limit &gt;= 0 ? input.slice(0, limit) : input.slice(limit, input.length);
      } else {
        return &quot;&quot;;
      }
    }

    var out = [],
      i, n;

    // if abs(limit) exceeds maximum length, trim it
    if (limit &gt; input.length)
      limit = input.length;
    else if (limit &lt; -input.length)
      limit = -input.length;

    if (limit &gt; 0) {
      i = 0;
      n = limit;
    } else {
      i = input.length + limit;
      n = input.length;
    }

    for (; i&lt;n; i++) {
      out.push(input[i]);
    }

    return out;
  }
}

/**
 * @ngdoc function
 * @name ng.filter:orderBy
 * @function
 *
 * @description
 * Orders a specified &#x60;array&#x60; by the &#x60;expression&#x60; predicate.
 *
 * Note: this function is used to augment the &#x60;Array&#x60; type in Angular expressions. See
 * {@link ng.$filter} for more information about Angular arrays.
 *
 * @param {Array} array The array to sort.
 * @param {function(*)|string|Array.&lt;(function(*)|string)&gt;} expression A predicate to be
 *    used by the comparator to determine the order of elements.
 *
 *    Can be one of:
 *
 *    - &#x60;function&#x60;: Getter function. The result of this function will be sorted using the
 *      &#x60;&lt;&#x60;, &#x60;=&#x60;, &#x60;&gt;&#x60; operator.
 *    - &#x60;string&#x60;: An Angular expression which evaluates to an object to order by, such as &#x27;name&#x27;
 *      to sort by a property called &#x27;name&#x27;. Optionally prefixed with &#x60;+&#x60; or &#x60;-&#x60; to control
 *      ascending or descending sort order (for example, +name or -name).
 *    - &#x60;Array&#x60;: An array of function or string predicates. The first predicate in the array
 *      is used for sorting, but when two items are equivalent, the next predicate is used.
 *
 * @param {boolean=} reverse Reverse the order the array.
 * @returns {Array} Sorted copy of the source array.
 *
 * @example
   &lt;doc:example&gt;
     &lt;doc:source&gt;
       &lt;script&gt;
         function Ctrl($scope) {
           $scope.friends =
               [{name:&#x27;John&#x27;, phone:&#x27;555-1212&#x27;, age:10},
                {name:&#x27;Mary&#x27;, phone:&#x27;555-9876&#x27;, age:19},
                {name:&#x27;Mike&#x27;, phone:&#x27;555-4321&#x27;, age:21},
                {name:&#x27;Adam&#x27;, phone:&#x27;555-5678&#x27;, age:35},
                {name:&#x27;Julie&#x27;, phone:&#x27;555-8765&#x27;, age:29}]
           $scope.predicate = &#x27;-age&#x27;;
         }
       &lt;/script&gt;
       &lt;div ng-controller=&quot;Ctrl&quot;&gt;
         &lt;pre&gt;Sorting predicate = {{predicate}}; reverse = {{reverse}}&lt;/pre&gt;
         &lt;hr/&gt;
         [ &lt;a href=&quot;&quot; ng-click=&quot;predicate=&#x27;&#x27;&quot;&gt;unsorted&lt;/a&gt; ]
         &lt;table class=&quot;friend&quot;&gt;
           &lt;tr&gt;
             &lt;th&gt;&lt;a href=&quot;&quot; ng-click=&quot;predicate = &#x27;name&#x27;; reverse=false&quot;&gt;Name&lt;/a&gt;
                 (&lt;a href ng-click=&quot;predicate = &#x27;-name&#x27;; reverse=false&quot;&gt;^&lt;/a&gt;)&lt;/th&gt;
             &lt;th&gt;&lt;a href=&quot;&quot; ng-click=&quot;predicate = &#x27;phone&#x27;; reverse=!reverse&quot;&gt;Phone Number&lt;/a&gt;&lt;/th&gt;
             &lt;th&gt;&lt;a href=&quot;&quot; ng-click=&quot;predicate = &#x27;age&#x27;; reverse=!reverse&quot;&gt;Age&lt;/a&gt;&lt;/th&gt;
           &lt;/tr&gt;
           &lt;tr ng-repeat=&quot;friend in friends | orderBy:predicate:reverse&quot;&gt;
             &lt;td&gt;{{friend.name}}&lt;/td&gt;
             &lt;td&gt;{{friend.phone}}&lt;/td&gt;
             &lt;td&gt;{{friend.age}}&lt;/td&gt;
           &lt;/tr&gt;
         &lt;/table&gt;
       &lt;/div&gt;
     &lt;/doc:source&gt;
     &lt;doc:scenario&gt;
       it(&#x27;should be reverse ordered by aged&#x27;, function() {
         expect(binding(&#x27;predicate&#x27;)).toBe(&#x27;-age&#x27;);
         expect(repeater(&#x27;table.friend&#x27;, &#x27;friend in friends&#x27;).column(&#x27;friend.age&#x27;)).
           toEqual([&#x27;35&#x27;, &#x27;29&#x27;, &#x27;21&#x27;, &#x27;19&#x27;, &#x27;10&#x27;]);
         expect(repeater(&#x27;table.friend&#x27;, &#x27;friend in friends&#x27;).column(&#x27;friend.name&#x27;)).
           toEqual([&#x27;Adam&#x27;, &#x27;Julie&#x27;, &#x27;Mike&#x27;, &#x27;Mary&#x27;, &#x27;John&#x27;]);
       });

       it(&#x27;should reorder the table when user selects different predicate&#x27;, function() {
         element(&#x27;.doc-example-live a:contains(&quot;Name&quot;)&#x27;).click();
         expect(repeater(&#x27;table.friend&#x27;, &#x27;friend in friends&#x27;).column(&#x27;friend.name&#x27;)).
           toEqual([&#x27;Adam&#x27;, &#x27;John&#x27;, &#x27;Julie&#x27;, &#x27;Mary&#x27;, &#x27;Mike&#x27;]);
         expect(repeater(&#x27;table.friend&#x27;, &#x27;friend in friends&#x27;).column(&#x27;friend.age&#x27;)).
           toEqual([&#x27;35&#x27;, &#x27;10&#x27;, &#x27;29&#x27;, &#x27;19&#x27;, &#x27;21&#x27;]);

         element(&#x27;.doc-example-live a:contains(&quot;Phone&quot;)&#x27;).click();
         expect(repeater(&#x27;table.friend&#x27;, &#x27;friend in friends&#x27;).column(&#x27;friend.phone&#x27;)).
           toEqual([&#x27;555-9876&#x27;, &#x27;555-8765&#x27;, &#x27;555-5678&#x27;, &#x27;555-4321&#x27;, &#x27;555-1212&#x27;]);
         expect(repeater(&#x27;table.friend&#x27;, &#x27;friend in friends&#x27;).column(&#x27;friend.name&#x27;)).
           toEqual([&#x27;Mary&#x27;, &#x27;Julie&#x27;, &#x27;Adam&#x27;, &#x27;Mike&#x27;, &#x27;John&#x27;]);
       });
     &lt;/doc:scenario&gt;
   &lt;/doc:example&gt;
 */
orderByFilter.$inject = [&#x27;$parse&#x27;];
function orderByFilter($parse){
  return function(array, sortPredicate, reverseOrder) {
    if (!isArray(array)) return array;
    if (!sortPredicate) return array;
    sortPredicate = isArray(sortPredicate) ? sortPredicate: [sortPredicate];
    sortPredicate = map(sortPredicate, function(predicate){
      var descending = false, get = predicate || identity;
      if (isString(predicate)) {
        if ((predicate.charAt(0) == &#x27;+&#x27; || predicate.charAt(0) == &#x27;-&#x27;)) {
          descending = predicate.charAt(0) == &#x27;-&#x27;;
          predicate = predicate.substring(1);
        }
        get = $parse(predicate);
      }
      return reverseComparator(function(a,b){
        return compare(get(a),get(b));
      }, descending);
    });
    var arrayCopy = [];
    for ( var i = 0; i &lt; array.length; i++) { arrayCopy.push(array[i]); }
    return arrayCopy.sort(reverseComparator(comparator, reverseOrder));

    function comparator(o1, o2){
      for ( var i = 0; i &lt; sortPredicate.length; i++) {
        var comp = sortPredicate[i](o1, o2);
        if (comp !== 0) return comp;
      }
      return 0;
    }
    function reverseComparator(comp, descending) {
      return toBoolean(descending)
          ? function(a,b){return comp(b,a);}
          : comp;
    }
    function compare(v1, v2){
      var t1 = typeof v1;
      var t2 = typeof v2;
      if (t1 == t2) {
        if (t1 == &quot;string&quot;) v1 = v1.toLowerCase();
        if (t1 == &quot;string&quot;) v2 = v2.toLowerCase();
        if (v1 === v2) return 0;
        return v1 &lt; v2 ? -1 : 1;
      } else {
        return t1 &lt; t2 ? -1 : 1;
      }
    }
  }
}

function ngDirective(directive) {
  if (isFunction(directive)) {
    directive = {
      link: directive
    }
  }
  directive.restrict = directive.restrict || &#x27;AC&#x27;;
  return valueFn(directive);
}

/**
 * @ngdoc directive
 * @name ng.directive:a
 * @restrict E
 *
 * @description
 * Modifies the default behavior of html A tag, so that the default action is prevented when href
 * attribute is empty.
 *
 * The reasoning for this change is to allow easy creation of action links with &#x60;ngClick&#x60; directive
 * without changing the location or causing page reloads, e.g.:
 * &#x60;&lt;a href=&quot;&quot; ng-click=&quot;model.$save()&quot;&gt;Save&lt;/a&gt;&#x60;
 */
var htmlAnchorDirective = valueFn({
  restrict: &#x27;E&#x27;,
  compile: function(element, attr) {

    if (msie &lt;= 8) {

      // turn &lt;a href ng-click=&quot;..&quot;&gt;link&lt;/a&gt; into a stylable link in IE
      // but only if it doesn&#x27;t have name attribute, in which case it&#x27;s an anchor
      if (!attr.href &amp;&amp; !attr.name) {
        attr.$set(&#x27;href&#x27;, &#x27;&#x27;);
      }

      // add a comment node to anchors to workaround IE bug that causes element content to be reset
      // to new attribute content if attribute is updated with value containing @ and element also
      // contains value with @
      // see issue #1949
      element.append(document.createComment(&#x27;IE fix&#x27;));
    }

    return function(scope, element) {
      element.bind(&#x27;click&#x27;, function(event){
        // if we have no href url, then don&#x27;t navigate anywhere.
        if (!element.attr(&#x27;href&#x27;)) {
          event.preventDefault();
        }
      });
    }
  }
});

/**
 * @ngdoc directive
 * @name ng.directive:ngHref
 * @restrict A
 *
 * @description
 * Using Angular markup like {{hash}} in an href attribute makes
 * the page open to a wrong URL, if the user clicks that link before
 * angular has a chance to replace the {{hash}} with actual URL, the
 * link will be broken and will most likely return a 404 error.
 * The &#x60;ngHref&#x60; directive solves this problem.
 *
 * The buggy way to write it:
 * &lt;pre&gt;
 * &lt;a href=&quot;http://www.gravatar.com/avatar/{{hash}}&quot;/&gt;
 * &lt;/pre&gt;
 *
 * The correct way to write it:
 * &lt;pre&gt;
 * &lt;a ng-href=&quot;http://www.gravatar.com/avatar/{{hash}}&quot;/&gt;
 * &lt;/pre&gt;
 *
 * @element A
 * @param {template} ngHref any string which can contain &#x60;{{}}&#x60; markup.
 *
 * @example
 * This example uses &#x60;link&#x60; variable inside &#x60;href&#x60; attribute:
    &lt;doc:example&gt;
      &lt;doc:source&gt;
        &lt;input ng-model=&quot;value&quot; /&gt;&lt;br /&gt;
        &lt;a id=&quot;link-1&quot; href ng-click=&quot;value = 1&quot;&gt;link 1&lt;/a&gt; (link, don&#x27;t reload)&lt;br /&gt;
        &lt;a id=&quot;link-2&quot; href=&quot;&quot; ng-click=&quot;value = 2&quot;&gt;link 2&lt;/a&gt; (link, don&#x27;t reload)&lt;br /&gt;
        &lt;a id=&quot;link-3&quot; ng-href=&quot;/{{&#x27;123&#x27;}}&quot;&gt;link 3&lt;/a&gt; (link, reload!)&lt;br /&gt;
        &lt;a id=&quot;link-4&quot; href=&quot;&quot; name=&quot;xx&quot; ng-click=&quot;value = 4&quot;&gt;anchor&lt;/a&gt; (link, don&#x27;t reload)&lt;br /&gt;
        &lt;a id=&quot;link-5&quot; name=&quot;xxx&quot; ng-click=&quot;value = 5&quot;&gt;anchor&lt;/a&gt; (no link)&lt;br /&gt;
        &lt;a id=&quot;link-6&quot; ng-href=&quot;{{value}}&quot;&gt;link&lt;/a&gt; (link, change location)
      &lt;/doc:source&gt;
      &lt;doc:scenario&gt;
        it(&#x27;should execute ng-click but not reload when href without value&#x27;, function() {
          element(&#x27;#link-1&#x27;).click();
          expect(input(&#x27;value&#x27;).val()).toEqual(&#x27;1&#x27;);
          expect(element(&#x27;#link-1&#x27;).attr(&#x27;href&#x27;)).toBe(&quot;&quot;);
        });

        it(&#x27;should execute ng-click but not reload when href empty string&#x27;, function() {
          element(&#x27;#link-2&#x27;).click();
          expect(input(&#x27;value&#x27;).val()).toEqual(&#x27;2&#x27;);
          expect(element(&#x27;#link-2&#x27;).attr(&#x27;href&#x27;)).toBe(&quot;&quot;);
        });

        it(&#x27;should execute ng-click and change url when ng-href specified&#x27;, function() {
          expect(element(&#x27;#link-3&#x27;).attr(&#x27;href&#x27;)).toBe(&quot;/123&quot;);

          element(&#x27;#link-3&#x27;).click();
          expect(browser().window().path()).toEqual(&#x27;/123&#x27;);
        });

        it(&#x27;should execute ng-click but not reload when href empty string and name specified&#x27;, function() {
          element(&#x27;#link-4&#x27;).click();
          expect(input(&#x27;value&#x27;).val()).toEqual(&#x27;4&#x27;);
          expect(element(&#x27;#link-4&#x27;).attr(&#x27;href&#x27;)).toBe(&#x27;&#x27;);
        });

        it(&#x27;should execute ng-click but not reload when no href but name specified&#x27;, function() {
          element(&#x27;#link-5&#x27;).click();
          expect(input(&#x27;value&#x27;).val()).toEqual(&#x27;5&#x27;);
          expect(element(&#x27;#link-5&#x27;).attr(&#x27;href&#x27;)).toBe(undefined);
        });

        it(&#x27;should only change url when only ng-href&#x27;, function() {
          input(&#x27;value&#x27;).enter(&#x27;6&#x27;);
          expect(element(&#x27;#link-6&#x27;).attr(&#x27;href&#x27;)).toBe(&#x27;6&#x27;);

          element(&#x27;#link-6&#x27;).click();
          expect(browser().location().url()).toEqual(&#x27;/6&#x27;);
        });
      &lt;/doc:scenario&gt;
    &lt;/doc:example&gt;
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngSrc
 * @restrict A
 *
 * @description
 * Using Angular markup like &#x60;{{hash}}&#x60; in a &#x60;src&#x60; attribute doesn&#x27;t
 * work right: The browser will fetch from the URL with the literal
 * text &#x60;{{hash}}&#x60; until Angular replaces the expression inside
 * &#x60;{{hash}}&#x60;. The &#x60;ngSrc&#x60; directive solves this problem.
 *
 * The buggy way to write it:
 * &lt;pre&gt;
 * &lt;img src=&quot;http://www.gravatar.com/avatar/{{hash}}&quot;/&gt;
 * &lt;/pre&gt;
 *
 * The correct way to write it:
 * &lt;pre&gt;
 * &lt;img ng-src=&quot;http://www.gravatar.com/avatar/{{hash}}&quot;/&gt;
 * &lt;/pre&gt;
 *
 * @element IMG
 * @param {template} ngSrc any string which can contain &#x60;{{}}&#x60; markup.
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngSrcset
 * @restrict A
 *
 * @description
 * Using Angular markup like &#x60;{{hash}}&#x60; in a &#x60;srcset&#x60; attribute doesn&#x27;t
 * work right: The browser will fetch from the URL with the literal
 * text &#x60;{{hash}}&#x60; until Angular replaces the expression inside
 * &#x60;{{hash}}&#x60;. The &#x60;ngSrcset&#x60; directive solves this problem.
 *
 * The buggy way to write it:
 * &lt;pre&gt;
 * &lt;img srcset=&quot;http://www.gravatar.com/avatar/{{hash}} 2x&quot;/&gt;
 * &lt;/pre&gt;
 *
 * The correct way to write it:
 * &lt;pre&gt;
 * &lt;img ng-srcset=&quot;http://www.gravatar.com/avatar/{{hash}} 2x&quot;/&gt;
 * &lt;/pre&gt;
 *
 * @element IMG
 * @param {template} ngSrcset any string which can contain &#x60;{{}}&#x60; markup.
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngDisabled
 * @restrict A
 *
 * @description
 *
 * The following markup will make the button enabled on Chrome/Firefox but not on IE8 and older IEs:
 * &lt;pre&gt;
 * &lt;div ng-init=&quot;scope = { isDisabled: false }&quot;&gt;
 *  &lt;button disabled=&quot;{{scope.isDisabled}}&quot;&gt;Disabled&lt;/button&gt;
 * &lt;/div&gt;
 * &lt;/pre&gt;
 *
 * The HTML specs do not require browsers to preserve the special attributes such as disabled.
 * (The presence of them means true and absence means false)
 * This prevents the angular compiler from correctly retrieving the binding expression.
 * To solve this problem, we introduce the &#x60;ngDisabled&#x60; directive.
 *
 * @example
    &lt;doc:example&gt;
      &lt;doc:source&gt;
        Click me to toggle: &lt;input type=&quot;checkbox&quot; ng-model=&quot;checked&quot;&gt;&lt;br/&gt;
        &lt;button ng-model=&quot;button&quot; ng-disabled=&quot;checked&quot;&gt;Button&lt;/button&gt;
      &lt;/doc:source&gt;
      &lt;doc:scenario&gt;
        it(&#x27;should toggle button&#x27;, function() {
          expect(element(&#x27;.doc-example-live :button&#x27;).prop(&#x27;disabled&#x27;)).toBeFalsy();
          input(&#x27;checked&#x27;).check();
          expect(element(&#x27;.doc-example-live :button&#x27;).prop(&#x27;disabled&#x27;)).toBeTruthy();
        });
      &lt;/doc:scenario&gt;
    &lt;/doc:example&gt;
 *
 * @element INPUT
 * @param {expression} ngDisabled Angular expression that will be evaluated.
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngChecked
 * @restrict A
 *
 * @description
 * The HTML specs do not require browsers to preserve the special attributes such as checked.
 * (The presence of them means true and absence means false)
 * This prevents the angular compiler from correctly retrieving the binding expression.
 * To solve this problem, we introduce the &#x60;ngChecked&#x60; directive.
 * @example
    &lt;doc:example&gt;
      &lt;doc:source&gt;
        Check me to check both: &lt;input type=&quot;checkbox&quot; ng-model=&quot;master&quot;&gt;&lt;br/&gt;
        &lt;input id=&quot;checkSlave&quot; type=&quot;checkbox&quot; ng-checked=&quot;master&quot;&gt;
      &lt;/doc:source&gt;
      &lt;doc:scenario&gt;
        it(&#x27;should check both checkBoxes&#x27;, function() {
          expect(element(&#x27;.doc-example-live #checkSlave&#x27;).prop(&#x27;checked&#x27;)).toBeFalsy();
          input(&#x27;master&#x27;).check();
          expect(element(&#x27;.doc-example-live #checkSlave&#x27;).prop(&#x27;checked&#x27;)).toBeTruthy();
        });
      &lt;/doc:scenario&gt;
    &lt;/doc:example&gt;
 *
 * @element INPUT
 * @param {expression} ngChecked Angular expression that will be evaluated.
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngMultiple
 * @restrict A
 *
 * @description
 * The HTML specs do not require browsers to preserve the special attributes such as multiple.
 * (The presence of them means true and absence means false)
 * This prevents the angular compiler from correctly retrieving the binding expression.
 * To solve this problem, we introduce the &#x60;ngMultiple&#x60; directive.
 *
 * @example
     &lt;doc:example&gt;
       &lt;doc:source&gt;
         Check me check multiple: &lt;input type=&quot;checkbox&quot; ng-model=&quot;checked&quot;&gt;&lt;br/&gt;
         &lt;select id=&quot;select&quot; ng-multiple=&quot;checked&quot;&gt;
           &lt;option&gt;Misko&lt;/option&gt;
           &lt;option&gt;Igor&lt;/option&gt;
           &lt;option&gt;Vojta&lt;/option&gt;
           &lt;option&gt;Di&lt;/option&gt;
         &lt;/select&gt;
       &lt;/doc:source&gt;
       &lt;doc:scenario&gt;
         it(&#x27;should toggle multiple&#x27;, function() {
           expect(element(&#x27;.doc-example-live #select&#x27;).prop(&#x27;multiple&#x27;)).toBeFalsy();
           input(&#x27;checked&#x27;).check();
           expect(element(&#x27;.doc-example-live #select&#x27;).prop(&#x27;multiple&#x27;)).toBeTruthy();
         });
       &lt;/doc:scenario&gt;
     &lt;/doc:example&gt;
 *
 * @element SELECT
 * @param {expression} ngMultiple Angular expression that will be evaluated.
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngReadonly
 * @restrict A
 *
 * @description
 * The HTML specs do not require browsers to preserve the special attributes such as readonly.
 * (The presence of them means true and absence means false)
 * This prevents the angular compiler from correctly retrieving the binding expression.
 * To solve this problem, we introduce the &#x60;ngReadonly&#x60; directive.
 * @example
    &lt;doc:example&gt;
      &lt;doc:source&gt;
        Check me to make text readonly: &lt;input type=&quot;checkbox&quot; ng-model=&quot;checked&quot;&gt;&lt;br/&gt;
        &lt;input type=&quot;text&quot; ng-readonly=&quot;checked&quot; value=&quot;I&#x27;m Angular&quot;/&gt;
      &lt;/doc:source&gt;
      &lt;doc:scenario&gt;
        it(&#x27;should toggle readonly attr&#x27;, function() {
          expect(element(&#x27;.doc-example-live :text&#x27;).prop(&#x27;readonly&#x27;)).toBeFalsy();
          input(&#x27;checked&#x27;).check();
          expect(element(&#x27;.doc-example-live :text&#x27;).prop(&#x27;readonly&#x27;)).toBeTruthy();
        });
      &lt;/doc:scenario&gt;
    &lt;/doc:example&gt;
 *
 * @element INPUT
 * @param {string} expression Angular expression that will be evaluated.
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngSelected
 * @restrict A
 *
 * @description
 * The HTML specs do not require browsers to preserve the special attributes such as selected.
 * (The presence of them means true and absence means false)
 * This prevents the angular compiler from correctly retrieving the binding expression.
 * To solve this problem, we introduced the &#x60;ngSelected&#x60; directive.
 * @example
    &lt;doc:example&gt;
      &lt;doc:source&gt;
        Check me to select: &lt;input type=&quot;checkbox&quot; ng-model=&quot;selected&quot;&gt;&lt;br/&gt;
        &lt;select&gt;
          &lt;option&gt;Hello!&lt;/option&gt;
          &lt;option id=&quot;greet&quot; ng-selected=&quot;selected&quot;&gt;Greetings!&lt;/option&gt;
        &lt;/select&gt;
      &lt;/doc:source&gt;
      &lt;doc:scenario&gt;
        it(&#x27;should select Greetings!&#x27;, function() {
          expect(element(&#x27;.doc-example-live #greet&#x27;).prop(&#x27;selected&#x27;)).toBeFalsy();
          input(&#x27;selected&#x27;).check();
          expect(element(&#x27;.doc-example-live #greet&#x27;).prop(&#x27;selected&#x27;)).toBeTruthy();
        });
      &lt;/doc:scenario&gt;
    &lt;/doc:example&gt;
 *
 * @element OPTION
 * @param {string} expression Angular expression that will be evaluated.
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngOpen
 * @restrict A
 *
 * @description
 * The HTML specs do not require browsers to preserve the special attributes such as open.
 * (The presence of them means true and absence means false)
 * This prevents the angular compiler from correctly retrieving the binding expression.
 * To solve this problem, we introduce the &#x60;ngOpen&#x60; directive.
 *
 * @example
     &lt;doc:example&gt;
       &lt;doc:source&gt;
         Check me check multiple: &lt;input type=&quot;checkbox&quot; ng-model=&quot;open&quot;&gt;&lt;br/&gt;
         &lt;details id=&quot;details&quot; ng-open=&quot;open&quot;&gt;
            &lt;summary&gt;Show/Hide me&lt;/summary&gt;
         &lt;/details&gt;
       &lt;/doc:source&gt;
       &lt;doc:scenario&gt;
         it(&#x27;should toggle open&#x27;, function() {
           expect(element(&#x27;#details&#x27;).prop(&#x27;open&#x27;)).toBeFalsy();
           input(&#x27;open&#x27;).check();
           expect(element(&#x27;#details&#x27;).prop(&#x27;open&#x27;)).toBeTruthy();
         });
       &lt;/doc:scenario&gt;
     &lt;/doc:example&gt;
 *
 * @element DETAILS
 * @param {string} expression Angular expression that will be evaluated.
 */

var ngAttributeAliasDirectives = {};


// boolean attrs are evaluated
forEach(BOOLEAN_ATTR, function(propName, attrName) {
  var normalized = directiveNormalize(&#x27;ng-&#x27; + attrName);
  ngAttributeAliasDirectives[normalized] = function() {
    return {
      priority: 100,
      compile: function() {
        return function(scope, element, attr) {
          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
            attr.$set(attrName, !!value);
          });
        };
      }
    };
  };
});


// ng-src, ng-srcset, ng-href are interpolated
forEach([&#x27;src&#x27;, &#x27;srcset&#x27;, &#x27;href&#x27;], function(attrName) {
  var normalized = directiveNormalize(&#x27;ng-&#x27; + attrName);
  ngAttributeAliasDirectives[normalized] = function() {
    return {
      priority: 99, // it needs to run after the attributes are interpolated
      link: function(scope, element, attr) {
        attr.$observe(normalized, function(value) {
          if (!value)
             return;

          attr.$set(attrName, value);

          // on IE, if &quot;ng:src&quot; directive declaration is used and &quot;src&quot; attribute doesn&#x27;t exist
          // then calling element.setAttribute(&#x27;src&#x27;, &#x27;foo&#x27;) doesn&#x27;t do anything, so we need
          // to set the property as well to achieve the desired effect.
          // we use attr[attrName] value since $set can sanitize the url.
          if (msie) element.prop(attrName, attr[attrName]);
        });
      }
    };
  };
});

var nullFormCtrl = {
  $addControl: noop,
  $removeControl: noop,
  $setValidity: noop,
  $setDirty: noop,
  $setPristine: noop
};

/**
 * @ngdoc object
 * @name ng.directive:form.FormController
 *
 * @property {boolean} $pristine True if user has not interacted with the form yet.
 * @property {boolean} $dirty True if user has already interacted with the form.
 * @property {boolean} $valid True if all of the containing forms and controls are valid.
 * @property {boolean} $invalid True if at least one containing control or form is invalid.
 *
 * @property {Object} $error Is an object hash, containing references to all invalid controls or
 *  forms, where:
 *
 *  - keys are validation tokens (error names)  such as &#x60;required&#x60;, &#x60;url&#x60; or &#x60;email&#x60;),
 *  - values are arrays of controls or forms that are invalid with given error.
 *
 * @description
 * &#x60;FormController&#x60; keeps track of all its controls and nested forms as well as state of them,
 * such as being valid/invalid or dirty/pristine.
 *
 * Each {@link ng.directive:form form} directive creates an instance
 * of &#x60;FormController&#x60;.
 *
 */
//asks for $scope to fool the BC controller module
FormController.$inject = [&#x27;$element&#x27;, &#x27;$attrs&#x27;, &#x27;$scope&#x27;];
function FormController(element, attrs) {
  var form = this,
      parentForm = element.parent().controller(&#x27;form&#x27;) || nullFormCtrl,
      invalidCount = 0, // used to easily determine if we are valid
      errors = form.$error = {},
      controls = [];

  // init state
  form.$name = attrs.name;
  form.$dirty = false;
  form.$pristine = true;
  form.$valid = true;
  form.$invalid = false;

  parentForm.$addControl(form);

  // Setup initial state of the control
  element.addClass(PRISTINE_CLASS);
  toggleValidCss(true);

  // convenience method for easy toggling of classes
  function toggleValidCss(isValid, validationErrorKey) {
    validationErrorKey = validationErrorKey ? &#x27;-&#x27; + snake_case(validationErrorKey, &#x27;-&#x27;) : &#x27;&#x27;;
    element.
      removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).
      addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
  }

  form.$addControl = function(control) {
    controls.push(control);

    if (control.$name &amp;&amp; !form.hasOwnProperty(control.$name)) {
      form[control.$name] = control;
    }
  };

  form.$removeControl = function(control) {
    if (control.$name &amp;&amp; form[control.$name] === control) {
      delete form[control.$name];
    }
    forEach(errors, function(queue, validationToken) {
      form.$setValidity(validationToken, true, control);
    });

    arrayRemove(controls, control);
  };

  form.$setValidity = function(validationToken, isValid, control) {
    var queue = errors[validationToken];

    if (isValid) {
      if (queue) {
        arrayRemove(queue, control);
        if (!queue.length) {
          invalidCount--;
          if (!invalidCount) {
            toggleValidCss(isValid);
            form.$valid = true;
            form.$invalid = false;
          }
          errors[validationToken] = false;
          toggleValidCss(true, validationToken);
          parentForm.$setValidity(validationToken, true, form);
        }
      }

    } else {
      if (!invalidCount) {
        toggleValidCss(isValid);
      }
      if (queue) {
        if (includes(queue, control)) return;
      } else {
        errors[validationToken] = queue = [];
        invalidCount++;
        toggleValidCss(false, validationToken);
        parentForm.$setValidity(validationToken, false, form);
      }
      queue.push(control);

      form.$valid = false;
      form.$invalid = true;
    }
  };

  form.$setDirty = function() {
    element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
    form.$dirty = true;
    form.$pristine = false;
    parentForm.$setDirty();
  };

  /**
   * @ngdoc function
   * @name ng.directive:form.FormController#$setPristine
   * @methodOf ng.directive:form.FormController
   *
   * @description
   * Sets the form to its pristine state.
   *
   * This method can be called to remove the &#x27;ng-dirty&#x27; class and set the form to its pristine
   * state (ng-pristine class). This method will also propagate to all the controls contained
   * in this form.
   *
   * Setting a form back to a pristine state is often useful when we want to &#x27;reuse&#x27; a form after
   * saving or resetting it.
   */
  form.$setPristine = function () {
    element.removeClass(DIRTY_CLASS).addClass(PRISTINE_CLASS);
    form.$dirty = false;
    form.$pristine = true;
    forEach(controls, function(control) {
      control.$setPristine();
    });
  };
}


/**
 * @ngdoc directive
 * @name ng.directive:ngForm
 * @restrict EAC
 *
 * @description
 * Nestable alias of {@link ng.directive:form &#x60;form&#x60;} directive. HTML
 * does not allow nesting of form elements. It is useful to nest forms, for example if the validity of a
 * sub-group of controls needs to be determined.
 *
 * @param {string=} name|ngForm Name of the form. If specified, the form controller will be published into
 *                       related scope, under this name.
 *
 */

 /**
 * @ngdoc directive
 * @name ng.directive:form
 * @restrict E
 *
 * @description
 * Directive that instantiates
 * {@link ng.directive:form.FormController FormController}.
 *
 * If &#x60;name&#x60; attribute is specified, the form controller is published onto the current scope under
 * this name.
 *
 * # Alias: {@link ng.directive:ngForm &#x60;ngForm&#x60;}
 *
 * In angular forms can be nested. This means that the outer form is valid when all of the child
 * forms are valid as well. However browsers do not allow nesting of &#x60;&lt;form&gt;&#x60; elements, for this
 * reason angular provides {@link ng.directive:ngForm &#x60;ngForm&#x60;} alias
 * which behaves identical to &#x60;&lt;form&gt;&#x60; but allows form nesting.
 *
 *
 * # CSS classes
 *  - &#x60;ng-valid&#x60; Is set if the form is valid.
 *  - &#x60;ng-invalid&#x60; Is set if the form is invalid.
 *  - &#x60;ng-pristine&#x60; Is set if the form is pristine.
 *  - &#x60;ng-dirty&#x60; Is set if the form is dirty.
 *
 *
 * # Submitting a form and preventing default action
 *
 * Since the role of forms in client-side Angular applications is different than in classical
 * roundtrip apps, it is desirable for the browser not to translate the form submission into a full
 * page reload that sends the data to the server. Instead some javascript logic should be triggered
 * to handle the form submission in application specific way.
 *
 * For this reason, Angular prevents the default action (form submission to the server) unless the
 * &#x60;&lt;form&gt;&#x60; element has an &#x60;action&#x60; attribute specified.
 *
 * You can use one of the following two ways to specify what javascript method should be called when
 * a form is submitted:
 *
 * - {@link ng.directive:ngSubmit ngSubmit} directive on the form element
 * - {@link ng.directive:ngClick ngClick} directive on the first
  *  button or input field of type submit (input[type=submit])
 *
 * To prevent double execution of the handler, use only one of ngSubmit or ngClick directives. This
 * is because of the following form submission rules coming from the html spec:
 *
 * - If a form has only one input field then hitting enter in this field triggers form submit
 * (&#x60;ngSubmit&#x60;)
 * - if a form has has 2+ input fields and no buttons or input[type=submit] then hitting enter
 * doesn&#x27;t trigger submit
 * - if a form has one or more input fields and one or more buttons or input[type=submit] then
 * hitting enter in any of the input fields will trigger the click handler on the *first* button or
 * input[type=submit] (&#x60;ngClick&#x60;) *and* a submit handler on the enclosing form (&#x60;ngSubmit&#x60;)
 *
 * @param {string=} name Name of the form. If specified, the form controller will be published into
 *                       related scope, under this name.
 *
 * @example
    &lt;doc:example&gt;
      &lt;doc:source&gt;
       &lt;script&gt;
         function Ctrl($scope) {
           $scope.userType = &#x27;guest&#x27;;
         }
       &lt;/script&gt;
       &lt;form name=&quot;myForm&quot; ng-controller=&quot;Ctrl&quot;&gt;
         userType: &lt;input name=&quot;input&quot; ng-model=&quot;userType&quot; required&gt;
         &lt;span class=&quot;error&quot; ng-show=&quot;myForm.input.$error.required&quot;&gt;Required!&lt;/span&gt;&lt;br&gt;
         &lt;tt&gt;userType = {{userType}}&lt;/tt&gt;&lt;br&gt;
         &lt;tt&gt;myForm.input.$valid = {{myForm.input.$valid}}&lt;/tt&gt;&lt;br&gt;
         &lt;tt&gt;myForm.input.$error = {{myForm.input.$error}}&lt;/tt&gt;&lt;br&gt;
         &lt;tt&gt;myForm.$valid = {{myForm.$valid}}&lt;/tt&gt;&lt;br&gt;
         &lt;tt&gt;myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt&gt;&lt;br&gt;
        &lt;/form&gt;
      &lt;/doc:source&gt;
      &lt;doc:scenario&gt;
        it(&#x27;should initialize to model&#x27;, function() {
         expect(binding(&#x27;userType&#x27;)).toEqual(&#x27;guest&#x27;);
         expect(binding(&#x27;myForm.input.$valid&#x27;)).toEqual(&#x27;true&#x27;);
        });

        it(&#x27;should be invalid if empty&#x27;, function() {
         input(&#x27;userType&#x27;).enter(&#x27;&#x27;);
         expect(binding(&#x27;userType&#x27;)).toEqual(&#x27;&#x27;);
         expect(binding(&#x27;myForm.input.$valid&#x27;)).toEqual(&#x27;false&#x27;);
        });
      &lt;/doc:scenario&gt;
    &lt;/doc:example&gt;
 */
var formDirectiveFactory = function(isNgForm) {
  return [&#x27;$timeout&#x27;, function($timeout) {
    var formDirective = {
      name: &#x27;form&#x27;,
      restrict: &#x27;E&#x27;,
      controller: FormController,
      compile: function() {
        return {
          pre: function(scope, formElement, attr, controller) {
            if (!attr.action) {
              // we can&#x27;t use jq events because if a form is destroyed during submission the default
              // action is not prevented. see #1238
              //
              // IE 9 is not affected because it doesn&#x27;t fire a submit event and try to do a full
              // page reload if the form was destroyed by submission of the form via a click handler
              // on a button in the form. Looks like an IE9 specific bug.
              var preventDefaultListener = function(event) {
                event.preventDefault
                  ? event.preventDefault()
                  : event.returnValue = false; // IE
              };

              addEventListenerFn(formElement[0], &#x27;submit&#x27;, preventDefaultListener);

              // unregister the preventDefault listener so that we don&#x27;t not leak memory but in a
              // way that will achieve the prevention of the default action.
              formElement.bind(&#x27;$destroy&#x27;, function() {
                $timeout(function() {
                  removeEventListenerFn(formElement[0], &#x27;submit&#x27;, preventDefaultListener);
                }, 0, false);
              });
            }

            var parentFormCtrl = formElement.parent().controller(&#x27;form&#x27;),
                alias = attr.name || attr.ngForm;

            if (alias) {
              scope[alias] = controller;
            }
            if (parentFormCtrl) {
              formElement.bind(&#x27;$destroy&#x27;, function() {
                parentFormCtrl.$removeControl(controller);
                if (alias) {
                  scope[alias] = undefined;
                }
                extend(controller, nullFormCtrl); //stop propagating child destruction handlers upwards
              });
            }
          }
        };
      }
    };

    return isNgForm ? extend(copy(formDirective), {restrict: &#x27;EAC&#x27;}) : formDirective;
  }];
};

var formDirective = formDirectiveFactory();
var ngFormDirective = formDirectiveFactory(true);

var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&amp;%@!\-\/]))?$/;
var EMAIL_REGEXP = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$/;
var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;

var inputType = {

  /**
   * @ngdoc inputType
   * @name ng.directive:input.text
   *
   * @description
   * Standard HTML text input with angular data binding.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} required Adds &#x60;required&#x60; validation error key if the value is not entered.
   * @param {string=} ngRequired Adds &#x60;required&#x60; attribute and &#x60;required&#x60; validation constraint to
   *    the element when the ngRequired expression evaluates to true. Use &#x60;ngRequired&#x60; instead of
   *    &#x60;required&#x60; when you want to data-bind to the &#x60;required&#x60; attribute.
   * @param {number=} ngMinlength Sets &#x60;minlength&#x60; validation error key if the value is shorter than
   *    minlength.
   * @param {number=} ngMaxlength Sets &#x60;maxlength&#x60; validation error key if the value is longer than
   *    maxlength.
   * @param {string=} ngPattern Sets &#x60;pattern&#x60; validation error key if the value does not match the
   *    RegExp pattern expression. Expected value is &#x60;/regexp/&#x60; for inline patterns or &#x60;regexp&#x60; for
   *    patterns defined as scope expressions.
   * @param {string=} ngChange Angular expression to be executed when input changes due to user
   *    interaction with the input element.
   * @param {boolean=} [ngTrim=true] If set to false Angular will not automatically trimming the
   *    input.
   *
   * @example
      &lt;doc:example&gt;
        &lt;doc:source&gt;
         &lt;script&gt;
           function Ctrl($scope) {
             $scope.text = &#x27;guest&#x27;;
             $scope.word = /^\s*\w*\s*$/;
           }
         &lt;/script&gt;
         &lt;form name=&quot;myForm&quot; ng-controller=&quot;Ctrl&quot;&gt;
           Single word: &lt;input type=&quot;text&quot; name=&quot;input&quot; ng-model=&quot;text&quot;
                               ng-pattern=&quot;word&quot; required ng-trim=&quot;false&quot;&gt;
           &lt;span class=&quot;error&quot; ng-show=&quot;myForm.input.$error.required&quot;&gt;
             Required!&lt;/span&gt;
           &lt;span class=&quot;error&quot; ng-show=&quot;myForm.input.$error.pattern&quot;&gt;
             Single word only!&lt;/span&gt;

           &lt;tt&gt;text = {{text}}&lt;/tt&gt;&lt;br/&gt;
           &lt;tt&gt;myForm.input.$valid = {{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;
           &lt;tt&gt;myForm.input.$error = {{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;
           &lt;tt&gt;myForm.$valid = {{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;
           &lt;tt&gt;myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;
          &lt;/form&gt;
        &lt;/doc:source&gt;
        &lt;doc:scenario&gt;
          it(&#x27;should initialize to model&#x27;, function() {
            expect(binding(&#x27;text&#x27;)).toEqual(&#x27;guest&#x27;);
            expect(binding(&#x27;myForm.input.$valid&#x27;)).toEqual(&#x27;true&#x27;);
          });

          it(&#x27;should be invalid if empty&#x27;, function() {
            input(&#x27;text&#x27;).enter(&#x27;&#x27;);
            expect(binding(&#x27;text&#x27;)).toEqual(&#x27;&#x27;);
            expect(binding(&#x27;myForm.input.$valid&#x27;)).toEqual(&#x27;false&#x27;);
          });

          it(&#x27;should be invalid if multi word&#x27;, function() {
            input(&#x27;text&#x27;).enter(&#x27;hello world&#x27;);
            expect(binding(&#x27;myForm.input.$valid&#x27;)).toEqual(&#x27;false&#x27;);
          });

          it(&#x27;should not be trimmed&#x27;, function() {
            input(&#x27;text&#x27;).enter(&#x27;untrimmed &#x27;);
            expect(binding(&#x27;text&#x27;)).toEqual(&#x27;untrimmed &#x27;);
            expect(binding(&#x27;myForm.input.$valid&#x27;)).toEqual(&#x27;true&#x27;);
          });
        &lt;/doc:scenario&gt;
      &lt;/doc:example&gt;
   */
  &#x27;text&#x27;: textInputType,


  /**
   * @ngdoc inputType
   * @name ng.directive:input.number
   *
   * @description
   * Text input with number validation and transformation. Sets the &#x60;number&#x60; validation
   * error if not a valid number.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} min Sets the &#x60;min&#x60; validation error key if the value entered is less than &#x60;min&#x60;.
   * @param {string=} max Sets the &#x60;max&#x60; validation error key if the value entered is greater than &#x60;max&#x60;.
   * @param {string=} required Sets &#x60;required&#x60; validation error key if the value is not entered.
   * @param {string=} ngRequired Adds &#x60;required&#x60; attribute and &#x60;required&#x60; validation constraint to
   *    the element when the ngRequired expression evaluates to true. Use &#x60;ngRequired&#x60; instead of
   *    &#x60;required&#x60; when you want to data-bind to the &#x60;required&#x60; attribute.
   * @param {number=} ngMinlength Sets &#x60;minlength&#x60; validation error key if the value is shorter than
   *    minlength.
   * @param {number=} ngMaxlength Sets &#x60;maxlength&#x60; validation error key if the value is longer than
   *    maxlength.
   * @param {string=} ngPattern Sets &#x60;pattern&#x60; validation error key if the value does not match the
   *    RegExp pattern expression. Expected value is &#x60;/regexp/&#x60; for inline patterns or &#x60;regexp&#x60; for
   *    patterns defined as scope expressions.
   * @param {string=} ngChange Angular expression to be executed when input changes due to user
   *    interaction with the input element.
   *
   * @example
      &lt;doc:example&gt;
        &lt;doc:source&gt;
         &lt;script&gt;
           function Ctrl($scope) {
             $scope.value = 12;
           }
         &lt;/script&gt;
         &lt;form name=&quot;myForm&quot; ng-controller=&quot;Ctrl&quot;&gt;
           Number: &lt;input type=&quot;number&quot; name=&quot;input&quot; ng-model=&quot;value&quot;
                          min=&quot;0&quot; max=&quot;99&quot; required&gt;
           &lt;span class=&quot;error&quot; ng-show=&quot;myForm.list.$error.required&quot;&gt;
             Required!&lt;/span&gt;
           &lt;span class=&quot;error&quot; ng-show=&quot;myForm.list.$error.number&quot;&gt;
             Not valid number!&lt;/span&gt;
           &lt;tt&gt;value = {{value}}&lt;/tt&gt;&lt;br/&gt;
           &lt;tt&gt;myForm.input.$valid = {{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;
           &lt;tt&gt;myForm.input.$error = {{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;
           &lt;tt&gt;myForm.$valid = {{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;
           &lt;tt&gt;myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;
          &lt;/form&gt;
        &lt;/doc:source&gt;
        &lt;doc:scenario&gt;
          it(&#x27;should initialize to model&#x27;, function() {
           expect(binding(&#x27;value&#x27;)).toEqual(&#x27;12&#x27;);
           expect(binding(&#x27;myForm.input.$valid&#x27;)).toEqual(&#x27;true&#x27;);
          });

          it(&#x27;should be invalid if empty&#x27;, function() {
           input(&#x27;value&#x27;).enter(&#x27;&#x27;);
           expect(binding(&#x27;value&#x27;)).toEqual(&#x27;&#x27;);
           expect(binding(&#x27;myForm.input.$valid&#x27;)).toEqual(&#x27;false&#x27;);
          });

          it(&#x27;should be invalid if over max&#x27;, function() {
           input(&#x27;value&#x27;).enter(&#x27;123&#x27;);
           expect(binding(&#x27;value&#x27;)).toEqual(&#x27;&#x27;);
           expect(binding(&#x27;myForm.input.$valid&#x27;)).toEqual(&#x27;false&#x27;);
          });
        &lt;/doc:scenario&gt;
      &lt;/doc:example&gt;
   */
  &#x27;number&#x27;: numberInputType,


  /**
   * @ngdoc inputType
   * @name ng.directive:input.url
   *
   * @description
   * Text input with URL validation. Sets the &#x60;url&#x60; validation error key if the content is not a
   * valid URL.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} required Sets &#x60;required&#x60; validation error key if the value is not entered.
   * @param {string=} ngRequired Adds &#x60;required&#x60; attribute and &#x60;required&#x60; validation constraint to
   *    the element when the ngRequired expression evaluates to true. Use &#x60;ngRequired&#x60; instead of
   *    &#x60;required&#x60; when you want to data-bind to the &#x60;required&#x60; attribute.
   * @param {number=} ngMinlength Sets &#x60;minlength&#x60; validation error key if the value is shorter than
   *    minlength.
   * @param {number=} ngMaxlength Sets &#x60;maxlength&#x60; validation error key if the value is longer than
   *    maxlength.
   * @param {string=} ngPattern Sets &#x60;pattern&#x60; validation error key if the value does not match the
   *    RegExp pattern expression. Expected value is &#x60;/regexp/&#x60; for inline patterns or &#x60;regexp&#x60; for
   *    patterns defined as scope expressions.
   * @param {string=} ngChange Angular expression to be executed when input changes due to user
   *    interaction with the input element.
   *
   * @example
      &lt;doc:example&gt;
        &lt;doc:source&gt;
         &lt;script&gt;
           function Ctrl($scope) {
             $scope.text = &#x27;http://google.com&#x27;;
           }
         &lt;/script&gt;
         &lt;form name=&quot;myForm&quot; ng-controller=&quot;Ctrl&quot;&gt;
           URL: &lt;input type=&quot;url&quot; name=&quot;input&quot; ng-model=&quot;text&quot; required&gt;
           &lt;span class=&quot;error&quot; ng-show=&quot;myForm.input.$error.required&quot;&gt;
             Required!&lt;/span&gt;
           &lt;span class=&quot;error&quot; ng-show=&quot;myForm.input.$error.url&quot;&gt;
             Not valid url!&lt;/span&gt;
           &lt;tt&gt;text = {{text}}&lt;/tt&gt;&lt;br/&gt;
           &lt;tt&gt;myForm.input.$valid = {{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;
           &lt;tt&gt;myForm.input.$error = {{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;
           &lt;tt&gt;myForm.$valid = {{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;
           &lt;tt&gt;myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;
           &lt;tt&gt;myForm.$error.url = {{!!myForm.$error.url}}&lt;/tt&gt;&lt;br/&gt;
          &lt;/form&gt;
        &lt;/doc:source&gt;
        &lt;doc:scenario&gt;
          it(&#x27;should initialize to model&#x27;, function() {
            expect(binding(&#x27;text&#x27;)).toEqual(&#x27;http://google.com&#x27;);
            expect(binding(&#x27;myForm.input.$valid&#x27;)).toEqual(&#x27;true&#x27;);
          });

          it(&#x27;should be invalid if empty&#x27;, function() {
            input(&#x27;text&#x27;).enter(&#x27;&#x27;);
            expect(binding(&#x27;text&#x27;)).toEqual(&#x27;&#x27;);
            expect(binding(&#x27;myForm.input.$valid&#x27;)).toEqual(&#x27;false&#x27;);
          });

          it(&#x27;should be invalid if not url&#x27;, function() {
            input(&#x27;text&#x27;).enter(&#x27;xxx&#x27;);
            expect(binding(&#x27;myForm.input.$valid&#x27;)).toEqual(&#x27;false&#x27;);
          });
        &lt;/doc:scenario&gt;
      &lt;/doc:example&gt;
   */
  &#x27;url&#x27;: urlInputType,


  /**
   * @ngdoc inputType
   * @name ng.directive:input.email
   *
   * @description
   * Text input with email validation. Sets the &#x60;email&#x60; validation error key if not a valid email
   * address.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} required Sets &#x60;required&#x60; validation error key if the value is not entered.
   * @param {string=} ngRequired Adds &#x60;required&#x60; attribute and &#x60;required&#x60; validation constraint to
   *    the element when the ngRequired expression evaluates to true. Use &#x60;ngRequired&#x60; instead of
   *    &#x60;required&#x60; when you want to data-bind to the &#x60;required&#x60; attribute.
   * @param {number=} ngMinlength Sets &#x60;minlength&#x60; validation error key if the value is shorter than
   *    minlength.
   * @param {number=} ngMaxlength Sets &#x60;maxlength&#x60; validation error key if the value is longer than
   *    maxlength.
   * @param {string=} ngPattern Sets &#x60;pattern&#x60; validation error key if the value does not match the
   *    RegExp pattern expression. Expected value is &#x60;/regexp/&#x60; for inline patterns or &#x60;regexp&#x60; for
   *    patterns defined as scope expressions.
   *
   * @example
      &lt;doc:example&gt;
        &lt;doc:source&gt;
         &lt;script&gt;
           function Ctrl($scope) {
             $scope.text = &#x27;me@example.com&#x27;;
           }
         &lt;/script&gt;
           &lt;form name=&quot;myForm&quot; ng-controller=&quot;Ctrl&quot;&gt;
             Email: &lt;input type=&quot;email&quot; name=&quot;input&quot; ng-model=&quot;text&quot; required&gt;
             &lt;span class=&quot;error&quot; ng-show=&quot;myForm.input.$error.required&quot;&gt;
               Required!&lt;/span&gt;
             &lt;span class=&quot;error&quot; ng-show=&quot;myForm.input.$error.email&quot;&gt;
               Not valid email!&lt;/span&gt;
             &lt;tt&gt;text = {{text}}&lt;/tt&gt;&lt;br/&gt;
             &lt;tt&gt;myForm.input.$valid = {{myForm.input.$valid}}&lt;/tt&gt;&lt;br/&gt;
             &lt;tt&gt;myForm.input.$error = {{myForm.input.$error}}&lt;/tt&gt;&lt;br/&gt;
             &lt;tt&gt;myForm.$valid = {{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;
             &lt;tt&gt;myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;
             &lt;tt&gt;myForm.$error.email = {{!!myForm.$error.email}}&lt;/tt&gt;&lt;br/&gt;
           &lt;/form&gt;
        &lt;/doc:source&gt;
        &lt;doc:scenario&gt;
          it(&#x27;should initialize to model&#x27;, function() {
            expect(binding(&#x27;text&#x27;)).toEqual(&#x27;me@example.com&#x27;);
            expect(binding(&#x27;myForm.input.$valid&#x27;)).toEqual(&#x27;true&#x27;);
          });

          it(&#x27;should be invalid if empty&#x27;, function() {
            input(&#x27;text&#x27;).enter(&#x27;&#x27;);
            expect(binding(&#x27;text&#x27;)).toEqual(&#x27;&#x27;);
            expect(binding(&#x27;myForm.input.$valid&#x27;)).toEqual(&#x27;false&#x27;);
          });

          it(&#x27;should be invalid if not email&#x27;, function() {
            input(&#x27;text&#x27;).enter(&#x27;xxx&#x27;);
            expect(binding(&#x27;myForm.input.$valid&#x27;)).toEqual(&#x27;false&#x27;);
          });
        &lt;/doc:scenario&gt;
      &lt;/doc:example&gt;
   */
  &#x27;email&#x27;: emailInputType,


  /**
   * @ngdoc inputType
   * @name ng.directive:input.radio
   *
   * @description
   * HTML radio button.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string} value The value to which the expression should be set when selected.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} ngChange Angular expression to be executed when input changes due to user
   *    interaction with the input element.
   *
   * @example
      &lt;doc:example&gt;
        &lt;doc:source&gt;
         &lt;script&gt;
           function Ctrl($scope) {
             $scope.color = &#x27;blue&#x27;;
           }
         &lt;/script&gt;
         &lt;form name=&quot;myForm&quot; ng-controller=&quot;Ctrl&quot;&gt;
           &lt;input type=&quot;radio&quot; ng-model=&quot;color&quot; value=&quot;red&quot;&gt;  Red &lt;br/&gt;
           &lt;input type=&quot;radio&quot; ng-model=&quot;color&quot; value=&quot;green&quot;&gt; Green &lt;br/&gt;
           &lt;input type=&quot;radio&quot; ng-model=&quot;color&quot; value=&quot;blue&quot;&gt; Blue &lt;br/&gt;
           &lt;tt&gt;color = {{color}}&lt;/tt&gt;&lt;br/&gt;
          &lt;/form&gt;
        &lt;/doc:source&gt;
        &lt;doc:scenario&gt;
          it(&#x27;should change state&#x27;, function() {
            expect(binding(&#x27;color&#x27;)).toEqual(&#x27;blue&#x27;);

            input(&#x27;color&#x27;).select(&#x27;red&#x27;);
            expect(binding(&#x27;color&#x27;)).toEqual(&#x27;red&#x27;);
          });
        &lt;/doc:scenario&gt;
      &lt;/doc:example&gt;
   */
  &#x27;radio&#x27;: radioInputType,


  /**
   * @ngdoc inputType
   * @name ng.directive:input.checkbox
   *
   * @description
   * HTML checkbox.
   *
   * @param {string} ngModel Assignable angular expression to data-bind to.
   * @param {string=} name Property name of the form under which the control is published.
   * @param {string=} ngTrueValue The value to which the expression should be set when selected.
   * @param {string=} ngFalseValue The value to which the expression should be set when not selected.
   * @param {string=} ngChange Angular expression to be executed when input changes due to user
   *    interaction with the input element.
   *
   * @example
      &lt;doc:example&gt;
        &lt;doc:source&gt;
         &lt;script&gt;
           function Ctrl($scope) {
             $scope.value1 = true;
             $scope.value2 = &#x27;YES&#x27;
           }
         &lt;/script&gt;
         &lt;form name=&quot;myForm&quot; ng-controller=&quot;Ctrl&quot;&gt;
           Value1: &lt;input type=&quot;checkbox&quot; ng-model=&quot;value1&quot;&gt; &lt;br/&gt;
           Value2: &lt;input type=&quot;checkbox&quot; ng-model=&quot;value2&quot;
                          ng-true-value=&quot;YES&quot; ng-false-value=&quot;NO&quot;&gt; &lt;br/&gt;
           &lt;tt&gt;value1 = {{value1}}&lt;/tt&gt;&lt;br/&gt;
           &lt;tt&gt;value2 = {{value2}}&lt;/tt&gt;&lt;br/&gt;
          &lt;/form&gt;
        &lt;/doc:source&gt;
        &lt;doc:scenario&gt;
          it(&#x27;should change state&#x27;, function() {
            expect(binding(&#x27;value1&#x27;)).toEqual(&#x27;true&#x27;);
            expect(binding(&#x27;value2&#x27;)).toEqual(&#x27;YES&#x27;);

            input(&#x27;value1&#x27;).check();
            input(&#x27;value2&#x27;).check();
            expect(binding(&#x27;value1&#x27;)).toEqual(&#x27;false&#x27;);
            expect(binding(&#x27;value2&#x27;)).toEqual(&#x27;NO&#x27;);
          });
        &lt;/doc:scenario&gt;
      &lt;/doc:example&gt;
   */
  &#x27;checkbox&#x27;: checkboxInputType,

  &#x27;hidden&#x27;: noop,
  &#x27;button&#x27;: noop,
  &#x27;submit&#x27;: noop,
  &#x27;reset&#x27;: noop
};


function isEmpty(value) {
  return isUndefined(value) || value === &#x27;&#x27; || value === null || value !== value;
}


function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {

  var listener = function() {
    var value = element.val();

    // By default we will trim the value
    // If the attribute ng-trim exists we will avoid trimming
    // e.g. &lt;input ng-model=&quot;foo&quot; ng-trim=&quot;false&quot;&gt;
    if (toBoolean(attr.ngTrim || &#x27;T&#x27;)) {
      value = trim(value);
    }

    if (ctrl.$viewValue !== value) {
      scope.$apply(function() {
        ctrl.$setViewValue(value);
      });
    }
  };

  // if the browser does support &quot;input&quot; event, we are fine - except on IE9 which doesn&#x27;t fire the
  // input event on backspace, delete or cut
  if ($sniffer.hasEvent(&#x27;input&#x27;)) {
    element.bind(&#x27;input&#x27;, listener);
  } else {
    var timeout;

    var deferListener = function() {
      if (!timeout) {
        timeout = $browser.defer(function() {
          listener();
          timeout = null;
        });
      }
    };

    element.bind(&#x27;keydown&#x27;, function(event) {
      var key = event.keyCode;

      // ignore
      //    command            modifiers                   arrows
      if (key === 91 || (15 &lt; key &amp;&amp; key &lt; 19) || (37 &lt;= key &amp;&amp; key &lt;= 40)) return;

      deferListener();
    });

    // if user paste into input using mouse, we need &quot;change&quot; event to catch it
    element.bind(&#x27;change&#x27;, listener);

    // if user modifies input value using context menu in IE, we need &quot;paste&quot; and &quot;cut&quot; events to catch it
    if ($sniffer.hasEvent(&#x27;paste&#x27;)) {
      element.bind(&#x27;paste cut&#x27;, deferListener);
    }
  }


  ctrl.$render = function() {
    element.val(isEmpty(ctrl.$viewValue) ? &#x27;&#x27; : ctrl.$viewValue);
  };

  // pattern validator
  var pattern = attr.ngPattern,
      patternValidator,
      match;

  var validate = function(regexp, value) {
    if (isEmpty(value) || regexp.test(value)) {
      ctrl.$setValidity(&#x27;pattern&#x27;, true);
      return value;
    } else {
      ctrl.$setValidity(&#x27;pattern&#x27;, false);
      return undefined;
    }
  };

  if (pattern) {
    match = pattern.match(/^\/(.*)\/([gim]*)$/);
    if (match) {
      pattern = new RegExp(match[1], match[2]);
      patternValidator = function(value) {
        return validate(pattern, value)
      };
    } else {
      patternValidator = function(value) {
        var patternObj = scope.$eval(pattern);

        if (!patternObj || !patternObj.test) {
          throw new Error(&#x27;Expected &#x27; + pattern + &#x27; to be a RegExp but was &#x27; + patternObj);
        }
        return validate(patternObj, value);
      };
    }

    ctrl.$formatters.push(patternValidator);
    ctrl.$parsers.push(patternValidator);
  }

  // min length validator
  if (attr.ngMinlength) {
    var minlength = int(attr.ngMinlength);
    var minLengthValidator = function(value) {
      if (!isEmpty(value) &amp;&amp; value.length &lt; minlength) {
        ctrl.$setValidity(&#x27;minlength&#x27;, false);
        return undefined;
      } else {
        ctrl.$setValidity(&#x27;minlength&#x27;, true);
        return value;
      }
    };

    ctrl.$parsers.push(minLengthValidator);
    ctrl.$formatters.push(minLengthValidator);
  }

  // max length validator
  if (attr.ngMaxlength) {
    var maxlength = int(attr.ngMaxlength);
    var maxLengthValidator = function(value) {
      if (!isEmpty(value) &amp;&amp; value.length &gt; maxlength) {
        ctrl.$setValidity(&#x27;maxlength&#x27;, false);
        return undefined;
      } else {
        ctrl.$setValidity(&#x27;maxlength&#x27;, true);
        return value;
      }
    };

    ctrl.$parsers.push(maxLengthValidator);
    ctrl.$formatters.push(maxLengthValidator);
  }
}

function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
  textInputType(scope, element, attr, ctrl, $sniffer, $browser);

  ctrl.$parsers.push(function(value) {
    var empty = isEmpty(value);
    if (empty || NUMBER_REGEXP.test(value)) {
      ctrl.$setValidity(&#x27;number&#x27;, true);
      return value === &#x27;&#x27; ? null : (empty ? value : parseFloat(value));
    } else {
      ctrl.$setValidity(&#x27;number&#x27;, false);
      return undefined;
    }
  });

  ctrl.$formatters.push(function(value) {
    return isEmpty(value) ? &#x27;&#x27; : &#x27;&#x27; + value;
  });

  if (attr.min) {
    var min = parseFloat(attr.min);
    var minValidator = function(value) {
      if (!isEmpty(value) &amp;&amp; value &lt; min) {
        ctrl.$setValidity(&#x27;min&#x27;, false);
        return undefined;
      } else {
        ctrl.$setValidity(&#x27;min&#x27;, true);
        return value;
      }
    };

    ctrl.$parsers.push(minValidator);
    ctrl.$formatters.push(minValidator);
  }

  if (attr.max) {
    var max = parseFloat(attr.max);
    var maxValidator = function(value) {
      if (!isEmpty(value) &amp;&amp; value &gt; max) {
        ctrl.$setValidity(&#x27;max&#x27;, false);
        return undefined;
      } else {
        ctrl.$setValidity(&#x27;max&#x27;, true);
        return value;
      }
    };

    ctrl.$parsers.push(maxValidator);
    ctrl.$formatters.push(maxValidator);
  }

  ctrl.$formatters.push(function(value) {

    if (isEmpty(value) || isNumber(value)) {
      ctrl.$setValidity(&#x27;number&#x27;, true);
      return value;
    } else {
      ctrl.$setValidity(&#x27;number&#x27;, false);
      return undefined;
    }
  });
}

function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
  textInputType(scope, element, attr, ctrl, $sniffer, $browser);

  var urlValidator = function(value) {
    if (isEmpty(value) || URL_REGEXP.test(value)) {
      ctrl.$setValidity(&#x27;url&#x27;, true);
      return value;
    } else {
      ctrl.$setValidity(&#x27;url&#x27;, false);
      return undefined;
    }
  };

  ctrl.$formatters.push(urlValidator);
  ctrl.$parsers.push(urlValidator);
}

function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
  textInputType(scope, element, attr, ctrl, $sniffer, $browser);

  var emailValidator = function(value) {
    if (isEmpty(value) || EMAIL_REGEXP.test(value)) {
      ctrl.$setValidity(&#x27;email&#x27;, true);
      return value;
    } else {
      ctrl.$setValidity(&#x27;email&#x27;, false);
      return undefined;
    }
  };

  ctrl.$formatters.push(emailValidator);
  ctrl.$parsers.push(emailValidator);
}

function radioInputType(scope, element, attr, ctrl) {
  // make the name unique, if not defined
  if (isUndefined(attr.name)) {
    element.attr(&#x27;name&#x27;, nextUid());
  }

  element.bind(&#x27;click&#x27;, function() {
    if (element[0].checked) {
      scope.$apply(function() {
        ctrl.$setViewValue(attr.value);
      });
    }
  });

  ctrl.$render = function() {
    var value = attr.value;
    element[0].checked = (value == ctrl.$viewValue);
  };

  attr.$observe(&#x27;value&#x27;, ctrl.$render);
}

function checkboxInputType(scope, element, attr, ctrl) {
  var trueValue = attr.ngTrueValue,
      falseValue = attr.ngFalseValue;

  if (!isString(trueValue)) trueValue = true;
  if (!isString(falseValue)) falseValue = false;

  element.bind(&#x27;click&#x27;, function() {
    scope.$apply(function() {
      ctrl.$setViewValue(element[0].checked);
    });
  });

  ctrl.$render = function() {
    element[0].checked = ctrl.$viewValue;
  };

  ctrl.$formatters.push(function(value) {
    return value === trueValue;
  });

  ctrl.$parsers.push(function(value) {
    return value ? trueValue : falseValue;
  });
}


/**
 * @ngdoc directive
 * @name ng.directive:textarea
 * @restrict E
 *
 * @description
 * HTML textarea element control with angular data-binding. The data-binding and validation
 * properties of this element are exactly the same as those of the
 * {@link ng.directive:input input element}.
 *
 * @param {string} ngModel Assignable angular expression to data-bind to.
 * @param {string=} name Property name of the form under which the control is published.
 * @param {string=} required Sets &#x60;required&#x60; validation error key if the value is not entered.
 * @param {string=} ngRequired Adds &#x60;required&#x60; attribute and &#x60;required&#x60; validation constraint to
 *    the element when the ngRequired expression evaluates to true. Use &#x60;ngRequired&#x60; instead of
 *    &#x60;required&#x60; when you want to data-bind to the &#x60;required&#x60; attribute.
 * @param {number=} ngMinlength Sets &#x60;minlength&#x60; validation error key if the value is shorter than
 *    minlength.
 * @param {number=} ngMaxlength Sets &#x60;maxlength&#x60; validation error key if the value is longer than
 *    maxlength.
 * @param {string=} ngPattern Sets &#x60;pattern&#x60; validation error key if the value does not match the
 *    RegExp pattern expression. Expected value is &#x60;/regexp/&#x60; for inline patterns or &#x60;regexp&#x60; for
 *    patterns defined as scope expressions.
 * @param {string=} ngChange Angular expression to be executed when input changes due to user
 *    interaction with the input element.
 */


/**
 * @ngdoc directive
 * @name ng.directive:input
 * @restrict E
 *
 * @description
 * HTML input element control with angular data-binding. Input control follows HTML5 input types
 * and polyfills the HTML5 validation behavior for older browsers.
 *
 * @param {string} ngModel Assignable angular expression to data-bind to.
 * @param {string=} name Property name of the form under which the control is published.
 * @param {string=} required Sets &#x60;required&#x60; validation error key if the value is not entered.
 * @param {boolean=} ngRequired Sets &#x60;required&#x60; attribute if set to true
 * @param {number=} ngMinlength Sets &#x60;minlength&#x60; validation error key if the value is shorter than
 *    minlength.
 * @param {number=} ngMaxlength Sets &#x60;maxlength&#x60; validation error key if the value is longer than
 *    maxlength.
 * @param {string=} ngPattern Sets &#x60;pattern&#x60; validation error key if the value does not match the
 *    RegExp pattern expression. Expected value is &#x60;/regexp/&#x60; for inline patterns or &#x60;regexp&#x60; for
 *    patterns defined as scope expressions.
 * @param {string=} ngChange Angular expression to be executed when input changes due to user
 *    interaction with the input element.
 *
 * @example
    &lt;doc:example&gt;
      &lt;doc:source&gt;
       &lt;script&gt;
         function Ctrl($scope) {
           $scope.user = {name: &#x27;guest&#x27;, last: &#x27;visitor&#x27;};
         }
       &lt;/script&gt;
       &lt;div ng-controller=&quot;Ctrl&quot;&gt;
         &lt;form name=&quot;myForm&quot;&gt;
           User name: &lt;input type=&quot;text&quot; name=&quot;userName&quot; ng-model=&quot;user.name&quot; required&gt;
           &lt;span class=&quot;error&quot; ng-show=&quot;myForm.userName.$error.required&quot;&gt;
             Required!&lt;/span&gt;&lt;br&gt;
           Last name: &lt;input type=&quot;text&quot; name=&quot;lastName&quot; ng-model=&quot;user.last&quot;
             ng-minlength=&quot;3&quot; ng-maxlength=&quot;10&quot;&gt;
           &lt;span class=&quot;error&quot; ng-show=&quot;myForm.lastName.$error.minlength&quot;&gt;
             Too short!&lt;/span&gt;
           &lt;span class=&quot;error&quot; ng-show=&quot;myForm.lastName.$error.maxlength&quot;&gt;
             Too long!&lt;/span&gt;&lt;br&gt;
         &lt;/form&gt;
         &lt;hr&gt;
         &lt;tt&gt;user = {{user}}&lt;/tt&gt;&lt;br/&gt;
         &lt;tt&gt;myForm.userName.$valid = {{myForm.userName.$valid}}&lt;/tt&gt;&lt;br&gt;
         &lt;tt&gt;myForm.userName.$error = {{myForm.userName.$error}}&lt;/tt&gt;&lt;br&gt;
         &lt;tt&gt;myForm.lastName.$valid = {{myForm.lastName.$valid}}&lt;/tt&gt;&lt;br&gt;
         &lt;tt&gt;myForm.lastName.$error = {{myForm.lastName.$error}}&lt;/tt&gt;&lt;br&gt;
         &lt;tt&gt;myForm.$valid = {{myForm.$valid}}&lt;/tt&gt;&lt;br&gt;
         &lt;tt&gt;myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt&gt;&lt;br&gt;
         &lt;tt&gt;myForm.$error.minlength = {{!!myForm.$error.minlength}}&lt;/tt&gt;&lt;br&gt;
         &lt;tt&gt;myForm.$error.maxlength = {{!!myForm.$error.maxlength}}&lt;/tt&gt;&lt;br&gt;
       &lt;/div&gt;
      &lt;/doc:source&gt;
      &lt;doc:scenario&gt;
        it(&#x27;should initialize to model&#x27;, function() {
          expect(binding(&#x27;user&#x27;)).toEqual(&#x27;{&quot;name&quot;:&quot;guest&quot;,&quot;last&quot;:&quot;visitor&quot;}&#x27;);
          expect(binding(&#x27;myForm.userName.$valid&#x27;)).toEqual(&#x27;true&#x27;);
          expect(binding(&#x27;myForm.$valid&#x27;)).toEqual(&#x27;true&#x27;);
        });

        it(&#x27;should be invalid if empty when required&#x27;, function() {
          input(&#x27;user.name&#x27;).enter(&#x27;&#x27;);
          expect(binding(&#x27;user&#x27;)).toEqual(&#x27;{&quot;last&quot;:&quot;visitor&quot;}&#x27;);
          expect(binding(&#x27;myForm.userName.$valid&#x27;)).toEqual(&#x27;false&#x27;);
          expect(binding(&#x27;myForm.$valid&#x27;)).toEqual(&#x27;false&#x27;);
        });

        it(&#x27;should be valid if empty when min length is set&#x27;, function() {
          input(&#x27;user.last&#x27;).enter(&#x27;&#x27;);
          expect(binding(&#x27;user&#x27;)).toEqual(&#x27;{&quot;name&quot;:&quot;guest&quot;,&quot;last&quot;:&quot;&quot;}&#x27;);
          expect(binding(&#x27;myForm.lastName.$valid&#x27;)).toEqual(&#x27;true&#x27;);
          expect(binding(&#x27;myForm.$valid&#x27;)).toEqual(&#x27;true&#x27;);
        });

        it(&#x27;should be invalid if less than required min length&#x27;, function() {
          input(&#x27;user.last&#x27;).enter(&#x27;xx&#x27;);
          expect(binding(&#x27;user&#x27;)).toEqual(&#x27;{&quot;name&quot;:&quot;guest&quot;}&#x27;);
          expect(binding(&#x27;myForm.lastName.$valid&#x27;)).toEqual(&#x27;false&#x27;);
          expect(binding(&#x27;myForm.lastName.$error&#x27;)).toMatch(/minlength/);
          expect(binding(&#x27;myForm.$valid&#x27;)).toEqual(&#x27;false&#x27;);
        });

        it(&#x27;should be invalid if longer than max length&#x27;, function() {
          input(&#x27;user.last&#x27;).enter(&#x27;some ridiculously long name&#x27;);
          expect(binding(&#x27;user&#x27;))
            .toEqual(&#x27;{&quot;name&quot;:&quot;guest&quot;}&#x27;);
          expect(binding(&#x27;myForm.lastName.$valid&#x27;)).toEqual(&#x27;false&#x27;);
          expect(binding(&#x27;myForm.lastName.$error&#x27;)).toMatch(/maxlength/);
          expect(binding(&#x27;myForm.$valid&#x27;)).toEqual(&#x27;false&#x27;);
        });
      &lt;/doc:scenario&gt;
    &lt;/doc:example&gt;
 */
var inputDirective = [&#x27;$browser&#x27;, &#x27;$sniffer&#x27;, function($browser, $sniffer) {
  return {
    restrict: &#x27;E&#x27;,
    require: &#x27;?ngModel&#x27;,
    link: function(scope, element, attr, ctrl) {
      if (ctrl) {
        (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer,
                                                            $browser);
      }
    }
  };
}];

var VALID_CLASS = &#x27;ng-valid&#x27;,
    INVALID_CLASS = &#x27;ng-invalid&#x27;,
    PRISTINE_CLASS = &#x27;ng-pristine&#x27;,
    DIRTY_CLASS = &#x27;ng-dirty&#x27;;

/**
 * @ngdoc object
 * @name ng.directive:ngModel.NgModelController
 *
 * @property {string} $viewValue Actual string value in the view.
 * @property {*} $modelValue The value in the model, that the control is bound to.
 * @property {Array.&lt;Function&gt;} $parsers Whenever the control reads value from the DOM, it executes
 *     all of these functions to sanitize / convert the value as well as validate.
 *
 * @property {Array.&lt;Function&gt;} $formatters Whenever the model value changes, it executes all of
 *     these functions to convert the value as well as validate.
 *
 * @property {Object} $error An object hash with all errors as keys.
 *
 * @property {boolean} $pristine True if user has not interacted with the control yet.
 * @property {boolean} $dirty True if user has already interacted with the control.
 * @property {boolean} $valid True if there is no error.
 * @property {boolean} $invalid True if at least one error on the control.
 *
 * @description
 *
 * &#x60;NgModelController&#x60; provides API for the &#x60;ng-model&#x60; directive. The controller contains
 * services for data-binding, validation, CSS update, value formatting and parsing. It
 * specifically does not contain any logic which deals with DOM rendering or listening to
 * DOM events. The &#x60;NgModelController&#x60; is meant to be extended by other directives where, the
 * directive provides DOM manipulation and the &#x60;NgModelController&#x60; provides the data-binding.
 *
 * This example shows how to use &#x60;NgModelController&#x60; with a custom control to achieve
 * data-binding. Notice how different directives (&#x60;contenteditable&#x60;, &#x60;ng-model&#x60;, and &#x60;required&#x60;)
 * collaborate together to achieve the desired result.
 *
 * &lt;example module=&quot;customControl&quot;&gt;
    &lt;file name=&quot;style.css&quot;&gt;
      [contenteditable] {
        border: 1px solid black;
        background-color: white;
        min-height: 20px;
      }

      .ng-invalid {
        border: 1px solid red;
      }

    &lt;/file&gt;
    &lt;file name=&quot;script.js&quot;&gt;
      angular.module(&#x27;customControl&#x27;, []).
        directive(&#x27;contenteditable&#x27;, function() {
          return {
            restrict: &#x27;A&#x27;, // only activate on element attribute
            require: &#x27;?ngModel&#x27;, // get a hold of NgModelController
            link: function(scope, element, attrs, ngModel) {
              if(!ngModel) return; // do nothing if no ng-model

              // Specify how UI should be updated
              ngModel.$render = function() {
                element.html(ngModel.$viewValue || &#x27;&#x27;);
              };

              // Listen for change events to enable binding
              element.bind(&#x27;blur keyup change&#x27;, function() {
                scope.$apply(read);
              });
              read(); // initialize

              // Write data to the model
              function read() {
                ngModel.$setViewValue(element.html());
              }
            }
          };
        });
    &lt;/file&gt;
    &lt;file name=&quot;index.html&quot;&gt;
      &lt;form name=&quot;myForm&quot;&gt;
       &lt;div contenteditable
            name=&quot;myWidget&quot; ng-model=&quot;userContent&quot;
            required&gt;Change me!&lt;/div&gt;
        &lt;span ng-show=&quot;myForm.myWidget.$error.required&quot;&gt;Required!&lt;/span&gt;
       &lt;hr&gt;
       &lt;textarea ng-model=&quot;userContent&quot;&gt;&lt;/textarea&gt;
      &lt;/form&gt;
    &lt;/file&gt;
    &lt;file name=&quot;scenario.js&quot;&gt;
      it(&#x27;should data-bind and become invalid&#x27;, function() {
        var contentEditable = element(&#x27;[contenteditable]&#x27;);

        expect(contentEditable.text()).toEqual(&#x27;Change me!&#x27;);
        input(&#x27;userContent&#x27;).enter(&#x27;&#x27;);
        expect(contentEditable.text()).toEqual(&#x27;&#x27;);
        expect(contentEditable.prop(&#x27;className&#x27;)).toMatch(/ng-invalid-required/);
      });
    &lt;/file&gt;
 * &lt;/example&gt;
 *
 */
var NgModelController = [&#x27;$scope&#x27;, &#x27;$exceptionHandler&#x27;, &#x27;$attrs&#x27;, &#x27;$element&#x27;, &#x27;$parse&#x27;,
    function($scope, $exceptionHandler, $attr, $element, $parse) {
  this.$viewValue = Number.NaN;
  this.$modelValue = Number.NaN;
  this.$parsers = [];
  this.$formatters = [];
  this.$viewChangeListeners = [];
  this.$pristine = true;
  this.$dirty = false;
  this.$valid = true;
  this.$invalid = false;
  this.$name = $attr.name;

  var ngModelGet = $parse($attr.ngModel),
      ngModelSet = ngModelGet.assign;

  if (!ngModelSet) {
    throw Error(NON_ASSIGNABLE_MODEL_EXPRESSION + $attr.ngModel +
        &#x27; (&#x27; + startingTag($element) + &#x27;)&#x27;);
  }

  /**
   * @ngdoc function
   * @name ng.directive:ngModel.NgModelController#$render
   * @methodOf ng.directive:ngModel.NgModelController
   *
   * @description
   * Called when the view needs to be updated. It is expected that the user of the ng-model
   * directive will implement this method.
   */
  this.$render = noop;

  var parentForm = $element.inheritedData(&#x27;$formController&#x27;) || nullFormCtrl,
      invalidCount = 0, // used to easily determine if we are valid
      $error = this.$error = {}; // keep invalid keys here


  // Setup initial state of the control
  $element.addClass(PRISTINE_CLASS);
  toggleValidCss(true);

  // convenience method for easy toggling of classes
  function toggleValidCss(isValid, validationErrorKey) {
    validationErrorKey = validationErrorKey ? &#x27;-&#x27; + snake_case(validationErrorKey, &#x27;-&#x27;) : &#x27;&#x27;;
    $element.
      removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).
      addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
  }

  /**
   * @ngdoc function
   * @name ng.directive:ngModel.NgModelController#$setValidity
   * @methodOf ng.directive:ngModel.NgModelController
   *
   * @description
   * Change the validity state, and notifies the form when the control changes validity. (i.e. it
   * does not notify form if given validator is already marked as invalid).
   *
   * This method should be called by validators - i.e. the parser or formatter functions.
   *
   * @param {string} validationErrorKey Name of the validator. the &#x60;validationErrorKey&#x60; will assign
   *        to &#x60;$error[validationErrorKey]=isValid&#x60; so that it is available for data-binding.
   *        The &#x60;validationErrorKey&#x60; should be in camelCase and will get converted into dash-case
   *        for class name. Example: &#x60;myError&#x60; will result in &#x60;ng-valid-my-error&#x60; and &#x60;ng-invalid-my-error&#x60;
   *        class and can be bound to as  &#x60;{{someForm.someControl.$error.myError}}&#x60; .
   * @param {boolean} isValid Whether the current state is valid (true) or invalid (false).
   */
  this.$setValidity = function(validationErrorKey, isValid) {
    if ($error[validationErrorKey] === !isValid) return;

    if (isValid) {
      if ($error[validationErrorKey]) invalidCount--;
      if (!invalidCount) {
        toggleValidCss(true);
        this.$valid = true;
        this.$invalid = false;
      }
    } else {
      toggleValidCss(false);
      this.$invalid = true;
      this.$valid = false;
      invalidCount++;
    }

    $error[validationErrorKey] = !isValid;
    toggleValidCss(isValid, validationErrorKey);

    parentForm.$setValidity(validationErrorKey, isValid, this);
  };

  /**
   * @ngdoc function
   * @name ng.directive:ngModel.NgModelController#$setPristine
   * @methodOf ng.directive:ngModel.NgModelController
   *
   * @description
   * Sets the control to its pristine state.
   *
   * This method can be called to remove the &#x27;ng-dirty&#x27; class and set the control to its pristine
   * state (ng-pristine class).
   */
  this.$setPristine = function () {
    this.$dirty = false;
    this.$pristine = true;
    $element.removeClass(DIRTY_CLASS).addClass(PRISTINE_CLASS);
  };

  /**
   * @ngdoc function
   * @name ng.directive:ngModel.NgModelController#$setViewValue
   * @methodOf ng.directive:ngModel.NgModelController
   *
   * @description
   * Read a value from view.
   *
   * This method should be called from within a DOM event handler.
   * For example {@link ng.directive:input input} or
   * {@link ng.directive:select select} directives call it.
   *
   * It internally calls all &#x60;parsers&#x60; and if resulted value is valid, updates the model and
   * calls all registered change listeners.
   *
   * @param {string} value Value from the view.
   */
  this.$setViewValue = function(value) {
    this.$viewValue = value;

    // change to dirty
    if (this.$pristine) {
      this.$dirty = true;
      this.$pristine = false;
      $element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
      parentForm.$setDirty();
    }

    forEach(this.$parsers, function(fn) {
      value = fn(value);
    });

    if (this.$modelValue !== value) {
      this.$modelValue = value;
      ngModelSet($scope, value);
      forEach(this.$viewChangeListeners, function(listener) {
        try {
          listener();
        } catch(e) {
          $exceptionHandler(e);
        }
      })
    }
  };

  // model -&gt; value
  var ctrl = this;

  $scope.$watch(function ngModelWatch() {
    var value = ngModelGet($scope);

    // if scope model value and ngModel value are out of sync
    if (ctrl.$modelValue !== value) {

      var formatters = ctrl.$formatters,
          idx = formatters.length;

      ctrl.$modelValue = value;
      while(idx--) {
        value = formatters[idx](value);
      }

      if (ctrl.$viewValue !== value) {
        ctrl.$viewValue = value;
        ctrl.$render();
      }
    }
  });
}];


/**
 * @ngdoc directive
 * @name ng.directive:ngModel
 *
 * @element input
 *
 * @description
 * Is directive that tells Angular to do two-way data binding. It works together with &#x60;input&#x60;,
 * &#x60;select&#x60;, &#x60;textarea&#x60;. You can easily write your own directives to use &#x60;ngModel&#x60; as well.
 *
 * &#x60;ngModel&#x60; is responsible for:
 *
 * - binding the view into the model, which other directives such as &#x60;input&#x60;, &#x60;textarea&#x60; or &#x60;select&#x60;
 *   require,
 * - providing validation behavior (i.e. required, number, email, url),
 * - keeping state of the control (valid/invalid, dirty/pristine, validation errors),
 * - setting related css class onto the element (&#x60;ng-valid&#x60;, &#x60;ng-invalid&#x60;, &#x60;ng-dirty&#x60;, &#x60;ng-pristine&#x60;),
 * - register the control with parent {@link ng.directive:form form}.
 *
 * For basic examples, how to use &#x60;ngModel&#x60;, see:
 *
 *  - {@link ng.directive:input input}
 *    - {@link ng.directive:input.text text}
 *    - {@link ng.directive:input.checkbox checkbox}
 *    - {@link ng.directive:input.radio radio}
 *    - {@link ng.directive:input.number number}
 *    - {@link ng.directive:input.email email}
 *    - {@link ng.directive:input.url url}
 *  - {@link ng.directive:select select}
 *  - {@link ng.directive:textarea textarea}
 *
 */
var ngModelDirective = function() {
  return {
    require: [&#x27;ngModel&#x27;, &#x27;^?form&#x27;],
    controller: NgModelController,
    link: function(scope, element, attr, ctrls) {
      // notify others, especially parent forms

      var modelCtrl = ctrls[0],
          formCtrl = ctrls[1] || nullFormCtrl;

      formCtrl.$addControl(modelCtrl);

      element.bind(&#x27;$destroy&#x27;, function() {
        formCtrl.$removeControl(modelCtrl);
      });
    }
  };
};


/**
 * @ngdoc directive
 * @name ng.directive:ngChange
 * @restrict E
 *
 * @description
 * Evaluate given expression when user changes the input.
 * The expression is not evaluated when the value change is coming from the model.
 *
 * Note, this directive requires &#x60;ngModel&#x60; to be present.
 *
 * @element input
 *
 * @example
 * &lt;doc:example&gt;
 *   &lt;doc:source&gt;
 *     &lt;script&gt;
 *       function Controller($scope) {
 *         $scope.counter = 0;
 *         $scope.change = function() {
 *           $scope.counter++;
 *         };
 *       }
 *     &lt;/script&gt;
 *     &lt;div ng-controller=&quot;Controller&quot;&gt;
 *       &lt;input type=&quot;checkbox&quot; ng-model=&quot;confirmed&quot; ng-change=&quot;change()&quot; id=&quot;ng-change-example1&quot; /&gt;
 *       &lt;input type=&quot;checkbox&quot; ng-model=&quot;confirmed&quot; id=&quot;ng-change-example2&quot; /&gt;
 *       &lt;label for=&quot;ng-change-example2&quot;&gt;Confirmed&lt;/label&gt;&lt;br /&gt;
 *       debug = {{confirmed}}&lt;br /&gt;
 *       counter = {{counter}}
 *     &lt;/div&gt;
 *   &lt;/doc:source&gt;
 *   &lt;doc:scenario&gt;
 *     it(&#x27;should evaluate the expression if changing from view&#x27;, function() {
 *       expect(binding(&#x27;counter&#x27;)).toEqual(&#x27;0&#x27;);
 *       element(&#x27;#ng-change-example1&#x27;).click();
 *       expect(binding(&#x27;counter&#x27;)).toEqual(&#x27;1&#x27;);
 *       expect(binding(&#x27;confirmed&#x27;)).toEqual(&#x27;true&#x27;);
 *     });
 *
 *     it(&#x27;should not evaluate the expression if changing from model&#x27;, function() {
 *       element(&#x27;#ng-change-example2&#x27;).click();
 *       expect(binding(&#x27;counter&#x27;)).toEqual(&#x27;0&#x27;);
 *       expect(binding(&#x27;confirmed&#x27;)).toEqual(&#x27;true&#x27;);
 *     });
 *   &lt;/doc:scenario&gt;
 * &lt;/doc:example&gt;
 */
var ngChangeDirective = valueFn({
  require: &#x27;ngModel&#x27;,
  link: function(scope, element, attr, ctrl) {
    ctrl.$viewChangeListeners.push(function() {
      scope.$eval(attr.ngChange);
    });
  }
});


var requiredDirective = function() {
  return {
    require: &#x27;?ngModel&#x27;,
    link: function(scope, elm, attr, ctrl) {
      if (!ctrl) return;
      attr.required = true; // force truthy in case we are on non input element

      var validator = function(value) {
        if (attr.required &amp;&amp; (isEmpty(value) || value === false)) {
          ctrl.$setValidity(&#x27;required&#x27;, false);
          return;
        } else {
          ctrl.$setValidity(&#x27;required&#x27;, true);
          return value;
        }
      };

      ctrl.$formatters.push(validator);
      ctrl.$parsers.unshift(validator);

      attr.$observe(&#x27;required&#x27;, function() {
        validator(ctrl.$viewValue);
      });
    }
  };
};


/**
 * @ngdoc directive
 * @name ng.directive:ngList
 *
 * @description
 * Text input that converts between comma-separated string into an array of strings.
 *
 * @element input
 * @param {string=} ngList optional delimiter that should be used to split the value. If
 *   specified in form &#x60;/something/&#x60; then the value will be converted into a regular expression.
 *
 * @example
    &lt;doc:example&gt;
      &lt;doc:source&gt;
       &lt;script&gt;
         function Ctrl($scope) {
           $scope.names = [&#x27;igor&#x27;, &#x27;misko&#x27;, &#x27;vojta&#x27;];
         }
       &lt;/script&gt;
       &lt;form name=&quot;myForm&quot; ng-controller=&quot;Ctrl&quot;&gt;
         List: &lt;input name=&quot;namesInput&quot; ng-model=&quot;names&quot; ng-list required&gt;
         &lt;span class=&quot;error&quot; ng-show=&quot;myForm.list.$error.required&quot;&gt;
           Required!&lt;/span&gt;
         &lt;tt&gt;names = {{names}}&lt;/tt&gt;&lt;br/&gt;
         &lt;tt&gt;myForm.namesInput.$valid = {{myForm.namesInput.$valid}}&lt;/tt&gt;&lt;br/&gt;
         &lt;tt&gt;myForm.namesInput.$error = {{myForm.namesInput.$error}}&lt;/tt&gt;&lt;br/&gt;
         &lt;tt&gt;myForm.$valid = {{myForm.$valid}}&lt;/tt&gt;&lt;br/&gt;
         &lt;tt&gt;myForm.$error.required = {{!!myForm.$error.required}}&lt;/tt&gt;&lt;br/&gt;
        &lt;/form&gt;
      &lt;/doc:source&gt;
      &lt;doc:scenario&gt;
        it(&#x27;should initialize to model&#x27;, function() {
          expect(binding(&#x27;names&#x27;)).toEqual(&#x27;[&quot;igor&quot;,&quot;misko&quot;,&quot;vojta&quot;]&#x27;);
          expect(binding(&#x27;myForm.namesInput.$valid&#x27;)).toEqual(&#x27;true&#x27;);
        });

        it(&#x27;should be invalid if empty&#x27;, function() {
          input(&#x27;names&#x27;).enter(&#x27;&#x27;);
          expect(binding(&#x27;names&#x27;)).toEqual(&#x27;[]&#x27;);
          expect(binding(&#x27;myForm.namesInput.$valid&#x27;)).toEqual(&#x27;false&#x27;);
        });
      &lt;/doc:scenario&gt;
    &lt;/doc:example&gt;
 */
var ngListDirective = function() {
  return {
    require: &#x27;ngModel&#x27;,
    link: function(scope, element, attr, ctrl) {
      var match = /\/(.*)\//.exec(attr.ngList),
          separator = match &amp;&amp; new RegExp(match[1]) || attr.ngList || &#x27;,&#x27;;

      var parse = function(viewValue) {
        var list = [];

        if (viewValue) {
          forEach(viewValue.split(separator), function(value) {
            if (value) list.push(trim(value));
          });
        }

        return list;
      };

      ctrl.$parsers.push(parse);
      ctrl.$formatters.push(function(value) {
        if (isArray(value)) {
          return value.join(&#x27;, &#x27;);
        }

        return undefined;
      });
    }
  };
};


var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;

var ngValueDirective = function() {
  return {
    priority: 100,
    compile: function(tpl, tplAttr) {
      if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
        return function(scope, elm, attr) {
          attr.$set(&#x27;value&#x27;, scope.$eval(attr.ngValue));
        };
      } else {
        return function(scope, elm, attr) {
          scope.$watch(attr.ngValue, function valueWatchAction(value) {
            attr.$set(&#x27;value&#x27;, value, false);
          });
        };
      }
    }
  };
};

/**
 * @ngdoc directive
 * @name ng.directive:ngBind
 *
 * @description
 * The &#x60;ngBind&#x60; attribute tells Angular to replace the text content of the specified HTML element
 * with the value of a given expression, and to update the text content when the value of that
 * expression changes.
 *
 * Typically, you don&#x27;t use &#x60;ngBind&#x60; directly, but instead you use the double curly markup like
 * &#x60;{{ expression }}&#x60; which is similar but less verbose.
 *
 * One scenario in which the use of &#x60;ngBind&#x60; is preferred over &#x60;{{ expression }}&#x60; binding is when
 * it&#x27;s desirable to put bindings into template that is momentarily displayed by the browser in its
 * raw state before Angular compiles it. Since &#x60;ngBind&#x60; is an element attribute, it makes the
 * bindings invisible to the user while the page is loading.
 *
 * An alternative solution to this problem would be using the
 * {@link ng.directive:ngCloak ngCloak} directive.
 *
 *
 * @element ANY
 * @param {expression} ngBind {@link guide/expression Expression} to evaluate.
 *
 * @example
 * Enter a name in the Live Preview text box; the greeting below the text box changes instantly.
   &lt;doc:example&gt;
     &lt;doc:source&gt;
       &lt;script&gt;
         function Ctrl($scope) {
           $scope.name = &#x27;Whirled&#x27;;
         }
       &lt;/script&gt;
       &lt;div ng-controller=&quot;Ctrl&quot;&gt;
         Enter name: &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;br&gt;
         Hello &lt;span ng-bind=&quot;name&quot;&gt;&lt;/span&gt;!
       &lt;/div&gt;
     &lt;/doc:source&gt;
     &lt;doc:scenario&gt;
       it(&#x27;should check ng-bind&#x27;, function() {
         expect(using(&#x27;.doc-example-live&#x27;).binding(&#x27;name&#x27;)).toBe(&#x27;Whirled&#x27;);
         using(&#x27;.doc-example-live&#x27;).input(&#x27;name&#x27;).enter(&#x27;world&#x27;);
         expect(using(&#x27;.doc-example-live&#x27;).binding(&#x27;name&#x27;)).toBe(&#x27;world&#x27;);
       });
     &lt;/doc:scenario&gt;
   &lt;/doc:example&gt;
 */
var ngBindDirective = ngDirective(function(scope, element, attr) {
  element.addClass(&#x27;ng-binding&#x27;).data(&#x27;$binding&#x27;, attr.ngBind);
  scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
    element.text(value == undefined ? &#x27;&#x27; : value);
  });
});


/**
 * @ngdoc directive
 * @name ng.directive:ngBindTemplate
 *
 * @description
 * The &#x60;ngBindTemplate&#x60; directive specifies that the element
 * text should be replaced with the template in ngBindTemplate.
 * Unlike ngBind the ngBindTemplate can contain multiple &#x60;{{&#x60; &#x60;}}&#x60;
 * expressions. (This is required since some HTML elements
 * can not have SPAN elements such as TITLE, or OPTION to name a few.)
 *
 * @element ANY
 * @param {string} ngBindTemplate template of form
 *   &lt;tt&gt;{{&lt;/tt&gt; &lt;tt&gt;expression&lt;/tt&gt; &lt;tt&gt;}}&lt;/tt&gt; to eval.
 *
 * @example
 * Try it here: enter text in text box and watch the greeting change.
   &lt;doc:example&gt;
     &lt;doc:source&gt;
       &lt;script&gt;
         function Ctrl($scope) {
           $scope.salutation = &#x27;Hello&#x27;;
           $scope.name = &#x27;World&#x27;;
         }
       &lt;/script&gt;
       &lt;div ng-controller=&quot;Ctrl&quot;&gt;
        Salutation: &lt;input type=&quot;text&quot; ng-model=&quot;salutation&quot;&gt;&lt;br&gt;
        Name: &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;&lt;br&gt;
        &lt;pre ng-bind-template=&quot;{{salutation}} {{name}}!&quot;&gt;&lt;/pre&gt;
       &lt;/div&gt;
     &lt;/doc:source&gt;
     &lt;doc:scenario&gt;
       it(&#x27;should check ng-bind&#x27;, function() {
         expect(using(&#x27;.doc-example-live&#x27;).binding(&#x27;salutation&#x27;)).
           toBe(&#x27;Hello&#x27;);
         expect(using(&#x27;.doc-example-live&#x27;).binding(&#x27;name&#x27;)).
           toBe(&#x27;World&#x27;);
         using(&#x27;.doc-example-live&#x27;).input(&#x27;salutation&#x27;).enter(&#x27;Greetings&#x27;);
         using(&#x27;.doc-example-live&#x27;).input(&#x27;name&#x27;).enter(&#x27;user&#x27;);
         expect(using(&#x27;.doc-example-live&#x27;).binding(&#x27;salutation&#x27;)).
           toBe(&#x27;Greetings&#x27;);
         expect(using(&#x27;.doc-example-live&#x27;).binding(&#x27;name&#x27;)).
           toBe(&#x27;user&#x27;);
       });
     &lt;/doc:scenario&gt;
   &lt;/doc:example&gt;
 */
var ngBindTemplateDirective = [&#x27;$interpolate&#x27;, function($interpolate) {
  return function(scope, element, attr) {
    // TODO: move this to scenario runner
    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
    element.addClass(&#x27;ng-binding&#x27;).data(&#x27;$binding&#x27;, interpolateFn);
    attr.$observe(&#x27;ngBindTemplate&#x27;, function(value) {
      element.text(value);
    });
  }
}];


/**
 * @ngdoc directive
 * @name ng.directive:ngBindHtmlUnsafe
 *
 * @description
 * Creates a binding that will innerHTML the result of evaluating the &#x60;expression&#x60; into the current
 * element. *The innerHTML-ed content will not be sanitized!* You should use this directive only if
 * {@link ngSanitize.directive:ngBindHtml ngBindHtml} directive is too
 * restrictive and when you absolutely trust the source of the content you are binding to.
 *
 * See {@link ngSanitize.$sanitize $sanitize} docs for examples.
 *
 * @element ANY
 * @param {expression} ngBindHtmlUnsafe {@link guide/expression Expression} to evaluate.
 */
var ngBindHtmlUnsafeDirective = [function() {
  return function(scope, element, attr) {
    element.addClass(&#x27;ng-binding&#x27;).data(&#x27;$binding&#x27;, attr.ngBindHtmlUnsafe);
    scope.$watch(attr.ngBindHtmlUnsafe, function ngBindHtmlUnsafeWatchAction(value) {
      element.html(value || &#x27;&#x27;);
    });
  };
}];

function classDirective(name, selector) {
  name = &#x27;ngClass&#x27; + name;
  return ngDirective(function(scope, element, attr) {
    var oldVal = undefined;

    scope.$watch(attr[name], ngClassWatchAction, true);

    attr.$observe(&#x27;class&#x27;, function(value) {
      var ngClass = scope.$eval(attr[name]);
      ngClassWatchAction(ngClass, ngClass);
    });


    if (name !== &#x27;ngClass&#x27;) {
      scope.$watch(&#x27;$index&#x27;, function($index, old$index) {
        var mod = $index &amp; 1;
        if (mod !== old$index &amp; 1) {
          if (mod === selector) {
            addClass(scope.$eval(attr[name]));
          } else {
            removeClass(scope.$eval(attr[name]));
          }
        }
      });
    }


    function ngClassWatchAction(newVal) {
      if (selector === true || scope.$index % 2 === selector) {
        if (oldVal &amp;&amp; !equals(newVal,oldVal)) {
          removeClass(oldVal);
        }
        addClass(newVal);
      }
      oldVal = copy(newVal);
    }


    function removeClass(classVal) {
      if (isObject(classVal) &amp;&amp; !isArray(classVal)) {
        classVal = map(classVal, function(v, k) { if (v) return k });
      }
      element.removeClass(isArray(classVal) ? classVal.join(&#x27; &#x27;) : classVal);
    }


    function addClass(classVal) {
      if (isObject(classVal) &amp;&amp; !isArray(classVal)) {
        classVal = map(classVal, function(v, k) { if (v) return k });
      }
      if (classVal) {
        element.addClass(isArray(classVal) ? classVal.join(&#x27; &#x27;) : classVal);
      }
    }
  });
}

/**
 * @ngdoc directive
 * @name ng.directive:ngClass
 *
 * @description
 * The &#x60;ngClass&#x60; allows you to set CSS class on HTML element dynamically by databinding an
 * expression that represents all classes to be added.
 *
 * The directive won&#x27;t add duplicate classes if a particular class was already set.
 *
 * When the expression changes, the previously added classes are removed and only then the
 * new classes are added.
 *
 * @element ANY
 * @param {expression} ngClass {@link guide/expression Expression} to eval. The result
 *   of the evaluation can be a string representing space delimited class
 *   names, an array, or a map of class names to boolean values.
 *
 * @example
   &lt;example&gt;
     &lt;file name=&quot;index.html&quot;&gt;
      &lt;input type=&quot;button&quot; value=&quot;set&quot; ng-click=&quot;myVar=&#x27;my-class&#x27;&quot;&gt;
      &lt;input type=&quot;button&quot; value=&quot;clear&quot; ng-click=&quot;myVar=&#x27;&#x27;&quot;&gt;
      &lt;br&gt;
      &lt;span ng-class=&quot;myVar&quot;&gt;Sample Text&lt;/span&gt;
     &lt;/file&gt;
     &lt;file name=&quot;style.css&quot;&gt;
       .my-class {
         color: red;
       }
     &lt;/file&gt;
     &lt;file name=&quot;scenario.js&quot;&gt;
       it(&#x27;should check ng-class&#x27;, function() {
         expect(element(&#x27;.doc-example-live span&#x27;).prop(&#x27;className&#x27;)).not().
           toMatch(/my-class/);

         using(&#x27;.doc-example-live&#x27;).element(&#x27;:button:first&#x27;).click();

         expect(element(&#x27;.doc-example-live span&#x27;).prop(&#x27;className&#x27;)).
           toMatch(/my-class/);

         using(&#x27;.doc-example-live&#x27;).element(&#x27;:button:last&#x27;).click();

         expect(element(&#x27;.doc-example-live span&#x27;).prop(&#x27;className&#x27;)).not().
           toMatch(/my-class/);
       });
     &lt;/file&gt;
   &lt;/example&gt;
 */
var ngClassDirective = classDirective(&#x27;&#x27;, true);

/**
 * @ngdoc directive
 * @name ng.directive:ngClassOdd
 *
 * @description
 * The &#x60;ngClassOdd&#x60; and &#x60;ngClassEven&#x60; directives work exactly as
 * {@link ng.directive:ngClass ngClass}, except it works in
 * conjunction with &#x60;ngRepeat&#x60; and takes affect only on odd (even) rows.
 *
 * This directive can be applied only within a scope of an
 * {@link ng.directive:ngRepeat ngRepeat}.
 *
 * @element ANY
 * @param {expression} ngClassOdd {@link guide/expression Expression} to eval. The result
 *   of the evaluation can be a string representing space delimited class names or an array.
 *
 * @example
   &lt;example&gt;
     &lt;file name=&quot;index.html&quot;&gt;
        &lt;ol ng-init=&quot;names=[&#x27;John&#x27;, &#x27;Mary&#x27;, &#x27;Cate&#x27;, &#x27;Suz&#x27;]&quot;&gt;
          &lt;li ng-repeat=&quot;name in names&quot;&gt;
           &lt;span ng-class-odd=&quot;&#x27;odd&#x27;&quot; ng-class-even=&quot;&#x27;even&#x27;&quot;&gt;
             {{name}}
           &lt;/span&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
     &lt;/file&gt;
     &lt;file name=&quot;style.css&quot;&gt;
       .odd {
         color: red;
       }
       .even {
         color: blue;
       }
     &lt;/file&gt;
     &lt;file name=&quot;scenario.js&quot;&gt;
       it(&#x27;should check ng-class-odd and ng-class-even&#x27;, function() {
         expect(element(&#x27;.doc-example-live li:first span&#x27;).prop(&#x27;className&#x27;)).
           toMatch(/odd/);
         expect(element(&#x27;.doc-example-live li:last span&#x27;).prop(&#x27;className&#x27;)).
           toMatch(/even/);
       });
     &lt;/file&gt;
   &lt;/example&gt;
 */
var ngClassOddDirective = classDirective(&#x27;Odd&#x27;, 0);

/**
 * @ngdoc directive
 * @name ng.directive:ngClassEven
 *
 * @description
 * The &#x60;ngClassOdd&#x60; and &#x60;ngClassEven&#x60; directives work exactly as
 * {@link ng.directive:ngClass ngClass}, except it works in
 * conjunction with &#x60;ngRepeat&#x60; and takes affect only on odd (even) rows.
 *
 * This directive can be applied only within a scope of an
 * {@link ng.directive:ngRepeat ngRepeat}.
 *
 * @element ANY
 * @param {expression} ngClassEven {@link guide/expression Expression} to eval. The
 *   result of the evaluation can be a string representing space delimited class names or an array.
 *
 * @example
   &lt;example&gt;
     &lt;file name=&quot;index.html&quot;&gt;
        &lt;ol ng-init=&quot;names=[&#x27;John&#x27;, &#x27;Mary&#x27;, &#x27;Cate&#x27;, &#x27;Suz&#x27;]&quot;&gt;
          &lt;li ng-repeat=&quot;name in names&quot;&gt;
           &lt;span ng-class-odd=&quot;&#x27;odd&#x27;&quot; ng-class-even=&quot;&#x27;even&#x27;&quot;&gt;
             {{name}} &amp;nbsp; &amp;nbsp; &amp;nbsp;
           &lt;/span&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
     &lt;/file&gt;
     &lt;file name=&quot;style.css&quot;&gt;
       .odd {
         color: red;
       }
       .even {
         color: blue;
       }
     &lt;/file&gt;
     &lt;file name=&quot;scenario.js&quot;&gt;
       it(&#x27;should check ng-class-odd and ng-class-even&#x27;, function() {
         expect(element(&#x27;.doc-example-live li:first span&#x27;).prop(&#x27;className&#x27;)).
           toMatch(/odd/);
         expect(element(&#x27;.doc-example-live li:last span&#x27;).prop(&#x27;className&#x27;)).
           toMatch(/even/);
       });
     &lt;/file&gt;
   &lt;/example&gt;
 */
var ngClassEvenDirective = classDirective(&#x27;Even&#x27;, 1);

/**
 * @ngdoc directive
 * @name ng.directive:ngCloak
 *
 * @description
 * The &#x60;ngCloak&#x60; directive is used to prevent the Angular html template from being briefly
 * displayed by the browser in its raw (uncompiled) form while your application is loading. Use this
 * directive to avoid the undesirable flicker effect caused by the html template display.
 *
 * The directive can be applied to the &#x60;&lt;body&gt;&#x60; element, but typically a fine-grained application is
 * preferred in order to benefit from progressive rendering of the browser view.
 *
 * &#x60;ngCloak&#x60; works in cooperation with a css rule that is embedded within &#x60;angular.js&#x60; and
 *  &#x60;angular.min.js&#x60; files. Following is the css rule:
 *
 * &lt;pre&gt;
 * [ng\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak {
 *   display: none;
 * }
 * &lt;/pre&gt;
 *
 * When this css rule is loaded by the browser, all html elements (including their children) that
 * are tagged with the &#x60;ng-cloak&#x60; directive are hidden. When Angular comes across this directive
 * during the compilation of the template it deletes the &#x60;ngCloak&#x60; element attribute, which
 * makes the compiled element visible.
 *
 * For the best result, &#x60;angular.js&#x60; script must be loaded in the head section of the html file;
 * alternatively, the css rule (above) must be included in the external stylesheet of the
 * application.
 *
 * Legacy browsers, like IE7, do not provide attribute selector support (added in CSS 2.1) so they
 * cannot match the &#x60;[ng\:cloak]&#x60; selector. To work around this limitation, you must add the css
 * class &#x60;ngCloak&#x60; in addition to &#x60;ngCloak&#x60; directive as shown in the example below.
 *
 * @element ANY
 *
 * @example
   &lt;doc:example&gt;
     &lt;doc:source&gt;
        &lt;div id=&quot;template1&quot; ng-cloak&gt;{{ &#x27;hello&#x27; }}&lt;/div&gt;
        &lt;div id=&quot;template2&quot; ng-cloak class=&quot;ng-cloak&quot;&gt;{{ &#x27;hello IE7&#x27; }}&lt;/div&gt;
     &lt;/doc:source&gt;
     &lt;doc:scenario&gt;
       it(&#x27;should remove the template directive and css class&#x27;, function() {
         expect(element(&#x27;.doc-example-live #template1&#x27;).attr(&#x27;ng-cloak&#x27;)).
           not().toBeDefined();
         expect(element(&#x27;.doc-example-live #template2&#x27;).attr(&#x27;ng-cloak&#x27;)).
           not().toBeDefined();
       });
     &lt;/doc:scenario&gt;
   &lt;/doc:example&gt;
 *
 */
var ngCloakDirective = ngDirective({
  compile: function(element, attr) {
    attr.$set(&#x27;ngCloak&#x27;, undefined);
    element.removeClass(&#x27;ng-cloak&#x27;);
  }
});

/**
 * @ngdoc directive
 * @name ng.directive:ngController
 *
 * @description
 * The &#x60;ngController&#x60; directive assigns behavior to a scope. This is a key aspect of how angular
 * supports the principles behind the Model-View-Controller design pattern.
 *
 * MVC components in angular:
 *
 * * Model  The Model is data in scope properties; scopes are attached to the DOM.
 * * View  The template (HTML with data bindings) is rendered into the View.
 * * Controller  The &#x60;ngController&#x60; directive specifies a Controller class; the class has
 *   methods that typically express the business logic behind the application.
 *
 * Note that an alternative way to define controllers is via the {@link ng.$route $route} service.
 *
 * @element ANY
 * @scope
 * @param {expression} ngController Name of a globally accessible constructor function or an
 *     {@link guide/expression expression} that on the current scope evaluates to a
 *     constructor function. The controller instance can further be published into the scope
 *     by adding &#x60;as localName&#x60; the controller name attribute.
 *
 * @example
 * Here is a simple form for editing user contact information. Adding, removing, clearing, and
 * greeting are methods declared on the controller (see source tab). These methods can
 * easily be called from the angular markup. Notice that the scope becomes the &#x60;this&#x60; for the
 * controller&#x27;s instance. This allows for easy access to the view data from the controller. Also
 * notice that any changes to the data are automatically reflected in the View without the need
 * for a manual update. The example is included in two different declaration styles based on
 * your style preferences.
   &lt;doc:example&gt;
     &lt;doc:source&gt;
      &lt;script&gt;
        function SettingsController() {
          this.name = &quot;John Smith&quot;;
          this.contacts = [
            {type: &#x27;phone&#x27;, value: &#x27;408 555 1212&#x27;},
            {type: &#x27;email&#x27;, value: &#x27;john.smith@example.org&#x27;} ];
          };

        SettingsController.prototype.greet = function() {
          alert(this.name);
        };

        SettingsController.prototype.addContact = function() {
          this.contacts.push({type: &#x27;email&#x27;, value: &#x27;yourname@example.org&#x27;});
        };

        SettingsController.prototype.removeContact = function(contactToRemove) {
         var index = this.contacts.indexOf(contactToRemove);
          this.contacts.splice(index, 1);
        };

        SettingsController.prototype.clearContact = function(contact) {
          contact.type = &#x27;phone&#x27;;
          contact.value = &#x27;&#x27;;
        };
      &lt;/script&gt;
      &lt;div ng-controller=&quot;SettingsController as settings&quot;&gt;
        Name: &lt;input type=&quot;text&quot; ng-model=&quot;settings.name&quot;/&gt;
        [ &lt;a href=&quot;&quot; ng-click=&quot;settings.greet()&quot;&gt;greet&lt;/a&gt; ]&lt;br/&gt;
        Contact:
        &lt;ul&gt;
          &lt;li ng-repeat=&quot;contact in settings.contacts&quot;&gt;
            &lt;select ng-model=&quot;contact.type&quot;&gt;
               &lt;option&gt;phone&lt;/option&gt;
               &lt;option&gt;email&lt;/option&gt;
            &lt;/select&gt;
            &lt;input type=&quot;text&quot; ng-model=&quot;contact.value&quot;/&gt;
            [ &lt;a href=&quot;&quot; ng-click=&quot;settings.clearContact(contact)&quot;&gt;clear&lt;/a&gt;
            | &lt;a href=&quot;&quot; ng-click=&quot;settings.removeContact(contact)&quot;&gt;X&lt;/a&gt; ]
          &lt;/li&gt;
          &lt;li&gt;[ &lt;a href=&quot;&quot; ng-click=&quot;settings.addContact()&quot;&gt;add&lt;/a&gt; ]&lt;/li&gt;
       &lt;/ul&gt;
      &lt;/div&gt;
     &lt;/doc:source&gt;
     &lt;doc:scenario&gt;
       it(&#x27;should check controller&#x27;, function() {
         expect(element(&#x27;.doc-example-live div&gt;:input&#x27;).val()).toBe(&#x27;John Smith&#x27;);
         expect(element(&#x27;.doc-example-live li:nth-child(1) input&#x27;).val())
           .toBe(&#x27;408 555 1212&#x27;);
         expect(element(&#x27;.doc-example-live li:nth-child(2) input&#x27;).val())
           .toBe(&#x27;john.smith@example.org&#x27;);

         element(&#x27;.doc-example-live li:first a:contains(&quot;clear&quot;)&#x27;).click();
         expect(element(&#x27;.doc-example-live li:first input&#x27;).val()).toBe(&#x27;&#x27;);

         element(&#x27;.doc-example-live li:last a:contains(&quot;add&quot;)&#x27;).click();
         expect(element(&#x27;.doc-example-live li:nth-child(3) input&#x27;).val())
           .toBe(&#x27;yourname@example.org&#x27;);
       });
     &lt;/doc:scenario&gt;
   &lt;/doc:example&gt;



    &lt;doc:example&gt;
     &lt;doc:source&gt;
      &lt;script&gt;
        function SettingsController($scope) {
          $scope.name = &quot;John Smith&quot;;
          $scope.contacts = [
            {type:&#x27;phone&#x27;, value:&#x27;408 555 1212&#x27;},
            {type:&#x27;email&#x27;, value:&#x27;john.smith@example.org&#x27;} ];

          $scope.greet = function() {
           alert(this.name);
          };

          $scope.addContact = function() {
           this.contacts.push({type:&#x27;email&#x27;, value:&#x27;yourname@example.org&#x27;});
          };

          $scope.removeContact = function(contactToRemove) {
           var index = this.contacts.indexOf(contactToRemove);
           this.contacts.splice(index, 1);
          };

          $scope.clearContact = function(contact) {
           contact.type = &#x27;phone&#x27;;
           contact.value = &#x27;&#x27;;
          };
        }
      &lt;/script&gt;
      &lt;div ng-controller=&quot;SettingsController&quot;&gt;
        Name: &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;/&gt;
        [ &lt;a href=&quot;&quot; ng-click=&quot;greet()&quot;&gt;greet&lt;/a&gt; ]&lt;br/&gt;
        Contact:
        &lt;ul&gt;
          &lt;li ng-repeat=&quot;contact in contacts&quot;&gt;
            &lt;select ng-model=&quot;contact.type&quot;&gt;
               &lt;option&gt;phone&lt;/option&gt;
               &lt;option&gt;email&lt;/option&gt;
            &lt;/select&gt;
            &lt;input type=&quot;text&quot; ng-model=&quot;contact.value&quot;/&gt;
            [ &lt;a href=&quot;&quot; ng-click=&quot;clearContact(contact)&quot;&gt;clear&lt;/a&gt;
            | &lt;a href=&quot;&quot; ng-click=&quot;removeContact(contact)&quot;&gt;X&lt;/a&gt; ]
          &lt;/li&gt;
          &lt;li&gt;[ &lt;a href=&quot;&quot; ng-click=&quot;addContact()&quot;&gt;add&lt;/a&gt; ]&lt;/li&gt;
       &lt;/ul&gt;
      &lt;/div&gt;
     &lt;/doc:source&gt;
     &lt;doc:scenario&gt;
       it(&#x27;should check controller&#x27;, function() {
         expect(element(&#x27;.doc-example-live div&gt;:input&#x27;).val()).toBe(&#x27;John Smith&#x27;);
         expect(element(&#x27;.doc-example-live li:nth-child(1) input&#x27;).val())
           .toBe(&#x27;408 555 1212&#x27;);
         expect(element(&#x27;.doc-example-live li:nth-child(2) input&#x27;).val())
           .toBe(&#x27;john.smith@example.org&#x27;);

         element(&#x27;.doc-example-live li:first a:contains(&quot;clear&quot;)&#x27;).click();
         expect(element(&#x27;.doc-example-live li:first input&#x27;).val()).toBe(&#x27;&#x27;);

         element(&#x27;.doc-example-live li:last a:contains(&quot;add&quot;)&#x27;).click();
         expect(element(&#x27;.doc-example-live li:nth-child(3) input&#x27;).val())
           .toBe(&#x27;yourname@example.org&#x27;);
       });
     &lt;/doc:scenario&gt;
   &lt;/doc:example&gt;

 */
var ngControllerDirective = [function() {
  return {
    scope: true,
    controller: &#x27;@&#x27;
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngCsp
 * @priority 1000
 *
 * @element html
 * @description
 * Enables [CSP (Content Security Policy)](https://developer.mozilla.org/en/Security/CSP) support.
 * 
 * This is necessary when developing things like Google Chrome Extensions.
 * 
 * CSP forbids apps to use &#x60;eval&#x60; or &#x60;Function(string)&#x60; generated functions (among other things).
 * For us to be compatible, we just need to implement the &quot;getterFn&quot; in $parse without violating
 * any of these restrictions.
 * 
 * AngularJS uses &#x60;Function(string)&#x60; generated functions as a speed optimization. By applying &#x60;ngCsp&#x60;
 * it is be possible to opt into the CSP compatible mode. When this mode is on AngularJS will
 * evaluate all expressions up to 30% slower than in non-CSP mode, but no security violations will
 * be raised.
 * 
 * In order to use this feature put &#x60;ngCsp&#x60; directive on the root element of the application.
 * 
 * @example
 * This example shows how to apply the &#x60;ngCsp&#x60; directive to the &#x60;html&#x60; tag.
   &lt;pre&gt;
     &lt;!doctype html&gt;
     &lt;html ng-app ng-csp&gt;
     ...
     ...
     &lt;/html&gt;
   &lt;/pre&gt;
 */

var ngCspDirective = [&#x27;$sniffer&#x27;, function($sniffer) {
  return {
    priority: 1000,
    compile: function() {
      $sniffer.csp = true;
    }
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngClick
 *
 * @description
 * The ngClick allows you to specify custom behavior when
 * element is clicked.
 *
 * @element ANY
 * @param {expression} ngClick {@link guide/expression Expression} to evaluate upon
 * click. (Event object is available as &#x60;$event&#x60;)
 *
 * @example
   &lt;doc:example&gt;
     &lt;doc:source&gt;
      &lt;button ng-click=&quot;count = count + 1&quot; ng-init=&quot;count=0&quot;&gt;
        Increment
      &lt;/button&gt;
      count: {{count}}
     &lt;/doc:source&gt;
     &lt;doc:scenario&gt;
       it(&#x27;should check ng-click&#x27;, function() {
         expect(binding(&#x27;count&#x27;)).toBe(&#x27;0&#x27;);
         element(&#x27;.doc-example-live :button&#x27;).click();
         expect(binding(&#x27;count&#x27;)).toBe(&#x27;1&#x27;);
       });
     &lt;/doc:scenario&gt;
   &lt;/doc:example&gt;
 */
/*
 * A directive that allows creation of custom onclick handlers that are defined as angular
 * expressions and are compiled and executed within the current scope.
 *
 * Events that are handled via these handler are always configured not to propagate further.
 */
var ngEventDirectives = {};
forEach(
  &#x27;click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress&#x27;.split(&#x27; &#x27;),
  function(name) {
    var directiveName = directiveNormalize(&#x27;ng-&#x27; + name);
    ngEventDirectives[directiveName] = [&#x27;$parse&#x27;, function($parse) {
      return function(scope, element, attr) {
        var fn = $parse(attr[directiveName]);
        element.bind(lowercase(name), function(event) {
          scope.$apply(function() {
            fn(scope, {$event:event});
          });
        });
      };
    }];
  }
);

/**
 * @ngdoc directive
 * @name ng.directive:ngDblclick
 *
 * @description
 * The &#x60;ngDblclick&#x60; directive allows you to specify custom behavior on dblclick event.
 *
 * @element ANY
 * @param {expression} ngDblclick {@link guide/expression Expression} to evaluate upon
 * dblclick. (Event object is available as &#x60;$event&#x60;)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngMousedown
 *
 * @description
 * The ngMousedown directive allows you to specify custom behavior on mousedown event.
 *
 * @element ANY
 * @param {expression} ngMousedown {@link guide/expression Expression} to evaluate upon
 * mousedown. (Event object is available as &#x60;$event&#x60;)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngMouseup
 *
 * @description
 * Specify custom behavior on mouseup event.
 *
 * @element ANY
 * @param {expression} ngMouseup {@link guide/expression Expression} to evaluate upon
 * mouseup. (Event object is available as &#x60;$event&#x60;)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */

/**
 * @ngdoc directive
 * @name ng.directive:ngMouseover
 *
 * @description
 * Specify custom behavior on mouseover event.
 *
 * @element ANY
 * @param {expression} ngMouseover {@link guide/expression Expression} to evaluate upon
 * mouseover. (Event object is available as &#x60;$event&#x60;)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngMouseenter
 *
 * @description
 * Specify custom behavior on mouseenter event.
 *
 * @element ANY
 * @param {expression} ngMouseenter {@link guide/expression Expression} to evaluate upon
 * mouseenter. (Event object is available as &#x60;$event&#x60;)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngMouseleave
 *
 * @description
 * Specify custom behavior on mouseleave event.
 *
 * @element ANY
 * @param {expression} ngMouseleave {@link guide/expression Expression} to evaluate upon
 * mouseleave. (Event object is available as &#x60;$event&#x60;)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngMousemove
 *
 * @description
 * Specify custom behavior on mousemove event.
 *
 * @element ANY
 * @param {expression} ngMousemove {@link guide/expression Expression} to evaluate upon
 * mousemove. (Event object is available as &#x60;$event&#x60;)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngKeydown
 *
 * @description
 * Specify custom behavior on keydown event.
 *
 * @element ANY
 * @param {expression} ngKeydown {@link guide/expression Expression} to evaluate upon
 * keydown. (Event object is available as &#x60;$event&#x60; and can be interrogated for keyCode, altKey, etc.)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngKeyup
 *
 * @description
 * Specify custom behavior on keyup event.
 *
 * @element ANY
 * @param {expression} ngKeyup {@link guide/expression Expression} to evaluate upon
 * keyup. (Event object is available as &#x60;$event&#x60; and can be interrogated for keyCode, altKey, etc.)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngKeypress
 *
 * @description
 * Specify custom behavior on keypress event.
 *
 * @element ANY
 * @param {expression} ngKeypress {@link guide/expression Expression} to evaluate upon
 * keypress. (Event object is available as &#x60;$event&#x60; and can be interrogated for keyCode, altKey, etc.)
 *
 * @example
 * See {@link ng.directive:ngClick ngClick}
 */


/**
 * @ngdoc directive
 * @name ng.directive:ngSubmit
 *
 * @description
 * Enables binding angular expressions to onsubmit events.
 *
 * Additionally it prevents the default action (which for form means sending the request to the
 * server and reloading the current page).
 *
 * @element form
 * @param {expression} ngSubmit {@link guide/expression Expression} to eval.
 *
 * @example
   &lt;doc:example&gt;
     &lt;doc:source&gt;
      &lt;script&gt;
        function Ctrl($scope) {
          $scope.list = [];
          $scope.text = &#x27;hello&#x27;;
          $scope.submit = function() {
            if (this.text) {
              this.list.push(this.text);
              this.text = &#x27;&#x27;;
            }
          };
        }
      &lt;/script&gt;
      &lt;form ng-submit=&quot;submit()&quot; ng-controller=&quot;Ctrl&quot;&gt;
        Enter text and hit enter:
        &lt;input type=&quot;text&quot; ng-model=&quot;text&quot; name=&quot;text&quot; /&gt;
        &lt;input type=&quot;submit&quot; id=&quot;submit&quot; value=&quot;Submit&quot; /&gt;
        &lt;pre&gt;list={{list}}&lt;/pre&gt;
      &lt;/form&gt;
     &lt;/doc:source&gt;
     &lt;doc:scenario&gt;
       it(&#x27;should check ng-submit&#x27;, function() {
         expect(binding(&#x27;list&#x27;)).toBe(&#x27;[]&#x27;);
         element(&#x27;.doc-example-live #submit&#x27;).click();
         expect(binding(&#x27;list&#x27;)).toBe(&#x27;[&quot;hello&quot;]&#x27;);
         expect(input(&#x27;text&#x27;).val()).toBe(&#x27;&#x27;);
       });
       it(&#x27;should ignore empty strings&#x27;, function() {
         expect(binding(&#x27;list&#x27;)).toBe(&#x27;[]&#x27;);
         element(&#x27;.doc-example-live #submit&#x27;).click();
         element(&#x27;.doc-example-live #submit&#x27;).click();
         expect(binding(&#x27;list&#x27;)).toBe(&#x27;[&quot;hello&quot;]&#x27;);
       });
     &lt;/doc:scenario&gt;
   &lt;/doc:example&gt;
 */
var ngSubmitDirective = ngDirective(function(scope, element, attrs) {
  element.bind(&#x27;submit&#x27;, function() {
    scope.$apply(attrs.ngSubmit);
  });
});

/**
 * @ngdoc directive
 * @name ng.directive:ngIf
 * @restrict A
 *
 * @description
 * The &#x60;ngIf&#x60; directive removes and recreates a portion of the DOM tree (HTML)
 * conditionally based on **&quot;falsy&quot;** and **&quot;truthy&quot;** values, respectively, evaluated within
 * an {expression}. In other words, if the expression assigned to **ngIf evaluates to a false
 * value** then **the element is removed from the DOM** and **if true** then **a clone of the
 * element is reinserted into the DOM**.
 *
 * &#x60;ngIf&#x60; differs from &#x60;ngShow&#x60; and &#x60;ngHide&#x60; in that &#x60;ngIf&#x60; completely removes and recreates the
 * element in the DOM rather than changing its visibility via the &#x60;display&#x60; css property.  A common
 * case when this difference is significant is when using css selectors that rely on an element&#x27;s
 * position within the DOM (HTML), such as the &#x60;:first-child&#x60; or &#x60;:last-child&#x60; pseudo-classes.
 *
 * Note that **when an element is removed using ngIf its scope is destroyed** and **a new scope
 * is created when the element is restored**.  The scope created within &#x60;ngIf&#x60; inherits from 
 * its parent scope using
 * {@link https://github.com/angular/angular.js/wiki/The-Nuances-of-Scope-Prototypal-Inheritance prototypal inheritance}.
 * An important implication of this is if &#x60;ngModel&#x60; is used within &#x60;ngIf&#x60; to bind to
 * a javascript primitive defined in the parent scope. In this case any modifications made to the
 * variable within the child scope will override (hide) the value in the parent scope.
 *
 * Also, &#x60;ngIf&#x60; recreates elements using their compiled state. An example scenario of this behavior
 * is if an element&#x27;s class attribute is directly modified after it&#x27;s compiled, using something like 
 * jQuery&#x27;s &#x60;.addClass()&#x60; method, and the element is later removed. When &#x60;ngIf&#x60; recreates the element
 * the added class will be lost because the original compiled state is used to regenerate the element.
 *
 * Additionally, you can provide animations via the ngAnimate attribute to animate the **enter**
 * and **leave** effects.
 *
 * @animations
 * enter - happens just after the ngIf contents change and a new DOM element is created and injected into the ngIf container
 * leave - happens just before the ngIf contents are removed from the DOM
 *
 * @element ANY
 * @scope
 * @param {expression} ngIf If the {@link guide/expression expression} is falsy then
 *     the element is removed from the DOM tree (HTML).
 *
 * @example
  &lt;example animations=&quot;true&quot;&gt;
    &lt;file name=&quot;index.html&quot;&gt;
      Click me: &lt;input type=&quot;checkbox&quot; ng-model=&quot;checked&quot; ng-init=&quot;checked=true&quot; /&gt;&lt;br/&gt;
      Show when checked:
      &lt;span ng-if=&quot;checked&quot; ng-animate=&quot;&#x27;example&#x27;&quot;&gt;
        I&#x27;m removed when the checkbox is unchecked.
      &lt;/span&gt;
    &lt;/file&gt;
    &lt;file name=&quot;animations.css&quot;&gt;
      .example-leave, .example-enter {
        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -ms-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
      }

      .example-enter {
        opacity:0;
      }
      .example-enter.example-enter-active {
        opacity:1;
      }

      .example-leave {
        opacity:1;
      }
      .example-leave.example-leave-active {
        opacity:0;
      }
    &lt;/file&gt;
  &lt;/example&gt;
 */
var ngIfDirective = [&#x27;$animator&#x27;, function($animator) {
  return {
    transclude: &#x27;element&#x27;,
    priority: 1000,
    terminal: true,
    restrict: &#x27;A&#x27;,
    compile: function (element, attr, transclude) {
      return function ($scope, $element, $attr) {
        var animate = $animator($scope, $attr);
        var childElement, childScope;
        $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
          if (childElement) {
            animate.leave(childElement);
            childElement = undefined;
          }
          if (childScope) {
            childScope.$destroy();
            childScope = undefined;
          }
          if (toBoolean(value)) {
            childScope = $scope.$new();
            transclude(childScope, function (clone) {
              childElement = clone;
              animate.enter(clone, $element.parent(), $element);
            });
          }
        });
      }
    }
  }
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngInclude
 * @restrict ECA
 *
 * @description
 * Fetches, compiles and includes an external HTML fragment.
 *
 * Keep in mind that Same Origin Policy applies to included resources
 * (e.g. ngInclude won&#x27;t work for cross-domain requests on all browsers and for
 *  file:// access on some browsers).
 *
 * Additionally, you can also provide animations via the ngAnimate attribute to animate the **enter**
 * and **leave** effects.
 *
 * @animations
 * enter - happens just after the ngInclude contents change and a new DOM element is created and injected into the ngInclude container
 * leave - happens just after the ngInclude contents change and just before the former contents are removed from the DOM
 *
 * @scope
 *
 * @param {string} ngInclude|src angular expression evaluating to URL. If the source is a string constant,
 *                 make sure you wrap it in quotes, e.g. &#x60;src=&quot;&#x27;myPartialTemplate.html&#x27;&quot;&#x60;.
 * @param {string=} onload Expression to evaluate when a new partial is loaded.
 *
 * @param {string=} autoscroll Whether &#x60;ngInclude&#x60; should call {@link ng.$anchorScroll
 *                  $anchorScroll} to scroll the viewport after the content is loaded.
 *
 *                  - If the attribute is not set, disable scrolling.
 *                  - If the attribute is set without value, enable scrolling.
 *                  - Otherwise enable scrolling only if the expression evaluates to truthy value.
 *
 * @example
  &lt;example animations=&quot;true&quot;&gt;
    &lt;file name=&quot;index.html&quot;&gt;
     &lt;div ng-controller=&quot;Ctrl&quot;&gt;
       &lt;select ng-model=&quot;template&quot; ng-options=&quot;t.name for t in templates&quot;&gt;
        &lt;option value=&quot;&quot;&gt;(blank)&lt;/option&gt;
       &lt;/select&gt;
       url of the template: &lt;tt&gt;{{template.url}}&lt;/tt&gt;
       &lt;hr/&gt;
       &lt;div class=&quot;example-animate-container&quot;
            ng-include=&quot;template.url&quot;
            ng-animate=&quot;{enter: &#x27;example-enter&#x27;, leave: &#x27;example-leave&#x27;}&quot;&gt;&lt;/div&gt;
     &lt;/div&gt;
    &lt;/file&gt;
    &lt;file name=&quot;script.js&quot;&gt;
      function Ctrl($scope) {
        $scope.templates =
          [ { name: &#x27;template1.html&#x27;, url: &#x27;template1.html&#x27;}
          , { name: &#x27;template2.html&#x27;, url: &#x27;template2.html&#x27;} ];
        $scope.template = $scope.templates[0];
      }
     &lt;/file&gt;
    &lt;file name=&quot;template1.html&quot;&gt;
      &lt;div&gt;Content of template1.html&lt;/div&gt;
    &lt;/file&gt;
    &lt;file name=&quot;template2.html&quot;&gt;
      &lt;div&gt;Content of template2.html&lt;/div&gt;
    &lt;/file&gt;
    &lt;file name=&quot;animations.css&quot;&gt;
      .example-leave,
      .example-enter {
        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -ms-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;

        position:absolute;
        top:0;
        left:0;
        right:0;
        bottom:0;
      }

      .example-animate-container &gt; * {
        display:block;
        padding:10px;
      }

      .example-enter {
        top:-50px;
      }
      .example-enter.example-enter-active {
        top:0;
      }

      .example-leave {
        top:0;
      }
      .example-leave.example-leave-active {
        top:50px;
      }
    &lt;/file&gt;
    &lt;file name=&quot;scenario.js&quot;&gt;
      it(&#x27;should load template1.html&#x27;, function() {
       expect(element(&#x27;.doc-example-live [ng-include]&#x27;).text()).
         toMatch(/Content of template1.html/);
      });
      it(&#x27;should load template2.html&#x27;, function() {
       select(&#x27;template&#x27;).option(&#x27;1&#x27;);
       expect(element(&#x27;.doc-example-live [ng-include]&#x27;).text()).
         toMatch(/Content of template2.html/);
      });
      it(&#x27;should change to blank&#x27;, function() {
       select(&#x27;template&#x27;).option(&#x27;&#x27;);
       expect(element(&#x27;.doc-example-live [ng-include]&#x27;).text()).toEqual(&#x27;&#x27;);
      });
    &lt;/file&gt;
  &lt;/example&gt;
 */


/**
 * @ngdoc event
 * @name ng.directive:ngInclude#$includeContentRequested
 * @eventOf ng.directive:ngInclude
 * @eventType emit on the scope ngInclude was declared in
 * @description
 * Emitted every time the ngInclude content is requested.
 */


/**
 * @ngdoc event
 * @name ng.directive:ngInclude#$includeContentLoaded
 * @eventOf ng.directive:ngInclude
 * @eventType emit on the current ngInclude scope
 * @description
 * Emitted every time the ngInclude content is reloaded.
 */
var ngIncludeDirective = [&#x27;$http&#x27;, &#x27;$templateCache&#x27;, &#x27;$anchorScroll&#x27;, &#x27;$compile&#x27;, &#x27;$animator&#x27;,
                  function($http,   $templateCache,   $anchorScroll,   $compile,   $animator) {
  return {
    restrict: &#x27;ECA&#x27;,
    terminal: true,
    compile: function(element, attr) {
      var srcExp = attr.ngInclude || attr.src,
          onloadExp = attr.onload || &#x27;&#x27;,
          autoScrollExp = attr.autoscroll;

      return function(scope, element, attr) {
        var animate = $animator(scope, attr);
        var changeCounter = 0,
            childScope;

        var clearContent = function() {
          if (childScope) {
            childScope.$destroy();
            childScope = null;
          }
          animate.leave(element.contents(), element);
        };

        scope.$watch(srcExp, function ngIncludeWatchAction(src) {
          var thisChangeId = ++changeCounter;

          if (src) {
            $http.get(src, {cache: $templateCache}).success(function(response) {
              if (thisChangeId !== changeCounter) return;

              if (childScope) childScope.$destroy();
              childScope = scope.$new();
              animate.leave(element.contents(), element);

              var contents = jqLite(&#x27;&lt;div/&gt;&#x27;).html(response).contents();

              animate.enter(contents, element);
              $compile(contents)(childScope);

              if (isDefined(autoScrollExp) &amp;&amp; (!autoScrollExp || scope.$eval(autoScrollExp))) {
                $anchorScroll();
              }

              childScope.$emit(&#x27;$includeContentLoaded&#x27;);
              scope.$eval(onloadExp);
            }).error(function() {
              if (thisChangeId === changeCounter) clearContent();
            });
            scope.$emit(&#x27;$includeContentRequested&#x27;);
          } else {
            clearContent();
          }
        });
      };
    }
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngInit
 *
 * @description
 * The &#x60;ngInit&#x60; directive specifies initialization tasks to be executed
 *  before the template enters execution mode during bootstrap.
 *
 * @element ANY
 * @param {expression} ngInit {@link guide/expression Expression} to eval.
 *
 * @example
   &lt;doc:example&gt;
     &lt;doc:source&gt;
    &lt;div ng-init=&quot;greeting=&#x27;Hello&#x27;; person=&#x27;World&#x27;&quot;&gt;
      {{greeting}} {{person}}!
    &lt;/div&gt;
     &lt;/doc:source&gt;
     &lt;doc:scenario&gt;
       it(&#x27;should check greeting&#x27;, function() {
         expect(binding(&#x27;greeting&#x27;)).toBe(&#x27;Hello&#x27;);
         expect(binding(&#x27;person&#x27;)).toBe(&#x27;World&#x27;);
       });
     &lt;/doc:scenario&gt;
   &lt;/doc:example&gt;
 */
var ngInitDirective = ngDirective({
  compile: function() {
    return {
      pre: function(scope, element, attrs) {
        scope.$eval(attrs.ngInit);
      }
    }
  }
});

/**
 * @ngdoc directive
 * @name ng.directive:ngNonBindable
 * @priority 1000
 *
 * @description
 * Sometimes it is necessary to write code which looks like bindings but which should be left alone
 * by angular. Use &#x60;ngNonBindable&#x60; to make angular ignore a chunk of HTML.
 *
 * @element ANY
 *
 * @example
 * In this example there are two location where a simple binding (&#x60;{{}}&#x60;) is present, but the one
 * wrapped in &#x60;ngNonBindable&#x60; is left alone.
 *
 * @example
    &lt;doc:example&gt;
      &lt;doc:source&gt;
        &lt;div&gt;Normal: {{1 + 2}}&lt;/div&gt;
        &lt;div ng-non-bindable&gt;Ignored: {{1 + 2}}&lt;/div&gt;
      &lt;/doc:source&gt;
      &lt;doc:scenario&gt;
       it(&#x27;should check ng-non-bindable&#x27;, function() {
         expect(using(&#x27;.doc-example-live&#x27;).binding(&#x27;1 + 2&#x27;)).toBe(&#x27;3&#x27;);
         expect(using(&#x27;.doc-example-live&#x27;).element(&#x27;div:last&#x27;).text()).
           toMatch(/1 \+ 2/);
       });
      &lt;/doc:scenario&gt;
    &lt;/doc:example&gt;
 */
var ngNonBindableDirective = ngDirective({ terminal: true, priority: 1000 });

/**
 * @ngdoc directive
 * @name ng.directive:ngPluralize
 * @restrict EA
 *
 * @description
 * # Overview
 * &#x60;ngPluralize&#x60; is a directive that displays messages according to en-US localization rules.
 * These rules are bundled with angular.js and the rules can be overridden
 * (see {@link guide/i18n Angular i18n} dev guide). You configure ngPluralize directive
 * by specifying the mappings between
 * {@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html
 * plural categories} and the strings to be displayed.
 *
 * # Plural categories and explicit number rules
 * There are two
 * {@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html
 * plural categories} in Angular&#x27;s default en-US locale: &quot;one&quot; and &quot;other&quot;.
 *
 * While a plural category may match many numbers (for example, in en-US locale, &quot;other&quot; can match
 * any number that is not 1), an explicit number rule can only match one number. For example, the
 * explicit number rule for &quot;3&quot; matches the number 3. You will see the use of plural categories
 * and explicit number rules throughout later parts of this documentation.
 *
 * # Configuring ngPluralize
 * You configure ngPluralize by providing 2 attributes: &#x60;count&#x60; and &#x60;when&#x60;.
 * You can also provide an optional attribute, &#x60;offset&#x60;.
 *
 * The value of the &#x60;count&#x60; attribute can be either a string or an {@link guide/expression
 * Angular expression}; these are evaluated on the current scope for its bound value.
 *
 * The &#x60;when&#x60; attribute specifies the mappings between plural categories and the actual
 * string to be displayed. The value of the attribute should be a JSON object so that Angular
 * can interpret it correctly.
 *
 * The following example shows how to configure ngPluralize:
 *
 * &lt;pre&gt;
 * &lt;ng-pluralize count=&quot;personCount&quot;
                 when=&quot;{&#x27;0&#x27;: &#x27;Nobody is viewing.&#x27;,
 *                      &#x27;one&#x27;: &#x27;1 person is viewing.&#x27;,
 *                      &#x27;other&#x27;: &#x27;{} people are viewing.&#x27;}&quot;&gt;
 * &lt;/ng-pluralize&gt;
 *&lt;/pre&gt;
 *
 * In the example, &#x60;&quot;0: Nobody is viewing.&quot;&#x60; is an explicit number rule. If you did not
 * specify this rule, 0 would be matched to the &quot;other&quot; category and &quot;0 people are viewing&quot;
 * would be shown instead of &quot;Nobody is viewing&quot;. You can specify an explicit number rule for
 * other numbers, for example 12, so that instead of showing &quot;12 people are viewing&quot;, you can
 * show &quot;a dozen people are viewing&quot;.
 *
 * You can use a set of closed braces(&#x60;{}&#x60;) as a placeholder for the number that you want substituted
 * into pluralized strings. In the previous example, Angular will replace &#x60;{}&#x60; with
 * &lt;span ng-non-bindable&gt;&#x60;{{personCount}}&#x60;&lt;/span&gt;. The closed braces &#x60;{}&#x60; is a placeholder
 * for &lt;span ng-non-bindable&gt;{{numberExpression}}&lt;/span&gt;.
 *
 * # Configuring ngPluralize with offset
 * The &#x60;offset&#x60; attribute allows further customization of pluralized text, which can result in
 * a better user experience. For example, instead of the message &quot;4 people are viewing this document&quot;,
 * you might display &quot;John, Kate and 2 others are viewing this document&quot;.
 * The offset attribute allows you to offset a number by any desired value.
 * Let&#x27;s take a look at an example:
 *
 * &lt;pre&gt;
 * &lt;ng-pluralize count=&quot;personCount&quot; offset=2
 *               when=&quot;{&#x27;0&#x27;: &#x27;Nobody is viewing.&#x27;,
 *                      &#x27;1&#x27;: &#x27;{{person1}} is viewing.&#x27;,
 *                      &#x27;2&#x27;: &#x27;{{person1}} and {{person2}} are viewing.&#x27;,
 *                      &#x27;one&#x27;: &#x27;{{person1}}, {{person2}} and one other person are viewing.&#x27;,
 *                      &#x27;other&#x27;: &#x27;{{person1}}, {{person2}} and {} other people are viewing.&#x27;}&quot;&gt;
 * &lt;/ng-pluralize&gt;
 * &lt;/pre&gt;
 *
 * Notice that we are still using two plural categories(one, other), but we added
 * three explicit number rules 0, 1 and 2.
 * When one person, perhaps John, views the document, &quot;John is viewing&quot; will be shown.
 * When three people view the document, no explicit number rule is found, so
 * an offset of 2 is taken off 3, and Angular uses 1 to decide the plural category.
 * In this case, plural category &#x27;one&#x27; is matched and &quot;John, Marry and one other person are viewing&quot;
 * is shown.
 *
 * Note that when you specify offsets, you must provide explicit number rules for
 * numbers from 0 up to and including the offset. If you use an offset of 3, for example,
 * you must provide explicit number rules for 0, 1, 2 and 3. You must also provide plural strings for
 * plural categories &quot;one&quot; and &quot;other&quot;.
 *
 * @param {string|expression} count The variable to be bounded to.
 * @param {string} when The mapping between plural category to its corresponding strings.
 * @param {number=} offset Offset to deduct from the total number.
 *
 * @example
    &lt;doc:example&gt;
      &lt;doc:source&gt;
        &lt;script&gt;
          function Ctrl($scope) {
            $scope.person1 = &#x27;Igor&#x27;;
            $scope.person2 = &#x27;Misko&#x27;;
            $scope.personCount = 1;
          }
        &lt;/script&gt;
        &lt;div ng-controller=&quot;Ctrl&quot;&gt;
          Person 1:&lt;input type=&quot;text&quot; ng-model=&quot;person1&quot; value=&quot;Igor&quot; /&gt;&lt;br/&gt;
          Person 2:&lt;input type=&quot;text&quot; ng-model=&quot;person2&quot; value=&quot;Misko&quot; /&gt;&lt;br/&gt;
          Number of People:&lt;input type=&quot;text&quot; ng-model=&quot;personCount&quot; value=&quot;1&quot; /&gt;&lt;br/&gt;

          &lt;!--- Example with simple pluralization rules for en locale ---&gt;
          Without Offset:
          &lt;ng-pluralize count=&quot;personCount&quot;
                        when=&quot;{&#x27;0&#x27;: &#x27;Nobody is viewing.&#x27;,
                               &#x27;one&#x27;: &#x27;1 person is viewing.&#x27;,
                               &#x27;other&#x27;: &#x27;{} people are viewing.&#x27;}&quot;&gt;
          &lt;/ng-pluralize&gt;&lt;br&gt;

          &lt;!--- Example with offset ---&gt;
          With Offset(2):
          &lt;ng-pluralize count=&quot;personCount&quot; offset=2
                        when=&quot;{&#x27;0&#x27;: &#x27;Nobody is viewing.&#x27;,
                               &#x27;1&#x27;: &#x27;{{person1}} is viewing.&#x27;,
                               &#x27;2&#x27;: &#x27;{{person1}} and {{person2}} are viewing.&#x27;,
                               &#x27;one&#x27;: &#x27;{{person1}}, {{person2}} and one other person are viewing.&#x27;,
                               &#x27;other&#x27;: &#x27;{{person1}}, {{person2}} and {} other people are viewing.&#x27;}&quot;&gt;
          &lt;/ng-pluralize&gt;
        &lt;/div&gt;
      &lt;/doc:source&gt;
      &lt;doc:scenario&gt;
        it(&#x27;should show correct pluralized string&#x27;, function() {
          expect(element(&#x27;.doc-example-live ng-pluralize:first&#x27;).text()).
                                             toBe(&#x27;1 person is viewing.&#x27;);
          expect(element(&#x27;.doc-example-live ng-pluralize:last&#x27;).text()).
                                                toBe(&#x27;Igor is viewing.&#x27;);

          using(&#x27;.doc-example-live&#x27;).input(&#x27;personCount&#x27;).enter(&#x27;0&#x27;);
          expect(element(&#x27;.doc-example-live ng-pluralize:first&#x27;).text()).
                                               toBe(&#x27;Nobody is viewing.&#x27;);
          expect(element(&#x27;.doc-example-live ng-pluralize:last&#x27;).text()).
                                              toBe(&#x27;Nobody is viewing.&#x27;);

          using(&#x27;.doc-example-live&#x27;).input(&#x27;personCount&#x27;).enter(&#x27;2&#x27;);
          expect(element(&#x27;.doc-example-live ng-pluralize:first&#x27;).text()).
                                            toBe(&#x27;2 people are viewing.&#x27;);
          expect(element(&#x27;.doc-example-live ng-pluralize:last&#x27;).text()).
                              toBe(&#x27;Igor and Misko are viewing.&#x27;);

          using(&#x27;.doc-example-live&#x27;).input(&#x27;personCount&#x27;).enter(&#x27;3&#x27;);
          expect(element(&#x27;.doc-example-live ng-pluralize:first&#x27;).text()).
                                            toBe(&#x27;3 people are viewing.&#x27;);
          expect(element(&#x27;.doc-example-live ng-pluralize:last&#x27;).text()).
                              toBe(&#x27;Igor, Misko and one other person are viewing.&#x27;);

          using(&#x27;.doc-example-live&#x27;).input(&#x27;personCount&#x27;).enter(&#x27;4&#x27;);
          expect(element(&#x27;.doc-example-live ng-pluralize:first&#x27;).text()).
                                            toBe(&#x27;4 people are viewing.&#x27;);
          expect(element(&#x27;.doc-example-live ng-pluralize:last&#x27;).text()).
                              toBe(&#x27;Igor, Misko and 2 other people are viewing.&#x27;);
        });

        it(&#x27;should show data-binded names&#x27;, function() {
          using(&#x27;.doc-example-live&#x27;).input(&#x27;personCount&#x27;).enter(&#x27;4&#x27;);
          expect(element(&#x27;.doc-example-live ng-pluralize:last&#x27;).text()).
              toBe(&#x27;Igor, Misko and 2 other people are viewing.&#x27;);

          using(&#x27;.doc-example-live&#x27;).input(&#x27;person1&#x27;).enter(&#x27;Di&#x27;);
          using(&#x27;.doc-example-live&#x27;).input(&#x27;person2&#x27;).enter(&#x27;Vojta&#x27;);
          expect(element(&#x27;.doc-example-live ng-pluralize:last&#x27;).text()).
              toBe(&#x27;Di, Vojta and 2 other people are viewing.&#x27;);
        });
      &lt;/doc:scenario&gt;
    &lt;/doc:example&gt;
 */
var ngPluralizeDirective = [&#x27;$locale&#x27;, &#x27;$interpolate&#x27;, function($locale, $interpolate) {
  var BRACE = /{}/g;
  return {
    restrict: &#x27;EA&#x27;,
    link: function(scope, element, attr) {
      var numberExp = attr.count,
          whenExp = element.attr(attr.$attr.when), // this is because we have {{}} in attrs
          offset = attr.offset || 0,
          whens = scope.$eval(whenExp),
          whensExpFns = {},
          startSymbol = $interpolate.startSymbol(),
          endSymbol = $interpolate.endSymbol();

      forEach(whens, function(expression, key) {
        whensExpFns[key] =
          $interpolate(expression.replace(BRACE, startSymbol + numberExp + &#x27;-&#x27; +
            offset + endSymbol));
      });

      scope.$watch(function ngPluralizeWatch() {
        var value = parseFloat(scope.$eval(numberExp));

        if (!isNaN(value)) {
          //if explicit number rule such as 1, 2, 3... is defined, just use it. Otherwise,
          //check it against pluralization rules in $locale service
          if (!(value in whens)) value = $locale.pluralCat(value - offset);
           return whensExpFns[value](scope, element, true);
        } else {
          return &#x27;&#x27;;
        }
      }, function ngPluralizeWatchAction(newVal) {
        element.text(newVal);
      });
    }
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngRepeat
 *
 * @description
 * The &#x60;ngRepeat&#x60; directive instantiates a template once per item from a collection. Each template
 * instance gets its own scope, where the given loop variable is set to the current collection item,
 * and &#x60;$index&#x60; is set to the item index or key.
 *
 * Special properties are exposed on the local scope of each template instance, including:
 *
 *   * &#x60;$index&#x60;  &#x60;{number}&#x60;  iterator offset of the repeated element (0..length-1)
 *   * &#x60;$first&#x60;  &#x60;{boolean}&#x60;  true if the repeated element is first in the iterator.
 *   * &#x60;$middle&#x60;  &#x60;{boolean}&#x60;  true if the repeated element is between the first and last in the iterator.
 *   * &#x60;$last&#x60;  &#x60;{boolean}&#x60;  true if the repeated element is last in the iterator.
 *
 * Additionally, you can also provide animations via the ngAnimate attribute to animate the **enter**,
 * **leave** and **move** effects.
 *
 * @animations
 * enter - when a new item is added to the list or when an item is revealed after a filter
 * leave - when an item is removed from the list or when an item is filtered out
 * move - when an adjacent item is filtered out causing a reorder or when the item contents are reordered
 *
 * @element ANY
 * @scope
 * @priority 1000
 * @param {repeat_expression} ngRepeat The expression indicating how to enumerate a collection. These
 *   formats are currently supported:
 *
 *   * &#x60;variable in expression&#x60;  where variable is the user defined loop variable and &#x60;expression&#x60;
 *     is a scope expression giving the collection to enumerate.
 *
 *     For example: &#x60;track in cd.tracks&#x60;.
 *
 *   * &#x60;(key, value) in expression&#x60;  where &#x60;key&#x60; and &#x60;value&#x60; can be any user defined identifiers,
 *     and &#x60;expression&#x60; is the scope expression giving the collection to enumerate.
 *
 *     For example: &#x60;(name, age) in {&#x27;adam&#x27;:10, &#x27;amalie&#x27;:12}&#x60;.
 *
 *   * &#x60;variable in expression track by tracking_expression&#x60;  You can also provide an optional tracking function
 *     which can be used to associate the objects in the collection with the DOM elements. If no tractking function
 *     is specified the ng-repeat associates elements by identity in the collection. It is an error to have
 *     more then one tractking function to  resolve to the same key. (This would mean that two distinct objects are
 *     mapped to the same DOM element, which is not possible.)
 *
 *     For example: &#x60;item in items&#x60; is equivalent to &#x60;item in items track by $id(item)&#x27;. This implies that the DOM elements
 *     will be associated by item identity in the array.
 *
 *     For example: &#x60;item in items track by $id(item)&#x60;. A built in &#x60;$id()&#x60; function can be used to assign a unique
 *     &#x60;$$hashKey&#x60; property to each item in the array. This property is then used as a key to associated DOM elements
 *     with the corresponding item in the array by identity. Moving the same object in array would move the DOM
 *     element in the same way ian the DOM.
 *
 *     For example: &#x60;item in items track by item.id&#x60; Is a typical pattern when the items come from the database. In this
 *     case the object identity does not matter. Two objects are considered equivalent as long as their &#x60;id&#x60;
 *     property is same.
 *
 * @example
 * This example initializes the scope to a list of names and
 * then uses &#x60;ngRepeat&#x60; to display every person:
  &lt;example animations=&quot;true&quot;&gt;
    &lt;file name=&quot;index.html&quot;&gt;
      &lt;div ng-init=&quot;friends = [
        {name:&#x27;John&#x27;, age:25, gender:&#x27;boy&#x27;},
        {name:&#x27;Jessie&#x27;, age:30, gender:&#x27;girl&#x27;},
        {name:&#x27;Johanna&#x27;, age:28, gender:&#x27;girl&#x27;},
        {name:&#x27;Joy&#x27;, age:15, gender:&#x27;girl&#x27;},
        {name:&#x27;Mary&#x27;, age:28, gender:&#x27;girl&#x27;},
        {name:&#x27;Peter&#x27;, age:95, gender:&#x27;boy&#x27;},
        {name:&#x27;Sebastian&#x27;, age:50, gender:&#x27;boy&#x27;},
        {name:&#x27;Erika&#x27;, age:27, gender:&#x27;girl&#x27;},
        {name:&#x27;Patrick&#x27;, age:40, gender:&#x27;boy&#x27;},
        {name:&#x27;Samantha&#x27;, age:60, gender:&#x27;girl&#x27;}
      ]&quot;&gt;
        I have {{friends.length}} friends. They are:
        &lt;input type=&quot;search&quot; ng-model=&quot;q&quot; placeholder=&quot;filter friends...&quot; /&gt;
        &lt;ul&gt;
          &lt;li ng-repeat=&quot;friend in friends | filter:q&quot;
              ng-animate=&quot;{enter: &#x27;example-repeat-enter&#x27;,
                          leave: &#x27;example-repeat-leave&#x27;,
                          move: &#x27;example-repeat-move&#x27;}&quot;&gt;
            [{{$index + 1}}] {{friend.name}} who is {{friend.age}} years old.
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/file&gt;
    &lt;file name=&quot;animations.css&quot;&gt;
      .example-repeat-enter,
      .example-repeat-leave,
      .example-repeat-move {
        -webkit-transition:all linear 0.5s;
        -moz-transition:all linear 0.5s;
        -ms-transition:all linear 0.5s;
        -o-transition:all linear 0.5s;
        transition:all linear 0.5s;
      }

      .example-repeat-enter {
        line-height:0;
        opacity:0;
      }
      .example-repeat-enter.example-repeat-enter-active {
        line-height:20px;
        opacity:1;
      }

      .example-repeat-leave {
        opacity:1;
        line-height:20px;
      }
      .example-repeat-leave.example-repeat-leave-active {
        opacity:0;
        line-height:0;
      }

      .example-repeat-move { }
      .example-repeat-move.example-repeat-move-active { }
    &lt;/file&gt;
    &lt;file name=&quot;scenario.js&quot;&gt;
       it(&#x27;should render initial data set&#x27;, function() {
         var r = using(&#x27;.doc-example-live&#x27;).repeater(&#x27;ul li&#x27;);
         expect(r.count()).toBe(10);
         expect(r.row(0)).toEqual([&quot;1&quot;,&quot;John&quot;,&quot;25&quot;]);
         expect(r.row(1)).toEqual([&quot;2&quot;,&quot;Jessie&quot;,&quot;30&quot;]);
         expect(r.row(9)).toEqual([&quot;10&quot;,&quot;Samantha&quot;,&quot;60&quot;]);
         expect(binding(&#x27;friends.length&#x27;)).toBe(&quot;10&quot;);
       });

       it(&#x27;should update repeater when filter predicate changes&#x27;, function() {
         var r = using(&#x27;.doc-example-live&#x27;).repeater(&#x27;ul li&#x27;);
         expect(r.count()).toBe(10);

         input(&#x27;q&#x27;).enter(&#x27;ma&#x27;);

         expect(r.count()).toBe(2);
         expect(r.row(0)).toEqual([&quot;1&quot;,&quot;Mary&quot;,&quot;28&quot;]);
         expect(r.row(1)).toEqual([&quot;2&quot;,&quot;Samantha&quot;,&quot;60&quot;]);
       });
      &lt;/file&gt;
    &lt;/example&gt;
 */
var ngRepeatDirective = [&#x27;$parse&#x27;, &#x27;$animator&#x27;, function($parse, $animator) {
  var NG_REMOVED = &#x27;$$NG_REMOVED&#x27;;
  return {
    transclude: &#x27;element&#x27;,
    priority: 1000,
    terminal: true,
    compile: function(element, attr, linker) {
      return function($scope, $element, $attr){
        var animate = $animator($scope, $attr);
        var expression = $attr.ngRepeat;
        var match = expression.match(/^\s*(.+)\s+in\s+(.*?)\s*(\s+track\s+by\s+(.+)\s*)?$/),
          trackByExp, trackByExpGetter, trackByIdFn, lhs, rhs, valueIdentifier, keyIdentifier,
          hashFnLocals = {$id: hashKey};

        if (!match) {
          throw Error(&quot;Expected ngRepeat in form of &#x27;_item_ in _collection_[ track by _id_]&#x27; but got &#x27;&quot; +
            expression + &quot;&#x27;.&quot;);
        }

        lhs = match[1];
        rhs = match[2];
        trackByExp = match[4];

        if (trackByExp) {
          trackByExpGetter = $parse(trackByExp);
          trackByIdFn = function(key, value, index) {
            // assign key, value, and $index to the locals so that they can be used in hash functions
            if (keyIdentifier) hashFnLocals[keyIdentifier] = key;
            hashFnLocals[valueIdentifier] = value;
            hashFnLocals.$index = index;
            return trackByExpGetter($scope, hashFnLocals);
          };
        } else {
          trackByIdFn = function(key, value) {
            return hashKey(value);
          }
        }

        match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/);
        if (!match) {
          throw Error(&quot;&#x27;item&#x27; in &#x27;item in collection&#x27; should be identifier or (key, value) but got &#x27;&quot; +
              lhs + &quot;&#x27;.&quot;);
        }
        valueIdentifier = match[3] || match[1];
        keyIdentifier = match[2];

        // Store a list of elements from previous run. This is a hash where key is the item from the
        // iterator, and the value is objects with following properties.
        //   - scope: bound scope
        //   - element: previous element.
        //   - index: position
        var lastBlockMap = {};

        //watch props
        $scope.$watchCollection(rhs, function ngRepeatAction(collection){
          var index, length,
              cursor = $element,     // current position of the node
              nextCursor,
              // Same as lastBlockMap but it has the current state. It will become the
              // lastBlockMap on the next iteration.
              nextBlockMap = {},
              arrayLength,
              childScope,
              key, value, // key/value of iteration
              trackById,
              collectionKeys,
              block,       // last object information {scope, element, id}
              nextBlockOrder = [];


          if (isArrayLike(collection)) {
            collectionKeys = collection;
          } else {
            // if object, extract keys, sort them and use to determine order of iteration over obj props
            collectionKeys = [];
            for (key in collection) {
              if (collection.hasOwnProperty(key) &amp;&amp; key.charAt(0) != &#x27;$&#x27;) {
                collectionKeys.push(key);
              }
            }
            collectionKeys.sort();
          }

          arrayLength = collectionKeys.length;

          // locate existing items
          length = nextBlockOrder.length = collectionKeys.length;
          for(index = 0; index &lt; length; index++) {
           key = (collection === collectionKeys) ? index : collectionKeys[index];
           value = collection[key];
           trackById = trackByIdFn(key, value, index);
           if(lastBlockMap.hasOwnProperty(trackById)) {
             block = lastBlockMap[trackById]
             delete lastBlockMap[trackById];
             nextBlockMap[trackById] = block;
             nextBlockOrder[index] = block;
           } else if (nextBlockMap.hasOwnProperty(trackById)) {
             // restore lastBlockMap
             forEach(nextBlockOrder, function(block) {
               if (block &amp;&amp; block.element) lastBlockMap[block.id] = block;
             });
             // This is a duplicate and we need to throw an error
             throw new Error(&#x27;Duplicates in a repeater are not allowed. Repeater: &#x27; + expression +
                 &#x27; key: &#x27; + trackById);
           } else {
             // new never before seen block
             nextBlockOrder[index] = { id: trackById };
             nextBlockMap[trackById] = false;
           }
         }

          // remove existing items
          for (key in lastBlockMap) {
            if (lastBlockMap.hasOwnProperty(key)) {
              block = lastBlockMap[key];
              animate.leave(block.element);
              block.element[0][NG_REMOVED] = true;
              block.scope.$destroy();
            }
          }

          // we are not using forEach for perf reasons (trying to avoid #call)
          for (index = 0, length = collectionKeys.length; index &lt; length; index++) {
            key = (collection === collectionKeys) ? index : collectionKeys[index];
            value = collection[key];
            block = nextBlockOrder[index];

            if (block.element) {
              // if we have already seen this object, then we need to reuse the
              // associated scope/element
              childScope = block.scope;

              nextCursor = cursor[0];
              do {
                nextCursor = nextCursor.nextSibling;
              } while(nextCursor &amp;&amp; nextCursor[NG_REMOVED]);

              if (block.element[0] == nextCursor) {
                // do nothing
                cursor = block.element;
              } else {
                // existing item which got moved
                animate.move(block.element, null, cursor);
                cursor = block.element;
              }
            } else {
              // new item which we don&#x27;t know about
              childScope = $scope.$new();
            }

            childScope[valueIdentifier] = value;
            if (keyIdentifier) childScope[keyIdentifier] = key;
            childScope.$index = index;
            childScope.$first = (index === 0);
            childScope.$last = (index === (arrayLength - 1));
            childScope.$middle = !(childScope.$first || childScope.$last);

            if (!block.element) {
              linker(childScope, function(clone) {
                animate.enter(clone, null, cursor);
                cursor = clone;
                block.scope = childScope;
                block.element = clone;
                nextBlockMap[block.id] = block;
              });
            }
          }
          lastBlockMap = nextBlockMap;
        });
      };
    }
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngShow
 *
 * @description
 * The &#x60;ngShow&#x60; and &#x60;ngHide&#x60; directives show or hide a portion of the DOM tree (HTML)
 * conditionally based on **&quot;truthy&quot;** values evaluated within an {expression}. In other
 * words, if the expression assigned to **ngShow evaluates to a true value** then **the element is set to visible**
 * (via &#x60;display:block&#x60; in css) and **if false** then **the element is set to hidden** (so display:none).
 * With ngHide this is the reverse whereas true values cause the element itself to become
 * hidden.
 *
 * Additionally, you can also provide animations via the ngAnimate attribute to animate the **show**
 * and **hide** effects.
 *
 * @animations
 * show - happens after the ngShow expression evaluates to a truthy value and the contents are set to visible
 * hide - happens before the ngShow expression evaluates to a non truthy value and just before the contents are set to hidden
 *
 * @element ANY
 * @param {expression} ngShow If the {@link guide/expression expression} is truthy
 *     then the element is shown or hidden respectively.
 *
 * @example
  &lt;example animations=&quot;true&quot;&gt;
    &lt;file name=&quot;index.html&quot;&gt;
      Click me: &lt;input type=&quot;checkbox&quot; ng-model=&quot;checked&quot;&gt;&lt;br/&gt;
      &lt;div&gt;
        Show:
        &lt;span class=&quot;check-element&quot;
              ng-show=&quot;checked&quot;
              ng-animate=&quot;{show: &#x27;example-show&#x27;, hide: &#x27;example-hide&#x27;}&quot;&gt;
          &lt;span class=&quot;icon-thumbs-up&quot;&gt;&lt;/span&gt; I show up when your checkbox is checked.
        &lt;/span&gt;
      &lt;/div&gt;
      &lt;div&gt;
        Hide:
        &lt;span class=&quot;check-element&quot;
              ng-hide=&quot;checked&quot;
              ng-animate=&quot;{show: &#x27;example-show&#x27;, hide: &#x27;example-hide&#x27;}&quot;&gt;
          &lt;span class=&quot;icon-thumbs-down&quot;&gt;&lt;/span&gt; I hide when your checkbox is checked.
        &lt;/span&gt;
      &lt;/div&gt;
    &lt;/file&gt;
    &lt;file name=&quot;animations.css&quot;&gt;
      .example-show, .example-hide {
        -webkit-transition:all linear 0.5s;
        -moz-transition:all linear 0.5s;
        -ms-transition:all linear 0.5s;
        -o-transition:all linear 0.5s;
        transition:all linear 0.5s;
      }

      .example-show {
        line-height:0;
        opacity:0;
        padding:0 10px;
      }
      .example-show-active.example-show-active {
        line-height:20px;
        opacity:1;
        padding:10px;
        border:1px solid black;
        background:white;
      }

      .example-hide {
        line-height:20px;
        opacity:1;
        padding:10px;
        border:1px solid black;
        background:white;
      }
      .example-hide-active.example-hide-active {
        line-height:0;
        opacity:0;
        padding:0 10px;
      }

      .check-element {
        padding:10px;
        border:1px solid black;
        background:white;
      }
    &lt;/file&gt;
    &lt;file name=&quot;scenario.js&quot;&gt;
       it(&#x27;should check ng-show / ng-hide&#x27;, function() {
         expect(element(&#x27;.doc-example-live span:first:hidden&#x27;).count()).toEqual(1);
         expect(element(&#x27;.doc-example-live span:last:visible&#x27;).count()).toEqual(1);

         input(&#x27;checked&#x27;).check();

         expect(element(&#x27;.doc-example-live span:first:visible&#x27;).count()).toEqual(1);
         expect(element(&#x27;.doc-example-live span:last:hidden&#x27;).count()).toEqual(1);
       });
    &lt;/file&gt;
  &lt;/example&gt;
 */
//TODO(misko): refactor to remove element from the DOM
var ngShowDirective = [&#x27;$animator&#x27;, function($animator) {
  return function(scope, element, attr) {
    var animate = $animator(scope, attr);
    scope.$watch(attr.ngShow, function ngShowWatchAction(value){
      animate[toBoolean(value) ? &#x27;show&#x27; : &#x27;hide&#x27;](element);
    });
  };
}];


/**
 * @ngdoc directive
 * @name ng.directive:ngHide
 *
 * @description
 * The &#x60;ngShow&#x60; and &#x60;ngHide&#x60; directives show or hide a portion of the DOM tree (HTML)
 * conditionally based on **&quot;truthy&quot;** values evaluated within an {expression}. In other
 * words, if the expression assigned to **ngShow evaluates to a true value** then **the element is set to visible**
 * (via &#x60;display:block&#x60; in css) and **if false** then **the element is set to hidden** (so display:none).
 * With ngHide this is the reverse whereas true values cause the element itself to become
 * hidden.
 *
 * Additionally, you can also provide animations via the ngAnimate attribute to animate the **show**
 * and **hide** effects.
 *
 * @animations
 * show - happens after the ngHide expression evaluates to a non truthy value and the contents are set to visible
 * hide - happens after the ngHide expression evaluates to a truthy value and just before the contents are set to hidden
 *
 * @element ANY
 * @param {expression} ngHide If the {@link guide/expression expression} is truthy then
 *     the element is shown or hidden respectively.
 *
 * @example
  &lt;example animations=&quot;true&quot;&gt;
    &lt;file name=&quot;index.html&quot;&gt;
      Click me: &lt;input type=&quot;checkbox&quot; ng-model=&quot;checked&quot;&gt;&lt;br/&gt;
      &lt;div&gt;
        Show:
        &lt;span class=&quot;check-element&quot;
              ng-show=&quot;checked&quot;
              ng-animate=&quot;{show: &#x27;example-show&#x27;, hide: &#x27;example-hide&#x27;}&quot;&gt;
          &lt;span class=&quot;icon-thumbs-up&quot;&gt;&lt;/span&gt; I show up when your checkbox is checked.
        &lt;/span&gt;
      &lt;/div&gt;
      &lt;div&gt;
        Hide:
        &lt;span class=&quot;check-element&quot;
              ng-hide=&quot;checked&quot;
              ng-animate=&quot;{show: &#x27;example-show&#x27;, hide: &#x27;example-hide&#x27;}&quot;&gt;
          &lt;span class=&quot;icon-thumbs-down&quot;&gt;&lt;/span&gt; I hide when your checkbox is checked.
        &lt;/span&gt;
      &lt;/div&gt;
    &lt;/file&gt;
    &lt;file name=&quot;animations.css&quot;&gt;
      .example-show, .example-hide {
        -webkit-transition:all linear 0.5s;
        -moz-transition:all linear 0.5s;
        -ms-transition:all linear 0.5s;
        -o-transition:all linear 0.5s;
        transition:all linear 0.5s;
      }

      .example-show {
        line-height:0;
        opacity:0;
        padding:0 10px;
      }
      .example-show.example-show-active {
        line-height:20px;
        opacity:1;
        padding:10px;
        border:1px solid black;
        background:white;
      }

      .example-hide {
        line-height:20px;
        opacity:1;
        padding:10px;
        border:1px solid black;
        background:white;
      }
      .example-hide.example-hide-active {
        line-height:0;
        opacity:0;
        padding:0 10px;
      }

      .check-element {
        padding:10px;
        border:1px solid black;
        background:white;
      }
    &lt;/file&gt;
    &lt;file name=&quot;scenario.js&quot;&gt;
       it(&#x27;should check ng-show / ng-hide&#x27;, function() {
         expect(element(&#x27;.doc-example-live .check-element:first:hidden&#x27;).count()).toEqual(1);
         expect(element(&#x27;.doc-example-live .check-element:last:visible&#x27;).count()).toEqual(1);

         input(&#x27;checked&#x27;).check();

         expect(element(&#x27;.doc-example-live .check-element:first:visible&#x27;).count()).toEqual(1);
         expect(element(&#x27;.doc-example-live .check-element:last:hidden&#x27;).count()).toEqual(1);
       });
    &lt;/file&gt;
  &lt;/example&gt;
 */
//TODO(misko): refactor to remove element from the DOM
var ngHideDirective = [&#x27;$animator&#x27;, function($animator) {
  return function(scope, element, attr) {
    var animate = $animator(scope, attr);
    scope.$watch(attr.ngHide, function ngHideWatchAction(value){
      animate[toBoolean(value) ? &#x27;hide&#x27; : &#x27;show&#x27;](element);
    });
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:ngStyle
 *
 * @description
 * The &#x60;ngStyle&#x60; directive allows you to set CSS style on an HTML element conditionally.
 *
 * @element ANY
 * @param {expression} ngStyle {@link guide/expression Expression} which evals to an
 *      object whose keys are CSS style names and values are corresponding values for those CSS
 *      keys.
 *
 * @example
   &lt;example&gt;
     &lt;file name=&quot;index.html&quot;&gt;
        &lt;input type=&quot;button&quot; value=&quot;set&quot; ng-click=&quot;myStyle={color:&#x27;red&#x27;}&quot;&gt;
        &lt;input type=&quot;button&quot; value=&quot;clear&quot; ng-click=&quot;myStyle={}&quot;&gt;
        &lt;br/&gt;
        &lt;span ng-style=&quot;myStyle&quot;&gt;Sample Text&lt;/span&gt;
        &lt;pre&gt;myStyle={{myStyle}}&lt;/pre&gt;
     &lt;/file&gt;
     &lt;file name=&quot;style.css&quot;&gt;
       span {
         color: black;
       }
     &lt;/file&gt;
     &lt;file name=&quot;scenario.js&quot;&gt;
       it(&#x27;should check ng-style&#x27;, function() {
         expect(element(&#x27;.doc-example-live span&#x27;).css(&#x27;color&#x27;)).toBe(&#x27;rgb(0, 0, 0)&#x27;);
         element(&#x27;.doc-example-live :button[value=set]&#x27;).click();
         expect(element(&#x27;.doc-example-live span&#x27;).css(&#x27;color&#x27;)).toBe(&#x27;rgb(255, 0, 0)&#x27;);
         element(&#x27;.doc-example-live :button[value=clear]&#x27;).click();
         expect(element(&#x27;.doc-example-live span&#x27;).css(&#x27;color&#x27;)).toBe(&#x27;rgb(0, 0, 0)&#x27;);
       });
     &lt;/file&gt;
   &lt;/example&gt;
 */
var ngStyleDirective = ngDirective(function(scope, element, attr) {
  scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
    if (oldStyles &amp;&amp; (newStyles !== oldStyles)) {
      forEach(oldStyles, function(val, style) { element.css(style, &#x27;&#x27;);});
    }
    if (newStyles) element.css(newStyles);
  }, true);
});

/**
 * @ngdoc directive
 * @name ng.directive:ngSwitch
 * @restrict EA
 *
 * @description
 * The ngSwitch directive is used to conditionally swap DOM structure on your template based on a scope expression.
 * Elements within ngSwitch but without ngSwitchWhen or ngSwitchDefault directives will be preserved at the location
 * as specified in the template.
 *
 * The directive itself works similar to ngInclude, however, instead of downloading template code (or loading it
 * from the template cache), ngSwitch simply choses one of the nested elements and makes it visible based on which element
 * matches the value obtained from the evaluated expression. In other words, you define a container element
 * (where you place the directive), place an expression on the **on=&quot;...&quot; attribute**
 * (or the **ng-switch=&quot;...&quot; attribute**), define any inner elements inside of the directive and place
 * a when attribute per element. The when attribute is used to inform ngSwitch which element to display when the on
 * expression is evaluated. If a matching expression is not found via a when attribute then an element with the default
 * attribute is displayed.
 *
 * Additionally, you can also provide animations via the ngAnimate attribute to animate the **enter**
 * and **leave** effects.
 *
 * @animations
 * enter - happens after the ngSwtich contents change and the matched child element is placed inside the container
 * leave - happens just after the ngSwitch contents change and just before the former contents are removed from the DOM
 *
 * @usage
 * &lt;ANY ng-switch=&quot;expression&quot;&gt;
 *   &lt;ANY ng-switch-when=&quot;matchValue1&quot;&gt;...&lt;/ANY&gt;
 *   &lt;ANY ng-switch-when=&quot;matchValue2&quot;&gt;...&lt;/ANY&gt;
 *   &lt;ANY ng-switch-default&gt;...&lt;/ANY&gt;
 * &lt;/ANY&gt;
 *
 * @scope
 * @param {*} ngSwitch|on expression to match against &lt;tt&gt;ng-switch-when&lt;/tt&gt;.
 * @paramDescription
 * On child elements add:
 *
 * * &#x60;ngSwitchWhen&#x60;: the case statement to match against. If match then this
 *   case will be displayed. If the same match appears multiple times, all the
 *   elements will be displayed.
 * * &#x60;ngSwitchDefault&#x60;: the default case when no other case match. If there
 *   are multiple default cases, all of them will be displayed when no other
 *   case match.
 *
 *
 * @example
  &lt;example animations=&quot;true&quot;&gt;
    &lt;file name=&quot;index.html&quot;&gt;
      &lt;div ng-controller=&quot;Ctrl&quot;&gt;
        &lt;select ng-model=&quot;selection&quot; ng-options=&quot;item for item in items&quot;&gt;
        &lt;/select&gt;
        &lt;tt&gt;selection={{selection}}&lt;/tt&gt;
        &lt;hr/&gt;
        &lt;div
          class=&quot;example-animate-container&quot;
          ng-switch on=&quot;selection&quot;
          ng-animate=&quot;{enter: &#x27;example-enter&#x27;, leave: &#x27;example-leave&#x27;}&quot;&gt;
            &lt;div ng-switch-when=&quot;settings&quot;&gt;Settings Div&lt;/div&gt;
            &lt;div ng-switch-when=&quot;home&quot;&gt;Home Span&lt;/div&gt;
            &lt;div ng-switch-default&gt;default&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/file&gt;
    &lt;file name=&quot;script.js&quot;&gt;
      function Ctrl($scope) {
        $scope.items = [&#x27;settings&#x27;, &#x27;home&#x27;, &#x27;other&#x27;];
        $scope.selection = $scope.items[0];
      }
    &lt;/file&gt;
    &lt;file name=&quot;animations.css&quot;&gt;
      .example-leave, .example-enter {
        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -ms-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;
        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;

        position:absolute;
        top:0;
        left:0;
        right:0;
        bottom:0;
      }

      .example-animate-container &gt; * {
        display:block;
        padding:10px;
      }

      .example-enter {
        top:-50px;
      }
      .example-enter.example-enter-active {
        top:0;
      }

      .example-leave {
        top:0;
      }
      .example-leave.example-leave-active {
        top:50px;
      }
    &lt;/file&gt;
    &lt;file name=&quot;scenario.js&quot;&gt;
      it(&#x27;should start in settings&#x27;, function() {
        expect(element(&#x27;.doc-example-live [ng-switch]&#x27;).text()).toMatch(/Settings Div/);
      });
      it(&#x27;should change to home&#x27;, function() {
        select(&#x27;selection&#x27;).option(&#x27;home&#x27;);
        expect(element(&#x27;.doc-example-live [ng-switch]&#x27;).text()).toMatch(/Home Span/);
      });
      it(&#x27;should select default&#x27;, function() {
        select(&#x27;selection&#x27;).option(&#x27;other&#x27;);
        expect(element(&#x27;.doc-example-live [ng-switch]&#x27;).text()).toMatch(/default/);
      });
    &lt;/file&gt;
  &lt;/example&gt;
 */
var ngSwitchDirective = [&#x27;$animator&#x27;, function($animator) {
  return {
    restrict: &#x27;EA&#x27;,
    require: &#x27;ngSwitch&#x27;,

    // asks for $scope to fool the BC controller module
    controller: [&#x27;$scope&#x27;, function ngSwitchController() {
     this.cases = {};
    }],
    link: function(scope, element, attr, ngSwitchController) {
      var animate = $animator(scope, attr);
      var watchExpr = attr.ngSwitch || attr.on,
          selectedTranscludes,
          selectedElements,
          selectedScopes = [];

      scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
        for (var i= 0, ii=selectedScopes.length; i&lt;ii; i++) {
          selectedScopes[i].$destroy();
          animate.leave(selectedElements[i]);
        }

        selectedElements = [];
        selectedScopes = [];

        if ((selectedTranscludes = ngSwitchController.cases[&#x27;!&#x27; + value] || ngSwitchController.cases[&#x27;?&#x27;])) {
          scope.$eval(attr.change);
          forEach(selectedTranscludes, function(selectedTransclude) {
            var selectedScope = scope.$new();
            selectedScopes.push(selectedScope);
            selectedTransclude.transclude(selectedScope, function(caseElement) {
              var anchor = selectedTransclude.element;

              selectedElements.push(caseElement);
              animate.enter(caseElement, anchor.parent(), anchor);
            });
          });
        }
      });
    }
  }
}];

var ngSwitchWhenDirective = ngDirective({
  transclude: &#x27;element&#x27;,
  priority: 500,
  require: &#x27;^ngSwitch&#x27;,
  compile: function(element, attrs, transclude) {
    return function(scope, element, attr, ctrl) {
      ctrl.cases[&#x27;!&#x27; + attrs.ngSwitchWhen] = (ctrl.cases[&#x27;!&#x27; + attrs.ngSwitchWhen] || []);
      ctrl.cases[&#x27;!&#x27; + attrs.ngSwitchWhen].push({ transclude: transclude, element: element });
    };
  }
});

var ngSwitchDefaultDirective = ngDirective({
  transclude: &#x27;element&#x27;,
  priority: 500,
  require: &#x27;^ngSwitch&#x27;,
  compile: function(element, attrs, transclude) {
    return function(scope, element, attr, ctrl) {
      ctrl.cases[&#x27;?&#x27;] = (ctrl.cases[&#x27;?&#x27;] || []);
      ctrl.cases[&#x27;?&#x27;].push({ transclude: transclude, element: element });
    };
  }
});

/**
 * @ngdoc directive
 * @name ng.directive:ngTransclude
 *
 * @description
 * Insert the transcluded DOM here.
 *
 * @element ANY
 *
 * @example
   &lt;doc:example module=&quot;transclude&quot;&gt;
     &lt;doc:source&gt;
       &lt;script&gt;
         function Ctrl($scope) {
           $scope.title = &#x27;Lorem Ipsum&#x27;;
           $scope.text = &#x27;Neque porro quisquam est qui dolorem ipsum quia dolor...&#x27;;
         }

         angular.module(&#x27;transclude&#x27;, [])
          .directive(&#x27;pane&#x27;, function(){
             return {
               restrict: &#x27;E&#x27;,
               transclude: true,
               scope: &#x27;isolate&#x27;,
               locals: { title:&#x27;bind&#x27; },
               template: &#x27;&lt;div style=&quot;border: 1px solid black;&quot;&gt;&#x27; +
                           &#x27;&lt;div style=&quot;background-color: gray&quot;&gt;{{title}}&lt;/div&gt;&#x27; +
                           &#x27;&lt;div ng-transclude&gt;&lt;/div&gt;&#x27; +
                         &#x27;&lt;/div&gt;&#x27;
             };
         });
       &lt;/script&gt;
       &lt;div ng-controller=&quot;Ctrl&quot;&gt;
         &lt;input ng-model=&quot;title&quot;&gt;&lt;br&gt;
         &lt;textarea ng-model=&quot;text&quot;&gt;&lt;/textarea&gt; &lt;br/&gt;
         &lt;pane title=&quot;{{title}}&quot;&gt;{{text}}&lt;/pane&gt;
       &lt;/div&gt;
     &lt;/doc:source&gt;
     &lt;doc:scenario&gt;
        it(&#x27;should have transcluded&#x27;, function() {
          input(&#x27;title&#x27;).enter(&#x27;TITLE&#x27;);
          input(&#x27;text&#x27;).enter(&#x27;TEXT&#x27;);
          expect(binding(&#x27;title&#x27;)).toEqual(&#x27;TITLE&#x27;);
          expect(binding(&#x27;text&#x27;)).toEqual(&#x27;TEXT&#x27;);
        });
     &lt;/doc:scenario&gt;
   &lt;/doc:example&gt;
 *
 */
var ngTranscludeDirective = ngDirective({
  controller: [&#x27;$transclude&#x27;, &#x27;$element&#x27;, function($transclude, $element) {
    $transclude(function(clone) {
      $element.append(clone);
    });
  }]
});

/**
 * @ngdoc directive
 * @name ng.directive:ngView
 * @restrict ECA
 *
 * @description
 * # Overview
 * &#x60;ngView&#x60; is a directive that complements the {@link ng.$route $route} service by
 * including the rendered template of the current route into the main layout (&#x60;index.html&#x60;) file.
 * Every time the current route changes, the included view changes with it according to the
 * configuration of the &#x60;$route&#x60; service.
 *
 * Additionally, you can also provide animations via the ngAnimate attribute to animate the **enter**
 * and **leave** effects.
 *
 * @animations
 * enter - happens just after the ngView contents are changed (when the new view DOM element is inserted into the DOM)
 * leave - happens just after the current ngView contents change and just before the former contents are removed from the DOM
 *
 * @scope
 * @example
    &lt;example module=&quot;ngView&quot; animations=&quot;true&quot;&gt;
      &lt;file name=&quot;index.html&quot;&gt;
        &lt;div ng-controller=&quot;MainCntl as main&quot;&gt;
          Choose:
          &lt;a href=&quot;Book/Moby&quot;&gt;Moby&lt;/a&gt; |
          &lt;a href=&quot;Book/Moby/ch/1&quot;&gt;Moby: Ch1&lt;/a&gt; |
          &lt;a href=&quot;Book/Gatsby&quot;&gt;Gatsby&lt;/a&gt; |
          &lt;a href=&quot;Book/Gatsby/ch/4?key=value&quot;&gt;Gatsby: Ch4&lt;/a&gt; |
          &lt;a href=&quot;Book/Scarlet&quot;&gt;Scarlet Letter&lt;/a&gt;&lt;br/&gt;

          &lt;div
            ng-view
            class=&quot;example-animate-container&quot;
            ng-animate=&quot;{enter: &#x27;example-enter&#x27;, leave: &#x27;example-leave&#x27;}&quot;&gt;&lt;/div&gt;
          &lt;hr /&gt;

          &lt;pre&gt;$location.path() = {{main.$location.path()}}&lt;/pre&gt;
          &lt;pre&gt;$route.current.templateUrl = {{main.$route.current.templateUrl}}&lt;/pre&gt;
          &lt;pre&gt;$route.current.params = {{main.$route.current.params}}&lt;/pre&gt;
          &lt;pre&gt;$route.current.scope.name = {{main.$route.current.scope.name}}&lt;/pre&gt;
          &lt;pre&gt;$routeParams = {{main.$routeParams}}&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/file&gt;

      &lt;file name=&quot;book.html&quot;&gt;
        &lt;div&gt;
          controller: {{book.name}}&lt;br /&gt;
          Book Id: {{book.params.bookId}}&lt;br /&gt;
        &lt;/div&gt;
      &lt;/file&gt;

      &lt;file name=&quot;chapter.html&quot;&gt;
        &lt;div&gt;
          controller: {{chapter.name}}&lt;br /&gt;
          Book Id: {{chapter.params.bookId}}&lt;br /&gt;
          Chapter Id: {{chapter.params.chapterId}}
        &lt;/div&gt;
      &lt;/file&gt;

      &lt;file name=&quot;animations.css&quot;&gt;
        .example-leave, .example-enter {
          -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;
          -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;
          -ms-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;
          -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;
          transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;
        }

        .example-animate-container {
          position:relative;
          height:100px;
        }

        .example-animate-container &gt; * {
          display:block;
          width:100%;
          border-left:1px solid black;

          position:absolute;
          top:0;
          left:0;
          right:0;
          bottom:0;
          padding:10px;
        }

        .example-enter {
          left:100%;
        }
        .example-enter.example-enter-active {
          left:0;
        }

        .example-leave { }
        .example-leave.example-leave-active {
          left:-100%;
        }
      &lt;/file&gt;

      &lt;file name=&quot;script.js&quot;&gt;
        angular.module(&#x27;ngView&#x27;, [], function($routeProvider, $locationProvider) {
          $routeProvider.when(&#x27;/Book/:bookId&#x27;, {
            templateUrl: &#x27;book.html&#x27;,
            controller: BookCntl,
            controllerAs: &#x27;book&#x27;
          });
          $routeProvider.when(&#x27;/Book/:bookId/ch/:chapterId&#x27;, {
            templateUrl: &#x27;chapter.html&#x27;,
            controller: ChapterCntl,
            controllerAs: &#x27;chapter&#x27;
          });

          // configure html5 to get links working on jsfiddle
          $locationProvider.html5Mode(true);
        });

        function MainCntl($route, $routeParams, $location) {
          this.$route = $route;
          this.$location = $location;
          this.$routeParams = $routeParams;
        }

        function BookCntl($routeParams) {
          this.name = &quot;BookCntl&quot;;
          this.params = $routeParams;
        }

        function ChapterCntl($routeParams) {
          this.name = &quot;ChapterCntl&quot;;
          this.params = $routeParams;
        }
      &lt;/file&gt;

      &lt;file name=&quot;scenario.js&quot;&gt;
        it(&#x27;should load and compile correct template&#x27;, function() {
          element(&#x27;a:contains(&quot;Moby: Ch1&quot;)&#x27;).click();
          var content = element(&#x27;.doc-example-live [ng-view]&#x27;).text();
          expect(content).toMatch(/controller\: ChapterCntl/);
          expect(content).toMatch(/Book Id\: Moby/);
          expect(content).toMatch(/Chapter Id\: 1/);

          element(&#x27;a:contains(&quot;Scarlet&quot;)&#x27;).click();
          content = element(&#x27;.doc-example-live [ng-view]&#x27;).text();
          expect(content).toMatch(/controller\: BookCntl/);
          expect(content).toMatch(/Book Id\: Scarlet/);
        });
      &lt;/file&gt;
    &lt;/example&gt;
 */


/**
 * @ngdoc event
 * @name ng.directive:ngView#$viewContentLoaded
 * @eventOf ng.directive:ngView
 * @eventType emit on the current ngView scope
 * @description
 * Emitted every time the ngView content is reloaded.
 */
var ngViewDirective = [&#x27;$http&#x27;, &#x27;$templateCache&#x27;, &#x27;$route&#x27;, &#x27;$anchorScroll&#x27;, &#x27;$compile&#x27;,
                       &#x27;$controller&#x27;, &#x27;$animator&#x27;,
               function($http,   $templateCache,   $route,   $anchorScroll,   $compile,
                        $controller,  $animator) {
  return {
    restrict: &#x27;ECA&#x27;,
    terminal: true,
    link: function(scope, element, attr) {
      var lastScope,
          onloadExp = attr.onload || &#x27;&#x27;,
          animate = $animator(scope, attr);

      scope.$on(&#x27;$routeChangeSuccess&#x27;, update);
      update();


      function destroyLastScope() {
        if (lastScope) {
          lastScope.$destroy();
          lastScope = null;
        }
      }

      function clearContent() {
        animate.leave(element.contents(), element);
        destroyLastScope();
      }

      function update() {
        var locals = $route.current &amp;&amp; $route.current.locals,
            template = locals &amp;&amp; locals.$template;

        if (template) {
          clearContent();
          var enterElements = jqLite(&#x27;&lt;div&gt;&lt;/div&gt;&#x27;).html(template).contents();
          animate.enter(enterElements, element);

          var link = $compile(enterElements),
              current = $route.current,
              controller;

          lastScope = current.scope = scope.$new();
          if (current.controller) {
            locals.$scope = lastScope;
            controller = $controller(current.controller, locals);
            if (current.controllerAs) {
              lastScope[current.controllerAs] = controller;
            }
            element.children().data(&#x27;$ngControllerController&#x27;, controller);
          }

          link(lastScope);
          lastScope.$emit(&#x27;$viewContentLoaded&#x27;);
          lastScope.$eval(onloadExp);

          // $anchorScroll might listen on event...
          $anchorScroll();
        } else {
          clearContent();
        }
      }
    }
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:script
 *
 * @description
 * Load content of a script tag, with type &#x60;text/ng-template&#x60;, into &#x60;$templateCache&#x60;, so that the
 * template can be used by &#x60;ngInclude&#x60;, &#x60;ngView&#x60; or directive templates.
 *
 * @restrict E
 * @param {&#x27;text/ng-template&#x27;} type must be set to &#x60;&#x27;text/ng-template&#x27;&#x60;
 *
 * @example
  &lt;doc:example&gt;
    &lt;doc:source&gt;
      &lt;script type=&quot;text/ng-template&quot; id=&quot;/tpl.html&quot;&gt;
        Content of the template.
      &lt;/script&gt;

      &lt;a ng-click=&quot;currentTpl=&#x27;/tpl.html&#x27;&quot; id=&quot;tpl-link&quot;&gt;Load inlined template&lt;/a&gt;
      &lt;div id=&quot;tpl-content&quot; ng-include src=&quot;currentTpl&quot;&gt;&lt;/div&gt;
    &lt;/doc:source&gt;
    &lt;doc:scenario&gt;
      it(&#x27;should load template defined inside script tag&#x27;, function() {
        element(&#x27;#tpl-link&#x27;).click();
        expect(element(&#x27;#tpl-content&#x27;).text()).toMatch(/Content of the template/);
      });
    &lt;/doc:scenario&gt;
  &lt;/doc:example&gt;
 */
var scriptDirective = [&#x27;$templateCache&#x27;, function($templateCache) {
  return {
    restrict: &#x27;E&#x27;,
    terminal: true,
    compile: function(element, attr) {
      if (attr.type == &#x27;text/ng-template&#x27;) {
        var templateUrl = attr.id,
            // IE is not consistent, in scripts we have to read .text but in other nodes we have to read .textContent
            text = element[0].text;

        $templateCache.put(templateUrl, text);
      }
    }
  };
}];

/**
 * @ngdoc directive
 * @name ng.directive:select
 * @restrict E
 *
 * @description
 * HTML &#x60;SELECT&#x60; element with angular data-binding.
 *
 * # &#x60;ngOptions&#x60;
 *
 * Optionally &#x60;ngOptions&#x60; attribute can be used to dynamically generate a list of &#x60;&lt;option&gt;&#x60;
 * elements for a &#x60;&lt;select&gt;&#x60; element using an array or an object obtained by evaluating the
 * &#x60;ngOptions&#x60; expression.
 *
 * When an item in the select menu is select, the value of array element or object property
 * represented by the selected option will be bound to the model identified by the &#x60;ngModel&#x60;
 * directive of the parent select element.
 *
 * Optionally, a single hard-coded &#x60;&lt;option&gt;&#x60; element, with the value set to an empty string, can
 * be nested into the &#x60;&lt;select&gt;&#x60; element. This element will then represent &#x60;null&#x60; or &quot;not selected&quot;
 * option. See example below for demonstration.
 *
 * Note: &#x60;ngOptions&#x60; provides iterator facility for &#x60;&lt;option&gt;&#x60; element which should be used instead
 * of {@link ng.directive:ngRepeat ngRepeat} when you want the
 * &#x60;select&#x60; model to be bound to a non-string value. This is because an option element can currently
 * be bound to string values only.
 *
 * @param {string} ngModel Assignable angular expression to data-bind to.
 * @param {string=} name Property name of the form under which the control is published.
 * @param {string=} required The control is considered valid only if value is entered.
 * @param {string=} ngRequired Adds &#x60;required&#x60; attribute and &#x60;required&#x60; validation constraint to
 *    the element when the ngRequired expression evaluates to true. Use &#x60;ngRequired&#x60; instead of
 *    &#x60;required&#x60; when you want to data-bind to the &#x60;required&#x60; attribute.
 * @param {comprehension_expression=} ngOptions in one of the following forms:
 *
 *   * for array data sources:
 *     * &#x60;label&#x60; **&#x60;for&#x60;** &#x60;value&#x60; **&#x60;in&#x60;** &#x60;array&#x60;
 *     * &#x60;select&#x60; **&#x60;as&#x60;** &#x60;label&#x60; **&#x60;for&#x60;** &#x60;value&#x60; **&#x60;in&#x60;** &#x60;array&#x60;
 *     * &#x60;label&#x60;  **&#x60;group by&#x60;** &#x60;group&#x60; **&#x60;for&#x60;** &#x60;value&#x60; **&#x60;in&#x60;** &#x60;array&#x60;
 *     * &#x60;select&#x60; **&#x60;as&#x60;** &#x60;label&#x60; **&#x60;group by&#x60;** &#x60;group&#x60; **&#x60;for&#x60;** &#x60;value&#x60; **&#x60;in&#x60;** &#x60;array&#x60; **&#x60;track by&#x60;** &#x60;trackexpr&#x60;
 *   * for object data sources:
 *     * &#x60;label&#x60; **&#x60;for (&#x60;**&#x60;key&#x60; **&#x60;,&#x60;** &#x60;value&#x60;**&#x60;) in&#x60;** &#x60;object&#x60;
 *     * &#x60;select&#x60; **&#x60;as&#x60;** &#x60;label&#x60; **&#x60;for (&#x60;**&#x60;key&#x60; **&#x60;,&#x60;** &#x60;value&#x60;**&#x60;) in&#x60;** &#x60;object&#x60;
 *     * &#x60;label&#x60; **&#x60;group by&#x60;** &#x60;group&#x60; **&#x60;for (&#x60;**&#x60;key&#x60;**&#x60;,&#x60;** &#x60;value&#x60;**&#x60;) in&#x60;** &#x60;object&#x60;
 *     * &#x60;select&#x60; **&#x60;as&#x60;** &#x60;label&#x60; **&#x60;group by&#x60;** &#x60;group&#x60;
 *         **&#x60;for&#x60; &#x60;(&#x60;**&#x60;key&#x60;**&#x60;,&#x60;** &#x60;value&#x60;**&#x60;) in&#x60;** &#x60;object&#x60;
 *
 * Where:
 *
 *   * &#x60;array&#x60; / &#x60;object&#x60;: an expression which evaluates to an array / object to iterate over.
 *   * &#x60;value&#x60;: local variable which will refer to each item in the &#x60;array&#x60; or each property value
 *      of &#x60;object&#x60; during iteration.
 *   * &#x60;key&#x60;: local variable which will refer to a property name in &#x60;object&#x60; during iteration.
 *   * &#x60;label&#x60;: The result of this expression will be the label for &#x60;&lt;option&gt;&#x60; element. The
 *     &#x60;expression&#x60; will most likely refer to the &#x60;value&#x60; variable (e.g. &#x60;value.propertyName&#x60;).
 *   * &#x60;select&#x60;: The result of this expression will be bound to the model of the parent &#x60;&lt;select&gt;&#x60;
 *      element. If not specified, &#x60;select&#x60; expression will default to &#x60;value&#x60;.
 *   * &#x60;group&#x60;: The result of this expression will be used to group options using the &#x60;&lt;optgroup&gt;&#x60;
 *      DOM element.
 *   * &#x60;trackexpr&#x60;: Used when working with an array of objects. The result of this expression will be
 *      used to identify the objects in the array. The &#x60;trackexpr&#x60; will most likely refer to the
 *     &#x60;value&#x60; variable (e.g. &#x60;value.propertyName&#x60;).
 *
 * @example
    &lt;doc:example&gt;
      &lt;doc:source&gt;
        &lt;script&gt;
        function MyCntrl($scope) {
          $scope.colors = [
            {name:&#x27;black&#x27;, shade:&#x27;dark&#x27;},
            {name:&#x27;white&#x27;, shade:&#x27;light&#x27;},
            {name:&#x27;red&#x27;, shade:&#x27;dark&#x27;},
            {name:&#x27;blue&#x27;, shade:&#x27;dark&#x27;},
            {name:&#x27;yellow&#x27;, shade:&#x27;light&#x27;}
          ];
          $scope.color = $scope.colors[2]; // red
        }
        &lt;/script&gt;
        &lt;div ng-controller=&quot;MyCntrl&quot;&gt;
          &lt;ul&gt;
            &lt;li ng-repeat=&quot;color in colors&quot;&gt;
              Name: &lt;input ng-model=&quot;color.name&quot;&gt;
              [&lt;a href ng-click=&quot;colors.splice($index, 1)&quot;&gt;X&lt;/a&gt;]
            &lt;/li&gt;
            &lt;li&gt;
              [&lt;a href ng-click=&quot;colors.push({})&quot;&gt;add&lt;/a&gt;]
            &lt;/li&gt;
          &lt;/ul&gt;
          &lt;hr/&gt;
          Color (null not allowed):
          &lt;select ng-model=&quot;color&quot; ng-options=&quot;c.name for c in colors&quot;&gt;&lt;/select&gt;&lt;br&gt;

          Color (null allowed):
          &lt;span  class=&quot;nullable&quot;&gt;
            &lt;select ng-model=&quot;color&quot; ng-options=&quot;c.name for c in colors&quot;&gt;
              &lt;option value=&quot;&quot;&gt;-- chose color --&lt;/option&gt;
            &lt;/select&gt;
          &lt;/span&gt;&lt;br/&gt;

          Color grouped by shade:
          &lt;select ng-model=&quot;color&quot; ng-options=&quot;c.name group by c.shade for c in colors&quot;&gt;
          &lt;/select&gt;&lt;br/&gt;


          Select &lt;a href ng-click=&quot;color={name:&#x27;not in list&#x27;}&quot;&gt;bogus&lt;/a&gt;.&lt;br&gt;
          &lt;hr/&gt;
          Currently selected: {{ {selected_color:color}  }}
          &lt;div style=&quot;border:solid 1px black; height:20px&quot;
               ng-style=&quot;{&#x27;background-color&#x27;:color.name}&quot;&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/doc:source&gt;
      &lt;doc:scenario&gt;
         it(&#x27;should check ng-options&#x27;, function() {
           expect(binding(&#x27;{selected_color:color}&#x27;)).toMatch(&#x27;red&#x27;);
           select(&#x27;color&#x27;).option(&#x27;0&#x27;);
           expect(binding(&#x27;{selected_color:color}&#x27;)).toMatch(&#x27;black&#x27;);
           using(&#x27;.nullable&#x27;).select(&#x27;color&#x27;).option(&#x27;&#x27;);
           expect(binding(&#x27;{selected_color:color}&#x27;)).toMatch(&#x27;null&#x27;);
         });
      &lt;/doc:scenario&gt;
    &lt;/doc:example&gt;
 */

var ngOptionsDirective = valueFn({ terminal: true });
var selectDirective = [&#x27;$compile&#x27;, &#x27;$parse&#x27;, function($compile,   $parse) {
                         //0000111110000000000022220000000000000000000000333300000000000000444444444444444440000000005555555555555555500000006666666666666666600000000000000007777000000000000000000088888
  var NG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w\d]*)|(?:\(\s*([\$\w][\$\w\d]*)\s*,\s*([\$\w][\$\w\d]*)\s*\)))\s+in\s+(.*?)(?:\s+track\s+by\s+(.*?))?$/,
      nullModelCtrl = {$setViewValue: noop};

  return {
    restrict: &#x27;E&#x27;,
    require: [&#x27;select&#x27;, &#x27;?ngModel&#x27;],
    controller: [&#x27;$element&#x27;, &#x27;$scope&#x27;, &#x27;$attrs&#x27;, function($element, $scope, $attrs) {
      var self = this,
          optionsMap = {},
          ngModelCtrl = nullModelCtrl,
          nullOption,
          unknownOption;


      self.databound = $attrs.ngModel;


      self.init = function(ngModelCtrl_, nullOption_, unknownOption_) {
        ngModelCtrl = ngModelCtrl_;
        nullOption = nullOption_;
        unknownOption = unknownOption_;
      }


      self.addOption = function(value) {
        optionsMap[value] = true;

        if (ngModelCtrl.$viewValue == value) {
          $element.val(value);
          if (unknownOption.parent()) unknownOption.remove();
        }
      };


      self.removeOption = function(value) {
        if (this.hasOption(value)) {
          delete optionsMap[value];
          if (ngModelCtrl.$viewValue == value) {
            this.renderUnknownOption(value);
          }
        }
      };


      self.renderUnknownOption = function(val) {
        var unknownVal = &#x27;? &#x27; + hashKey(val) + &#x27; ?&#x27;;
        unknownOption.val(unknownVal);
        $element.prepend(unknownOption);
        $element.val(unknownVal);
        unknownOption.prop(&#x27;selected&#x27;, true); // needed for IE
      }


      self.hasOption = function(value) {
        return optionsMap.hasOwnProperty(value);
      }

      $scope.$on(&#x27;$destroy&#x27;, function() {
        // disable unknown option so that we don&#x27;t do work when the whole select is being destroyed
        self.renderUnknownOption = noop;
      });
    }],

    link: function(scope, element, attr, ctrls) {
      // if ngModel is not defined, we don&#x27;t need to do anything
      if (!ctrls[1]) return;

      var selectCtrl = ctrls[0],
          ngModelCtrl = ctrls[1],
          multiple = attr.multiple,
          optionsExp = attr.ngOptions,
          nullOption = false, // if false, user will not be able to select it (used by ngOptions)
          emptyOption,
          // we can&#x27;t just jqLite(&#x27;&lt;option&gt;&#x27;) since jqLite is not smart enough
          // to create it in &lt;select&gt; and IE barfs otherwise.
          optionTemplate = jqLite(document.createElement(&#x27;option&#x27;)),
          optGroupTemplate =jqLite(document.createElement(&#x27;optgroup&#x27;)),
          unknownOption = optionTemplate.clone();

      // find &quot;null&quot; option
      for(var i = 0, children = element.children(), ii = children.length; i &lt; ii; i++) {
        if (children[i].value == &#x27;&#x27;) {
          emptyOption = nullOption = children.eq(i);
          break;
        }
      }

      selectCtrl.init(ngModelCtrl, nullOption, unknownOption);

      // required validator
      if (multiple &amp;&amp; (attr.required || attr.ngRequired)) {
        var requiredValidator = function(value) {
          ngModelCtrl.$setValidity(&#x27;required&#x27;, !attr.required || (value &amp;&amp; value.length));
          return value;
        };

        ngModelCtrl.$parsers.push(requiredValidator);
        ngModelCtrl.$formatters.unshift(requiredValidator);

        attr.$observe(&#x27;required&#x27;, function() {
          requiredValidator(ngModelCtrl.$viewValue);
        });
      }

      if (optionsExp) Options(scope, element, ngModelCtrl);
      else if (multiple) Multiple(scope, element, ngModelCtrl);
      else Single(scope, element, ngModelCtrl, selectCtrl);


      ////////////////////////////



      function Single(scope, selectElement, ngModelCtrl, selectCtrl) {
        ngModelCtrl.$render = function() {
          var viewValue = ngModelCtrl.$viewValue;

          if (selectCtrl.hasOption(viewValue)) {
            if (unknownOption.parent()) unknownOption.remove();
            selectElement.val(viewValue);
            if (viewValue === &#x27;&#x27;) emptyOption.prop(&#x27;selected&#x27;, true); // to make IE9 happy
          } else {
            if (isUndefined(viewValue) &amp;&amp; emptyOption) {
              selectElement.val(&#x27;&#x27;);
            } else {
              selectCtrl.renderUnknownOption(viewValue);
            }
          }
        };

        selectElement.bind(&#x27;change&#x27;, function() {
          scope.$apply(function() {
            if (unknownOption.parent()) unknownOption.remove();
            ngModelCtrl.$setViewValue(selectElement.val());
          });
        });
      }

      function Multiple(scope, selectElement, ctrl) {
        var lastView;
        ctrl.$render = function() {
          var items = new HashMap(ctrl.$viewValue);
          forEach(selectElement.find(&#x27;option&#x27;), function(option) {
            option.selected = isDefined(items.get(option.value));
          });
        };

        // we have to do it on each watch since ngModel watches reference, but
        // we need to work of an array, so we need to see if anything was inserted/removed
        scope.$watch(function selectMultipleWatch() {
          if (!equals(lastView, ctrl.$viewValue)) {
            lastView = copy(ctrl.$viewValue);
            ctrl.$render();
          }
        });

        selectElement.bind(&#x27;change&#x27;, function() {
          scope.$apply(function() {
            var array = [];
            forEach(selectElement.find(&#x27;option&#x27;), function(option) {
              if (option.selected) {
                array.push(option.value);
              }
            });
            ctrl.$setViewValue(array);
          });
        });
      }

      function Options(scope, selectElement, ctrl) {
        var match;

        if (! (match = optionsExp.match(NG_OPTIONS_REGEXP))) {
          throw Error(
            &quot;Expected ngOptions in form of &#x27;_select_ (as _label_)? for (_key_,)?_value_ in _collection_ (track by _expr_)?&#x27;&quot; +
            &quot; but got &#x27;&quot; + optionsExp + &quot;&#x27;.&quot;);
        }

        var displayFn = $parse(match[2] || match[1]),
            valueName = match[4] || match[6],
            keyName = match[5],
            groupByFn = $parse(match[3] || &#x27;&#x27;),
            valueFn = $parse(match[2] ? match[1] : valueName),
            valuesFn = $parse(match[7]),
            track = match[8],
            trackFn = track ? $parse(match[8]) : null,
            // This is an array of array of existing option groups in DOM. We try to reuse these if possible
            // optionGroupsCache[0] is the options with no option group
            // optionGroupsCache[?][0] is the parent: either the SELECT or OPTGROUP element
            optionGroupsCache = [[{element: selectElement, label:&#x27;&#x27;}]];

        if (nullOption) {
          // compile the element since there might be bindings in it
          $compile(nullOption)(scope);

          // remove the class, which is added automatically because we recompile the element and it
          // becomes the compilation root
          nullOption.removeClass(&#x27;ng-scope&#x27;);

          // we need to remove it before calling selectElement.html(&#x27;&#x27;) because otherwise IE will
          // remove the label from the element. wtf?
          nullOption.remove();
        }

        // clear contents, we&#x27;ll add what&#x27;s needed based on the model
        selectElement.html(&#x27;&#x27;);

        selectElement.bind(&#x27;change&#x27;, function() {
          scope.$apply(function() {
            var optionGroup,
                collection = valuesFn(scope) || [],
                locals = {},
                key, value, optionElement, index, groupIndex, length, groupLength;

            if (multiple) {
              value = [];
              for (groupIndex = 0, groupLength = optionGroupsCache.length;
                   groupIndex &lt; groupLength;
                   groupIndex++) {
                // list of options for that group. (first item has the parent)
                optionGroup = optionGroupsCache[groupIndex];

                for(index = 1, length = optionGroup.length; index &lt; length; index++) {
                  if ((optionElement = optionGroup[index].element)[0].selected) {
                    key = optionElement.val();
                    if (keyName) locals[keyName] = key;
                    if (trackFn) {
                      for (var trackIndex = 0; trackIndex &lt; collection.length; trackIndex++) {
                        locals[valueName] = collection[trackIndex];
                        if (trackFn(scope, locals) == key) break;
                      } 
                    } else {
                      locals[valueName] = collection[key];
                    }
                    value.push(valueFn(scope, locals));
                  }
                }
              }
            } else {
              key = selectElement.val();
              if (key == &#x27;?&#x27;) {
                value = undefined;
              } else if (key == &#x27;&#x27;){
                value = null;
              } else {
                if (trackFn) {
                  for (var trackIndex = 0; trackIndex &lt; collection.length; trackIndex++) {
                    locals[valueName] = collection[trackIndex];
                    if (trackFn(scope, locals) == key) {
                      value = valueFn(scope, locals);
                      break;
                    }
                  }
                } else {
                  locals[valueName] = collection[key];
                  if (keyName) locals[keyName] = key;
                  value = valueFn(scope, locals);
                }
              }
            }
            ctrl.$setViewValue(value);
          });
        });

        ctrl.$render = render;

        // TODO(vojta): can&#x27;t we optimize this ?
        scope.$watch(render);

        function render() {
          var optionGroups = {&#x27;&#x27;:[]}, // Temporary location for the option groups before we render them
              optionGroupNames = [&#x27;&#x27;],
              optionGroupName,
              optionGroup,
              option,
              existingParent, existingOptions, existingOption,
              modelValue = ctrl.$modelValue,
              values = valuesFn(scope) || [],
              keys = keyName ? sortedKeys(values) : values,
              groupLength, length,
              groupIndex, index,
              locals = {},
              selected,
              selectedSet = false, // nothing is selected yet
              lastElement,
              element,
              label;

          if (multiple) {
            if (trackFn &amp;&amp; isArray(modelValue)) {
              selectedSet = new HashMap([]);
              for (var trackIndex = 0; trackIndex &lt; modelValue.length; trackIndex++) {
                locals[valueName] = modelValue[trackIndex];
                selectedSet.put(trackFn(scope, locals), modelValue[trackIndex]);
              }
            } else {
              selectedSet = new HashMap(modelValue);
            }
          }

          // We now build up the list of options we need (we merge later)
          for (index = 0; length = keys.length, index &lt; length; index++) {
               locals[valueName] = values[keyName ? locals[keyName]=keys[index]:index];
               optionGroupName = groupByFn(scope, locals) || &#x27;&#x27;;
            if (!(optionGroup = optionGroups[optionGroupName])) {
              optionGroup = optionGroups[optionGroupName] = [];
              optionGroupNames.push(optionGroupName);
            }
            if (multiple) {
              selected = selectedSet.remove(trackFn ? trackFn(scope, locals) : valueFn(scope, locals)) != undefined;
            } else {
              if (trackFn) {
                var modelCast = {};
                modelCast[valueName] = modelValue;
                selected = trackFn(scope, modelCast) === trackFn(scope, locals);
              } else {
                selected = modelValue === valueFn(scope, locals);
              }
              selectedSet = selectedSet || selected; // see if at least one item is selected
            }
            label = displayFn(scope, locals); // what will be seen by the user
            label = label === undefined ? &#x27;&#x27; : label; // doing displayFn(scope, locals) || &#x27;&#x27; overwrites zero values
            optionGroup.push({
              id: trackFn ? trackFn(scope, locals) : (keyName ? keys[index] : index),   // either the index into array or key from object
              label: label,
              selected: selected                   // determine if we should be selected
            });
          }
          if (!multiple) {
            if (nullOption || modelValue === null) {
              // insert null option if we have a placeholder, or the model is null
              optionGroups[&#x27;&#x27;].unshift({id:&#x27;&#x27;, label:&#x27;&#x27;, selected:!selectedSet});
            } else if (!selectedSet) {
              // option could not be found, we have to insert the undefined item
              optionGroups[&#x27;&#x27;].unshift({id:&#x27;?&#x27;, label:&#x27;&#x27;, selected:true});
            }
          }

          // Now we need to update the list of DOM nodes to match the optionGroups we computed above
          for (groupIndex = 0, groupLength = optionGroupNames.length;
               groupIndex &lt; groupLength;
               groupIndex++) {
            // current option group name or &#x27;&#x27; if no group
            optionGroupName = optionGroupNames[groupIndex];

            // list of options for that group. (first item has the parent)
            optionGroup = optionGroups[optionGroupName];

            if (optionGroupsCache.length &lt;= groupIndex) {
              // we need to grow the optionGroups
              existingParent = {
                element: optGroupTemplate.clone().attr(&#x27;label&#x27;, optionGroupName),
                label: optionGroup.label
              };
              existingOptions = [existingParent];
              optionGroupsCache.push(existingOptions);
              selectElement.append(existingParent.element);
            } else {
              existingOptions = optionGroupsCache[groupIndex];
              existingParent = existingOptions[0];  // either SELECT (no group) or OPTGROUP element

              // update the OPTGROUP label if not the same.
              if (existingParent.label != optionGroupName) {
                existingParent.element.attr(&#x27;label&#x27;, existingParent.label = optionGroupName);
              }
            }

            lastElement = null;  // start at the beginning
            for(index = 0, length = optionGroup.length; index &lt; length; index++) {
              option = optionGroup[index];
              if ((existingOption = existingOptions[index+1])) {
                // reuse elements
                lastElement = existingOption.element;
                if (existingOption.label !== option.label) {
                  lastElement.text(existingOption.label = option.label);
                }
                if (existingOption.id !== option.id) {
                  lastElement.val(existingOption.id = option.id);
                }
                // lastElement.prop(&#x27;selected&#x27;) provided by jQuery has side-effects
                if (lastElement[0].selected !== option.selected) {
                  lastElement.prop(&#x27;selected&#x27;, (existingOption.selected = option.selected));
                }
              } else {
                // grow elements

                // if it&#x27;s a null option
                if (option.id === &#x27;&#x27; &amp;&amp; nullOption) {
                  // put back the pre-compiled element
                  element = nullOption;
                } else {
                  // jQuery(v1.4.2) Bug: We should be able to chain the method calls, but
                  // in this version of jQuery on some browser the .text() returns a string
                  // rather then the element.
                  (element = optionTemplate.clone())
                      .val(option.id)
                      .attr(&#x27;selected&#x27;, option.selected)
                      .text(option.label);
                }

                existingOptions.push(existingOption = {
                    element: element,
                    label: option.label,
                    id: option.id,
                    selected: option.selected
                });
                if (lastElement) {
                  lastElement.after(element);
                } else {
                  existingParent.element.append(element);
                }
                lastElement = element;
              }
            }
            // remove any excessive OPTIONs in a group
            index++; // increment since the existingOptions[0] is parent element not OPTION
            while(existingOptions.length &gt; index) {
              existingOptions.pop().element.remove();
            }
          }
          // remove any excessive OPTGROUPs from select
          while(optionGroupsCache.length &gt; groupIndex) {
            optionGroupsCache.pop()[0].element.remove();
          }
        }
      }
    }
  }
}];

var optionDirective = [&#x27;$interpolate&#x27;, function($interpolate) {
  var nullSelectCtrl = {
    addOption: noop,
    removeOption: noop
  };

  return {
    restrict: &#x27;E&#x27;,
    priority: 100,
    compile: function(element, attr) {
      if (isUndefined(attr.value)) {
        var interpolateFn = $interpolate(element.text(), true);
        if (!interpolateFn) {
          attr.$set(&#x27;value&#x27;, element.text());
        }
      }

      return function (scope, element, attr) {
        var selectCtrlName = &#x27;$selectController&#x27;,
            parent = element.parent(),
            selectCtrl = parent.data(selectCtrlName) ||
              parent.parent().data(selectCtrlName); // in case we are in optgroup

        if (selectCtrl &amp;&amp; selectCtrl.databound) {
          // For some reason Opera defaults to true and if not overridden this messes up the repeater.
          // We don&#x27;t want the view to drive the initialization of the model anyway.
          element.prop(&#x27;selected&#x27;, false);
        } else {
          selectCtrl = nullSelectCtrl;
        }

        if (interpolateFn) {
          scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {
            attr.$set(&#x27;value&#x27;, newVal);
            if (newVal !== oldVal) selectCtrl.removeOption(oldVal);
            selectCtrl.addOption(newVal);
          });
        } else {
          selectCtrl.addOption(attr.value);
        }

        element.bind(&#x27;$destroy&#x27;, function() {
          selectCtrl.removeOption(attr.value);
        });
      };
    }
  }
}];

var styleDirective = valueFn({
  restrict: &#x27;E&#x27;,
  terminal: true
});

/**
 * Setup file for the Scenario.
 * Must be first in the compilation/bootstrap list.
 */

// Public namespace
angular.scenario = angular.scenario || {};

/**
 * Defines a new output format.
 *
 * @param {string} name the name of the new output format
 * @param {function()} fn function(context, runner) that generates the output
 */
angular.scenario.output = angular.scenario.output || function(name, fn) {
  angular.scenario.output[name] = fn;
};

/**
 * Defines a new DSL statement. If your factory function returns a Future
 * it&#x27;s returned, otherwise the result is assumed to be a map of functions
 * for chaining. Chained functions are subject to the same rules.
 *
 * Note: All functions on the chain are bound to the chain scope so values
 *   set on &quot;this&quot; in your statement function are available in the chained
 *   functions.
 *
 * @param {string} name The name of the statement
 * @param {function()} fn Factory function(), return a function for
 *  the statement.
 */
angular.scenario.dsl = angular.scenario.dsl || function(name, fn) {
  angular.scenario.dsl[name] = function() {
    function executeStatement(statement, args) {
      var result = statement.apply(this, args);
      if (angular.isFunction(result) || result instanceof angular.scenario.Future)
        return result;
      var self = this;
      var chain = angular.extend({}, result);
      angular.forEach(chain, function(value, name) {
        if (angular.isFunction(value)) {
          chain[name] = function() {
            return executeStatement.call(self, value, arguments);
          };
        } else {
          chain[name] = value;
        }
      });
      return chain;
    }
    var statement = fn.apply(this, arguments);
    return function() {
      return executeStatement.call(this, statement, arguments);
    };
  };
};

/**
 * Defines a new matcher for use with the expects() statement. The value
 * this.actual (like in Jasmine) is available in your matcher to compare
 * against. Your function should return a boolean. The future is automatically
 * created for you.
 *
 * @param {string} name The name of the matcher
 * @param {function()} fn The matching function(expected).
 */
angular.scenario.matcher = angular.scenario.matcher || function(name, fn) {
  angular.scenario.matcher[name] = function(expected) {
    var prefix = &#x27;expect &#x27; + this.future.name + &#x27; &#x27;;
    if (this.inverse) {
      prefix += &#x27;not &#x27;;
    }
    var self = this;
    this.addFuture(prefix + name + &#x27; &#x27; + angular.toJson(expected),
      function(done) {
        var error;
        self.actual = self.future.value;
        if ((self.inverse &amp;&amp; fn.call(self, expected)) ||
            (!self.inverse &amp;&amp; !fn.call(self, expected))) {
          error = &#x27;expected &#x27; + angular.toJson(expected) +
            &#x27; but was &#x27; + angular.toJson(self.actual);
        }
        done(error);
    });
  };
};

/**
 * Initialize the scenario runner and run !
 *
 * Access global window and document object
 * Access $runner through closure
 *
 * @param {Object=} config Config options
 */
angular.scenario.setUpAndRun = function(config) {
  var href = window.location.href;
  var body = _jQuery(document.body);
  var output = [];
  var objModel = new angular.scenario.ObjectModel($runner);

  if (config &amp;&amp; config.scenario_output) {
    output = config.scenario_output.split(&#x27;,&#x27;);
  }

  angular.forEach(angular.scenario.output, function(fn, name) {
    if (!output.length || indexOf(output,name) != -1) {
      var context = body.append(&#x27;&lt;div&gt;&lt;/div&gt;&#x27;).find(&#x27;div:last&#x27;);
      context.attr(&#x27;id&#x27;, name);
      fn.call({}, context, $runner, objModel);
    }
  });

  if (!/^http/.test(href) &amp;&amp; !/^https/.test(href)) {
    body.append(&#x27;&lt;p id=&quot;system-error&quot;&gt;&lt;/p&gt;&#x27;);
    body.find(&#x27;#system-error&#x27;).text(
      &#x27;Scenario runner must be run using http or https. The protocol &#x27; +
      href.split(&#x27;:&#x27;)[0] + &#x27;:// is not supported.&#x27;
    );
    return;
  }

  var appFrame = body.append(&#x27;&lt;div id=&quot;application&quot;&gt;&lt;/div&gt;&#x27;).find(&#x27;#application&#x27;);
  var application = new angular.scenario.Application(appFrame);

  $runner.on(&#x27;RunnerEnd&#x27;, function() {
    appFrame.css(&#x27;display&#x27;, &#x27;none&#x27;);
    appFrame.find(&#x27;iframe&#x27;).attr(&#x27;src&#x27;, &#x27;about:blank&#x27;);
  });

  $runner.on(&#x27;RunnerError&#x27;, function(error) {
    if (window.console) {
      console.log(formatException(error));
    } else {
      // Do something for IE
      alert(error);
    }
  });

  $runner.run(application);
};

/**
 * Iterates through list with iterator function that must call the
 * continueFunction to continue iterating.
 *
 * @param {Array} list list to iterate over
 * @param {function()} iterator Callback function(value, continueFunction)
 * @param {function()} done Callback function(error, result) called when
 *   iteration finishes or an error occurs.
 */
function asyncForEach(list, iterator, done) {
  var i = 0;
  function loop(error, index) {
    if (index &amp;&amp; index &gt; i) {
      i = index;
    }
    if (error || i &gt;= list.length) {
      done(error);
    } else {
      try {
        iterator(list[i++], loop);
      } catch (e) {
        done(e);
      }
    }
  }
  loop();
}

/**
 * Formats an exception into a string with the stack trace, but limits
 * to a specific line length.
 *
 * @param {Object} error The exception to format, can be anything throwable
 * @param {Number=} [maxStackLines=5] max lines of the stack trace to include
 *  default is 5.
 */
function formatException(error, maxStackLines) {
  maxStackLines = maxStackLines || 5;
  var message = error.toString();
  if (error.stack) {
    var stack = error.stack.split(&#x27;\n&#x27;);
    if (stack[0].indexOf(message) === -1) {
      maxStackLines++;
      stack.unshift(error.message);
    }
    message = stack.slice(0, maxStackLines).join(&#x27;\n&#x27;);
  }
  return message;
}

/**
 * Returns a function that gets the file name and line number from a
 * location in the stack if available based on the call site.
 *
 * Note: this returns another function because accessing .stack is very
 * expensive in Chrome.
 *
 * @param {Number} offset Number of stack lines to skip
 */
function callerFile(offset) {
  var error = new Error();

  return function() {
    var line = (error.stack || &#x27;&#x27;).split(&#x27;\n&#x27;)[offset];

    // Clean up the stack trace line
    if (line) {
      if (line.indexOf(&#x27;@&#x27;) !== -1) {
        // Firefox
        line = line.substring(line.indexOf(&#x27;@&#x27;)+1);
      } else {
        // Chrome
        line = line.substring(line.indexOf(&#x27;(&#x27;)+1).replace(&#x27;)&#x27;, &#x27;&#x27;);
      }
    }

    return line || &#x27;&#x27;;
  };
}


/**
 * Don&#x27;t use the jQuery trigger method since it works incorrectly.
 *
 * jQuery notifies listeners and then changes the state of a checkbox and
 * does not create a real browser event. A real click changes the state of
 * the checkbox and then notifies listeners.
 *
 * To work around this we instead use our own handler that fires a real event.
 */
(function(fn){
  var parentTrigger = fn.trigger;
  fn.trigger = function(type) {
    if (/(click|change|keydown|blur|input|mousedown|mouseup)/.test(type)) {
      var processDefaults = [];
      this.each(function(index, node) {
        processDefaults.push(browserTrigger(node, type));
      });

      // this is not compatible with jQuery - we return an array of returned values,
      // so that scenario runner know whether JS code has preventDefault() of the event or not...
      return processDefaults;
    }
    return parentTrigger.apply(this, arguments);
  };
})(_jQuery.fn);

/**
 * Finds all bindings with the substring match of name and returns an
 * array of their values.
 *
 * @param {string} bindExp The name to match
 * @return {Array.&lt;string&gt;} String of binding values
 */
_jQuery.fn.bindings = function(windowJquery, bindExp) {
  var result = [], match,
      bindSelector = &#x27;.ng-binding:visible&#x27;;
  if (angular.isString(bindExp)) {
    bindExp = bindExp.replace(/\s/g, &#x27;&#x27;);
    match = function (actualExp) {
      if (actualExp) {
        actualExp = actualExp.replace(/\s/g, &#x27;&#x27;);
        if (actualExp == bindExp) return true;
        if (actualExp.indexOf(bindExp) == 0) {
          return actualExp.charAt(bindExp.length) == &#x27;|&#x27;;
        }
      }
    }
  } else if (bindExp) {
    match = function(actualExp) {
      return actualExp &amp;&amp; bindExp.exec(actualExp);
    }
  } else {
    match = function(actualExp) {
      return !!actualExp;
    };
  }
  var selection = this.find(bindSelector);
  if (this.is(bindSelector)) {
    selection = selection.add(this);
  }

  function push(value) {
    if (value == undefined) {
      value = &#x27;&#x27;;
    } else if (typeof value != &#x27;string&#x27;) {
      value = angular.toJson(value);
    }
    result.push(&#x27;&#x27; + value);
  }

  selection.each(function() {
    var element = windowJquery(this),
        binding;
    if (binding = element.data(&#x27;$binding&#x27;)) {
      if (typeof binding == &#x27;string&#x27;) {
        if (match(binding)) {
          push(element.scope().$eval(binding));
        }
      } else {
        if (!angular.isArray(binding)) {
          binding = [binding];
        }
        for(var fns, j=0, jj=binding.length;  j&lt;jj; j++) {
          fns = binding[j];
          if (fns.parts) {
            fns = fns.parts;
          } else {
            fns = [fns];
          }
          for (var scope, fn, i = 0, ii = fns.length; i &lt; ii; i++) {
            if(match((fn = fns[i]).exp)) {
              push(fn(scope = scope || element.scope()));
            }
          }
        }
      }
    }
  });
  return result;
};

(function() {
  var msie = parseInt((/msie (\d+)/.exec(navigator.userAgent.toLowerCase()) || [])[1], 10);

  function indexOf(array, obj) {
    if (array.indexOf) return array.indexOf(obj);

    for ( var i = 0; i &lt; array.length; i++) {
      if (obj === array[i]) return i;
    }
    return -1;
  }



  /**
   * Triggers a browser event. Attempts to choose the right event if one is
   * not specified.
   *
   * @param {Object} element Either a wrapped jQuery/jqLite node or a DOMElement
   * @param {string} eventType Optional event type.
   * @param {Array.&lt;string&gt;=} keys Optional list of pressed keys
   *        (valid values: &#x27;alt&#x27;, &#x27;meta&#x27;, &#x27;shift&#x27;, &#x27;ctrl&#x27;)
   * @param {number} x Optional x-coordinate for mouse/touch events.
   * @param {number} y Optional y-coordinate for mouse/touch events.
   */
  window.browserTrigger = function browserTrigger(element, eventType, keys, x, y) {
    if (element &amp;&amp; !element.nodeName) element = element[0];
    if (!element) return;

    var inputType = (element.type) ? element.type.toLowerCase() : null,
        nodeName = element.nodeName.toLowerCase();

    if (!eventType) {
      eventType = {
        &#x27;text&#x27;:            &#x27;change&#x27;,
        &#x27;textarea&#x27;:        &#x27;change&#x27;,
        &#x27;hidden&#x27;:          &#x27;change&#x27;,
        &#x27;password&#x27;:        &#x27;change&#x27;,
        &#x27;button&#x27;:          &#x27;click&#x27;,
        &#x27;submit&#x27;:          &#x27;click&#x27;,
        &#x27;reset&#x27;:           &#x27;click&#x27;,
        &#x27;image&#x27;:           &#x27;click&#x27;,
        &#x27;checkbox&#x27;:        &#x27;click&#x27;,
        &#x27;radio&#x27;:           &#x27;click&#x27;,
        &#x27;select-one&#x27;:      &#x27;change&#x27;,
        &#x27;select-multiple&#x27;: &#x27;change&#x27;,
        &#x27;_default_&#x27;:       &#x27;click&#x27;
      }[inputType || &#x27;_default_&#x27;];
    }

    if (nodeName == &#x27;option&#x27;) {
      element.parentNode.value = element.value;
      element = element.parentNode;
      eventType = &#x27;change&#x27;;
    }

    keys = keys || [];
    function pressed(key) {
      return indexOf(keys, key) !== -1;
    }

    if (msie &lt; 9) {
      if (inputType == &#x27;radio&#x27; || inputType == &#x27;checkbox&#x27;) {
          element.checked = !element.checked;
      }

      // WTF!!! Error: Unspecified error.
      // Don&#x27;t know why, but some elements when detached seem to be in inconsistent state and
      // calling .fireEvent() on them will result in very unhelpful error (Error: Unspecified error)
      // forcing the browser to compute the element position (by reading its CSS)
      // puts the element in consistent state.
      element.style.posLeft;

      // TODO(vojta): create event objects with pressed keys to get it working on IE&lt;9
      var ret = element.fireEvent(&#x27;on&#x27; + eventType);
      if (inputType == &#x27;submit&#x27;) {
        while(element) {
          if (element.nodeName.toLowerCase() == &#x27;form&#x27;) {
            element.fireEvent(&#x27;onsubmit&#x27;);
            break;
          }
          element = element.parentNode;
        }
      }
      return ret;
    } else {
      var evnt = document.createEvent(&#x27;MouseEvents&#x27;),
          originalPreventDefault = evnt.preventDefault,
          appWindow = element.ownerDocument.defaultView,
          fakeProcessDefault = true,
          finalProcessDefault,
          angular = appWindow.angular || {};

      // igor: temporary fix for https://bugzilla.mozilla.org/show_bug.cgi?id=684208
      angular[&#x27;ff-684208-preventDefault&#x27;] = false;
      evnt.preventDefault = function() {
        fakeProcessDefault = false;
        return originalPreventDefault.apply(evnt, arguments);
      };

      x = x || 0;
      y = y || 0;
      evnt.initMouseEvent(eventType, true, true, window, 0, x, y, x, y, pressed(&#x27;ctrl&#x27;), pressed(&#x27;alt&#x27;),
          pressed(&#x27;shift&#x27;), pressed(&#x27;meta&#x27;), 0, element);

      element.dispatchEvent(evnt);
      finalProcessDefault = !(angular[&#x27;ff-684208-preventDefault&#x27;] || !fakeProcessDefault);

      delete angular[&#x27;ff-684208-preventDefault&#x27;];

      return finalProcessDefault;
    }
  }
}());

/**
 * Represents the application currently being tested and abstracts usage
 * of iframes or separate windows.
 *
 * @param {Object} context jQuery wrapper around HTML context.
 */
angular.scenario.Application = function(context) {
  this.context = context;
  context.append(
    &#x27;&lt;h2&gt;Current URL: &lt;a href=&quot;about:blank&quot;&gt;None&lt;/a&gt;&lt;/h2&gt;&#x27; +
    &#x27;&lt;div id=&quot;test-frames&quot;&gt;&lt;/div&gt;&#x27;
  );
};

/**
 * Gets the jQuery collection of frames. Don&#x27;t use this directly because
 * frames may go stale.
 *
 * @private
 * @return {Object} jQuery collection
 */
angular.scenario.Application.prototype.getFrame_ = function() {
  return this.context.find(&#x27;#test-frames iframe:last&#x27;);
};

/**
 * Gets the window of the test runner frame. Always favor executeAction()
 * instead of this method since it prevents you from getting a stale window.
 *
 * @private
 * @return {Object} the window of the frame
 */
angular.scenario.Application.prototype.getWindow_ = function() {
  var contentWindow = this.getFrame_().prop(&#x27;contentWindow&#x27;);
  if (!contentWindow)
    throw &#x27;Frame window is not accessible.&#x27;;
  return contentWindow;
};

/**
 * Changes the location of the frame.
 *
 * @param {string} url The URL. If it begins with a # then only the
 *   hash of the page is changed.
 * @param {function()} loadFn function($window, $document) Called when frame loads.
 * @param {function()} errorFn function(error) Called if any error when loading.
 */
angular.scenario.Application.prototype.navigateTo = function(url, loadFn, errorFn) {
  var self = this;
  var frame = self.getFrame_();
  //TODO(esprehn): Refactor to use rethrow()
  errorFn = errorFn || function(e) { throw e; };
  if (url === &#x27;about:blank&#x27;) {
    errorFn(&#x27;Sandbox Error: Navigating to about:blank is not allowed.&#x27;);
  } else if (url.charAt(0) === &#x27;#&#x27;) {
    url = frame.attr(&#x27;src&#x27;).split(&#x27;#&#x27;)[0] + url;
    frame.attr(&#x27;src&#x27;, url);
    self.executeAction(loadFn);
  } else {
    frame.remove();
    self.context.find(&#x27;#test-frames&#x27;).append(&#x27;&lt;iframe&gt;&#x27;);
    frame = self.getFrame_();

    frame.load(function() {
      frame.unbind();
      try {
        var $window = self.getWindow_();

        if ($window.angular) {
          // Disable animations

          // TODO(i): this doesn&#x27;t disable javascript animations
          //          we don&#x27;t need that for our tests, but it should be done
          $window.angular.resumeBootstrap([[&#x27;$provide&#x27;, function($provide) {
            $provide.decorator(&#x27;$sniffer&#x27;, function($delegate) {
              $delegate.transitions = false;
              $delegate.animations = false;
              return $delegate;
            });
          }]]);
        }

        self.executeAction(loadFn);
      } catch (e) {
        errorFn(e);
      }
    }).attr(&#x27;src&#x27;, url);

    // for IE compatibility set the name *after* setting the frame url
    frame[0].contentWindow.name = &quot;NG_DEFER_BOOTSTRAP!&quot;;
  }
  self.context.find(&#x27;&gt; h2 a&#x27;).attr(&#x27;href&#x27;, url).text(url);
};

/**
 * Executes a function in the context of the tested application. Will wait
 * for all pending angular xhr requests before executing.
 *
 * @param {function()} action The callback to execute. function($window, $document)
 *  $document is a jQuery wrapped document.
 */
angular.scenario.Application.prototype.executeAction = function(action) {
  var self = this;
  var $window = this.getWindow_();
  if (!$window.document) {
    throw &#x27;Sandbox Error: Application document not accessible.&#x27;;
  }
  if (!$window.angular) {
    return action.call(this, $window, _jQuery($window.document));
  }
  angularInit($window.document, function(element) {
    var $injector = $window.angular.element(element).injector();
    var $element = _jQuery(element);

    $element.injector = function() {
      return $injector;
    };

    $injector.invoke(function($browser){
      $browser.notifyWhenNoOutstandingRequests(function() {
        action.call(self, $window, $element);
      });
    });
  });
};

/**
 * The representation of define blocks. Don&#x27;t used directly, instead use
 * define() in your tests.
 *
 * @param {string} descName Name of the block
 * @param {Object} parent describe or undefined if the root.
 */
angular.scenario.Describe = function(descName, parent) {
  this.only = parent &amp;&amp; parent.only;
  this.beforeEachFns = [];
  this.afterEachFns = [];
  this.its = [];
  this.children = [];
  this.name = descName;
  this.parent = parent;
  this.id = angular.scenario.Describe.id++;

  /**
   * Calls all before functions.
   */
  var beforeEachFns = this.beforeEachFns;
  this.setupBefore = function() {
    if (parent) parent.setupBefore.call(this);
    angular.forEach(beforeEachFns, function(fn) { fn.call(this); }, this);
  };

  /**
   * Calls all after functions.
   */
  var afterEachFns = this.afterEachFns;
  this.setupAfter  = function() {
    angular.forEach(afterEachFns, function(fn) { fn.call(this); }, this);
    if (parent) parent.setupAfter.call(this);
  };
};

// Shared Unique ID generator for every describe block
angular.scenario.Describe.id = 0;

// Shared Unique ID generator for every it (spec)
angular.scenario.Describe.specId = 0;

/**
 * Defines a block to execute before each it or nested describe.
 *
 * @param {function()} body Body of the block.
 */
angular.scenario.Describe.prototype.beforeEach = function(body) {
  this.beforeEachFns.push(body);
};

/**
 * Defines a block to execute after each it or nested describe.
 *
 * @param {function()} body Body of the block.
 */
angular.scenario.Describe.prototype.afterEach = function(body) {
  this.afterEachFns.push(body);
};

/**
 * Creates a new describe block that&#x27;s a child of this one.
 *
 * @param {string} name Name of the block. Appended to the parent block&#x27;s name.
 * @param {function()} body Body of the block.
 */
angular.scenario.Describe.prototype.describe = function(name, body) {
  var child = new angular.scenario.Describe(name, this);
  this.children.push(child);
  body.call(child);
};

/**
 * Same as describe() but makes ddescribe blocks the only to run.
 *
 * @param {string} name Name of the test.
 * @param {function()} body Body of the block.
 */
angular.scenario.Describe.prototype.ddescribe = function(name, body) {
  var child = new angular.scenario.Describe(name, this);
  child.only = true;
  this.children.push(child);
  body.call(child);
};

/**
 * Use to disable a describe block.
 */
angular.scenario.Describe.prototype.xdescribe = angular.noop;

/**
 * Defines a test.
 *
 * @param {string} name Name of the test.
 * @param {function()} vody Body of the block.
 */
angular.scenario.Describe.prototype.it = function(name, body) {
  this.its.push({
    id: angular.scenario.Describe.specId++,
    definition: this,
    only: this.only,
    name: name,
    before: this.setupBefore,
    body: body,
    after: this.setupAfter
  });
};

/**
 * Same as it() but makes iit tests the only test to run.
 *
 * @param {string} name Name of the test.
 * @param {function()} body Body of the block.
 */
angular.scenario.Describe.prototype.iit = function(name, body) {
  this.it.apply(this, arguments);
  this.its[this.its.length-1].only = true;
};

/**
 * Use to disable a test block.
 */
angular.scenario.Describe.prototype.xit = angular.noop;

/**
 * Gets an array of functions representing all the tests (recursively).
 * that can be executed with SpecRunner&#x27;s.
 *
 * @return {Array&lt;Object&gt;} Array of it blocks {
 *   definition : Object // parent Describe
 *   only: boolean
 *   name: string
 *   before: Function
 *   body: Function
 *   after: Function
 *  }
 */
angular.scenario.Describe.prototype.getSpecs = function() {
  var specs = arguments[0] || [];
  angular.forEach(this.children, function(child) {
    child.getSpecs(specs);
  });
  angular.forEach(this.its, function(it) {
    specs.push(it);
  });
  var only = [];
  angular.forEach(specs, function(it) {
    if (it.only) {
      only.push(it);
    }
  });
  return (only.length &amp;&amp; only) || specs;
};

/**
 * A future action in a spec.
 *
 * @param {string} name of the future action
 * @param {function()} future callback(error, result)
 * @param {function()} Optional. function that returns the file/line number.
 */
angular.scenario.Future = function(name, behavior, line) {
  this.name = name;
  this.behavior = behavior;
  this.fulfilled = false;
  this.value = undefined;
  this.parser = angular.identity;
  this.line = line || function() { return &#x27;&#x27;; };
};

/**
 * Executes the behavior of the closure.
 *
 * @param {function()} doneFn Callback function(error, result)
 */
angular.scenario.Future.prototype.execute = function(doneFn) {
  var self = this;
  this.behavior(function(error, result) {
    self.fulfilled = true;
    if (result) {
      try {
        result = self.parser(result);
      } catch(e) {
        error = e;
      }
    }
    self.value = error || result;
    doneFn(error, result);
  });
};

/**
 * Configures the future to convert it&#x27;s final with a function fn(value)
 *
 * @param {function()} fn function(value) that returns the parsed value
 */
angular.scenario.Future.prototype.parsedWith = function(fn) {
  this.parser = fn;
  return this;
};

/**
 * Configures the future to parse it&#x27;s final value from JSON
 * into objects.
 */
angular.scenario.Future.prototype.fromJson = function() {
  return this.parsedWith(angular.fromJson);
};

/**
 * Configures the future to convert it&#x27;s final value from objects
 * into JSON.
 */
angular.scenario.Future.prototype.toJson = function() {
  return this.parsedWith(angular.toJson);
};

/**
 * Maintains an object tree from the runner events.
 *
 * @param {Object} runner The scenario Runner instance to connect to.
 *
 * TODO(esprehn): Every output type creates one of these, but we probably
 *  want one global shared instance. Need to handle events better too
 *  so the HTML output doesn&#x27;t need to do spec model.getSpec(spec.id)
 *  silliness.
 *
 * TODO(vojta) refactor on, emit methods (from all objects) - use inheritance
 */
angular.scenario.ObjectModel = function(runner) {
  var self = this;

  this.specMap = {};
  this.listeners = [];
  this.value = {
    name: &#x27;&#x27;,
    children: {}
  };

  runner.on(&#x27;SpecBegin&#x27;, function(spec) {
    var block = self.value,
        definitions = [];

    angular.forEach(self.getDefinitionPath(spec), function(def) {
      if (!block.children[def.name]) {
        block.children[def.name] = {
          id: def.id,
          name: def.name,
          children: {},
          specs: {}
        };
      }
      block = block.children[def.name];
      definitions.push(def.name);
    });

    var it = self.specMap[spec.id] =
             block.specs[spec.name] =
             new angular.scenario.ObjectModel.Spec(spec.id, spec.name, definitions);

    // forward the event
    self.emit(&#x27;SpecBegin&#x27;, it);
  });

  runner.on(&#x27;SpecError&#x27;, function(spec, error) {
    var it = self.getSpec(spec.id);
    it.status = &#x27;error&#x27;;
    it.error = error;

    // forward the event
    self.emit(&#x27;SpecError&#x27;, it, error);
  });

  runner.on(&#x27;SpecEnd&#x27;, function(spec) {
    var it = self.getSpec(spec.id);
    complete(it);

    // forward the event
    self.emit(&#x27;SpecEnd&#x27;, it);
  });

  runner.on(&#x27;StepBegin&#x27;, function(spec, step) {
    var it = self.getSpec(spec.id);
    var step = new angular.scenario.ObjectModel.Step(step.name);
    it.steps.push(step);

    // forward the event
    self.emit(&#x27;StepBegin&#x27;, it, step);
  });

  runner.on(&#x27;StepEnd&#x27;, function(spec) {
    var it = self.getSpec(spec.id);
    var step = it.getLastStep();
    if (step.name !== step.name)
      throw &#x27;Events fired in the wrong order. Step names don\&#x27;t match.&#x27;;
    complete(step);

    // forward the event
    self.emit(&#x27;StepEnd&#x27;, it, step);
  });

  runner.on(&#x27;StepFailure&#x27;, function(spec, step, error) {
    var it = self.getSpec(spec.id),
        modelStep = it.getLastStep();

    modelStep.setErrorStatus(&#x27;failure&#x27;, error, step.line());
    it.setStatusFromStep(modelStep);

    // forward the event
    self.emit(&#x27;StepFailure&#x27;, it, modelStep, error);
  });

  runner.on(&#x27;StepError&#x27;, function(spec, step, error) {
    var it = self.getSpec(spec.id),
        modelStep = it.getLastStep();

    modelStep.setErrorStatus(&#x27;error&#x27;, error, step.line());
    it.setStatusFromStep(modelStep);

    // forward the event
    self.emit(&#x27;StepError&#x27;, it, modelStep, error);
  });

  runner.on(&#x27;RunnerBegin&#x27;, function() {
    self.emit(&#x27;RunnerBegin&#x27;);
  });
  runner.on(&#x27;RunnerEnd&#x27;, function() {
    self.emit(&#x27;RunnerEnd&#x27;);
  });

  function complete(item) {
    item.endTime = new Date().getTime();
    item.duration = item.endTime - item.startTime;
    item.status = item.status || &#x27;success&#x27;;
  }
};

/**
 * Adds a listener for an event.
 *
 * @param {string} eventName Name of the event to add a handler for
 * @param {function()} listener Function that will be called when event is fired
 */
angular.scenario.ObjectModel.prototype.on = function(eventName, listener) {
  eventName = eventName.toLowerCase();
  this.listeners[eventName] = this.listeners[eventName] || [];
  this.listeners[eventName].push(listener);
};

/**
 * Emits an event which notifies listeners and passes extra
 * arguments.
 *
 * @param {string} eventName Name of the event to fire.
 */
angular.scenario.ObjectModel.prototype.emit = function(eventName) {
  var self = this,
      args = Array.prototype.slice.call(arguments, 1),
      eventName = eventName.toLowerCase();

  if (this.listeners[eventName]) {
    angular.forEach(this.listeners[eventName], function(listener) {
      listener.apply(self, args);
    });
  }
};

/**
 * Computes the path of definition describe blocks that wrap around
 * this spec.
 *
 * @param spec Spec to compute the path for.
 * @return {Array&lt;Describe&gt;} The describe block path
 */
angular.scenario.ObjectModel.prototype.getDefinitionPath = function(spec) {
  var path = [];
  var currentDefinition = spec.definition;
  while (currentDefinition &amp;&amp; currentDefinition.name) {
    path.unshift(currentDefinition);
    currentDefinition = currentDefinition.parent;
  }
  return path;
};

/**
 * Gets a spec by id.
 *
 * @param {string} The id of the spec to get the object for.
 * @return {Object} the Spec instance
 */
angular.scenario.ObjectModel.prototype.getSpec = function(id) {
  return this.specMap[id];
};

/**
 * A single it block.
 *
 * @param {string} id Id of the spec
 * @param {string} name Name of the spec
 * @param {Array&lt;string&gt;=} definitionNames List of all describe block names that wrap this spec
 */
angular.scenario.ObjectModel.Spec = function(id, name, definitionNames) {
  this.id = id;
  this.name = name;
  this.startTime = new Date().getTime();
  this.steps = [];
  this.fullDefinitionName = (definitionNames || []).join(&#x27; &#x27;);
};

/**
 * Adds a new step to the Spec.
 *
 * @param {string} step Name of the step (really name of the future)
 * @return {Object} the added step
 */
angular.scenario.ObjectModel.Spec.prototype.addStep = function(name) {
  var step = new angular.scenario.ObjectModel.Step(name);
  this.steps.push(step);
  return step;
};

/**
 * Gets the most recent step.
 *
 * @return {Object} the step
 */
angular.scenario.ObjectModel.Spec.prototype.getLastStep = function() {
  return this.steps[this.steps.length-1];
};

/**
 * Set status of the Spec from given Step
 *
 * @param {angular.scenario.ObjectModel.Step} step
 */
angular.scenario.ObjectModel.Spec.prototype.setStatusFromStep = function(step) {
  if (!this.status || step.status == &#x27;error&#x27;) {
    this.status = step.status;
    this.error = step.error;
    this.line = step.line;
  }
};

/**
 * A single step inside a Spec.
 *
 * @param {string} step Name of the step
 */
angular.scenario.ObjectModel.Step = function(name) {
  this.name = name;
  this.startTime = new Date().getTime();
};

/**
 * Helper method for setting all error status related properties
 *
 * @param {string} status
 * @param {string} error
 * @param {string} line
 */
angular.scenario.ObjectModel.Step.prototype.setErrorStatus = function(status, error, line) {
  this.status = status;
  this.error = error;
  this.line = line;
};

/**
 * Runner for scenarios
 *
 * Has to be initialized before any test is loaded,
 * because it publishes the API into window (global space).
 */
angular.scenario.Runner = function($window) {
  this.listeners = [];
  this.$window = $window;
  this.rootDescribe = new angular.scenario.Describe();
  this.currentDescribe = this.rootDescribe;
  this.api = {
    it: this.it,
    iit: this.iit,
    xit: angular.noop,
    describe: this.describe,
    ddescribe: this.ddescribe,
    xdescribe: angular.noop,
    beforeEach: this.beforeEach,
    afterEach: this.afterEach
  };
  angular.forEach(this.api, angular.bind(this, function(fn, key) {
    this.$window[key] = angular.bind(this, fn);
  }));
};

/**
 * Emits an event which notifies listeners and passes extra
 * arguments.
 *
 * @param {string} eventName Name of the event to fire.
 */
angular.scenario.Runner.prototype.emit = function(eventName) {
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  eventName = eventName.toLowerCase();
  if (!this.listeners[eventName])
    return;
  angular.forEach(this.listeners[eventName], function(listener) {
    listener.apply(self, args);
  });
};

/**
 * Adds a listener for an event.
 *
 * @param {string} eventName The name of the event to add a handler for
 * @param {string} listener The fn(...) that takes the extra arguments from emit()
 */
angular.scenario.Runner.prototype.on = function(eventName, listener) {
  eventName = eventName.toLowerCase();
  this.listeners[eventName] = this.listeners[eventName] || [];
  this.listeners[eventName].push(listener);
};

/**
 * Defines a describe block of a spec.
 *
 * @see Describe.js
 *
 * @param {string} name Name of the block
 * @param {function()} body Body of the block
 */
angular.scenario.Runner.prototype.describe = function(name, body) {
  var self = this;
  this.currentDescribe.describe(name, function() {
    var parentDescribe = self.currentDescribe;
    self.currentDescribe = this;
    try {
      body.call(this);
    } finally {
      self.currentDescribe = parentDescribe;
    }
  });
};

/**
 * Same as describe, but makes ddescribe the only blocks to run.
 *
 * @see Describe.js
 *
 * @param {string} name Name of the block
 * @param {function()} body Body of the block
 */
angular.scenario.Runner.prototype.ddescribe = function(name, body) {
  var self = this;
  this.currentDescribe.ddescribe(name, function() {
    var parentDescribe = self.currentDescribe;
    self.currentDescribe = this;
    try {
      body.call(this);
    } finally {
      self.currentDescribe = parentDescribe;
    }
  });
};

/**
 * Defines a test in a describe block of a spec.
 *
 * @see Describe.js
 *
 * @param {string} name Name of the block
 * @param {function()} body Body of the block
 */
angular.scenario.Runner.prototype.it = function(name, body) {
  this.currentDescribe.it(name, body);
};

/**
 * Same as it, but makes iit tests the only tests to run.
 *
 * @see Describe.js
 *
 * @param {string} name Name of the block
 * @param {function()} body Body of the block
 */
angular.scenario.Runner.prototype.iit = function(name, body) {
  this.currentDescribe.iit(name, body);
};

/**
 * Defines a function to be called before each it block in the describe
 * (and before all nested describes).
 *
 * @see Describe.js
 *
 * @param {function()} Callback to execute
 */
angular.scenario.Runner.prototype.beforeEach = function(body) {
  this.currentDescribe.beforeEach(body);
};

/**
 * Defines a function to be called after each it block in the describe
 * (and before all nested describes).
 *
 * @see Describe.js
 *
 * @param {function()} Callback to execute
 */
angular.scenario.Runner.prototype.afterEach = function(body) {
  this.currentDescribe.afterEach(body);
};

/**
 * Creates a new spec runner.
 *
 * @private
 * @param {Object} scope parent scope
 */
angular.scenario.Runner.prototype.createSpecRunner_ = function(scope) {
  var child = scope.$new();
  var Cls = angular.scenario.SpecRunner;

  // Export all the methods to child scope manually as now we don&#x27;t mess controllers with scopes
  // TODO(vojta): refactor scenario runner so that these objects are not tightly coupled as current
  for (var name in Cls.prototype)
    child[name] = angular.bind(child, Cls.prototype[name]);

  Cls.call(child);
  return child;
};

/**
 * Runs all the loaded tests with the specified runner class on the
 * provided application.
 *
 * @param {angular.scenario.Application} application App to remote control.
 */
angular.scenario.Runner.prototype.run = function(application) {
  var self = this;
  var $root = angular.injector([&#x27;ng&#x27;]).get(&#x27;$rootScope&#x27;);
  angular.extend($root, this);
  angular.forEach(angular.scenario.Runner.prototype, function(fn, name) {
    $root[name] = angular.bind(self, fn);
  });
  $root.application = application;
  $root.emit(&#x27;RunnerBegin&#x27;);
  asyncForEach(this.rootDescribe.getSpecs(), function(spec, specDone) {
    var dslCache = {};
    var runner = self.createSpecRunner_($root);
    angular.forEach(angular.scenario.dsl, function(fn, key) {
      dslCache[key] = fn.call($root);
    });
    angular.forEach(angular.scenario.dsl, function(fn, key) {
      self.$window[key] = function() {
        var line = callerFile(3);
        var scope = runner.$new();

        // Make the dsl accessible on the current chain
        scope.dsl = {};
        angular.forEach(dslCache, function(fn, key) {
          scope.dsl[key] = function() {
            return dslCache[key].apply(scope, arguments);
          };
        });

        // Make these methods work on the current chain
        scope.addFuture = function() {
          Array.prototype.push.call(arguments, line);
          return angular.scenario.SpecRunner.
            prototype.addFuture.apply(scope, arguments);
        };
        scope.addFutureAction = function() {
          Array.prototype.push.call(arguments, line);
          return angular.scenario.SpecRunner.
            prototype.addFutureAction.apply(scope, arguments);
        };

        return scope.dsl[key].apply(scope, arguments);
      };
    });
    runner.run(spec, function() {
      runner.$destroy();
      specDone.apply(this, arguments);
    });
  },
  function(error) {
    if (error) {
      self.emit(&#x27;RunnerError&#x27;, error);
    }
    self.emit(&#x27;RunnerEnd&#x27;);
  });
};

/**
 * This class is the &quot;this&quot; of the it/beforeEach/afterEach method.
 * Responsibilities:
 *   - &quot;this&quot; for it/beforeEach/afterEach
 *   - keep state for single it/beforeEach/afterEach execution
 *   - keep track of all of the futures to execute
 *   - run single spec (execute each future)
 */
angular.scenario.SpecRunner = function() {
  this.futures = [];
  this.afterIndex = 0;
};

/**
 * Executes a spec which is an it block with associated before/after functions
 * based on the describe nesting.
 *
 * @param {Object} spec A spec object
 * @param {function()} specDone function that is called when the spec finshes. Function(error, index)
 */
angular.scenario.SpecRunner.prototype.run = function(spec, specDone) {
  var self = this;
  this.spec = spec;

  this.emit(&#x27;SpecBegin&#x27;, spec);

  try {
    spec.before.call(this);
    spec.body.call(this);
    this.afterIndex = this.futures.length;
    spec.after.call(this);
  } catch (e) {
    this.emit(&#x27;SpecError&#x27;, spec, e);
    this.emit(&#x27;SpecEnd&#x27;, spec);
    specDone();
    return;
  }

  var handleError = function(error, done) {
    if (self.error) {
      return done();
    }
    self.error = true;
    done(null, self.afterIndex);
  };

  asyncForEach(
    this.futures,
    function(future, futureDone) {
      self.step = future;
      self.emit(&#x27;StepBegin&#x27;, spec, future);
      try {
        future.execute(function(error) {
          if (error) {
            self.emit(&#x27;StepFailure&#x27;, spec, future, error);
            self.emit(&#x27;StepEnd&#x27;, spec, future);
            return handleError(error, futureDone);
          }
          self.emit(&#x27;StepEnd&#x27;, spec, future);
          self.$window.setTimeout(function() { futureDone(); }, 0);
        });
      } catch (e) {
        self.emit(&#x27;StepError&#x27;, spec, future, e);
        self.emit(&#x27;StepEnd&#x27;, spec, future);
        handleError(e, futureDone);
      }
    },
    function(e) {
      if (e) {
        self.emit(&#x27;SpecError&#x27;, spec, e);
      }
      self.emit(&#x27;SpecEnd&#x27;, spec);
      // Call done in a timeout so exceptions don&#x27;t recursively
      // call this function
      self.$window.setTimeout(function() { specDone(); }, 0);
    }
  );
};

/**
 * Adds a new future action.
 *
 * Note: Do not pass line manually. It happens automatically.
 *
 * @param {string} name Name of the future
 * @param {function()} behavior Behavior of the future
 * @param {function()} line fn() that returns file/line number
 */
angular.scenario.SpecRunner.prototype.addFuture = function(name, behavior, line) {
  var future = new angular.scenario.Future(name, angular.bind(this, behavior), line);
  this.futures.push(future);
  return future;
};

/**
 * Adds a new future action to be executed on the application window.
 *
 * Note: Do not pass line manually. It happens automatically.
 *
 * @param {string} name Name of the future
 * @param {function()} behavior Behavior of the future
 * @param {function()} line fn() that returns file/line number
 */
angular.scenario.SpecRunner.prototype.addFutureAction = function(name, behavior, line) {
  var self = this;
  var NG = /\[ng\\\:/;
  return this.addFuture(name, function(done) {
    this.application.executeAction(function($window, $document) {

      //TODO(esprehn): Refactor this so it doesn&#x27;t need to be in here.
      $document.elements = function(selector) {
        var args = Array.prototype.slice.call(arguments, 1);
        selector = (self.selector || &#x27;&#x27;) + &#x27; &#x27; + (selector || &#x27;&#x27;);
        selector = _jQuery.trim(selector) || &#x27;*&#x27;;
        angular.forEach(args, function(value, index) {
          selector = selector.replace(&#x27;$&#x27; + (index + 1), value);
        });
        var result = $document.find(selector);
        if (selector.match(NG)) {
          angular.forEach([&#x27;[ng-&#x27;,&#x27;[data-ng-&#x27;,&#x27;[x-ng-&#x27;], function(value, index){
            result = result.add(selector.replace(NG, value), $document);
          });
        }
        if (!result.length) {
          throw {
            type: &#x27;selector&#x27;,
            message: &#x27;Selector &#x27; + selector + &#x27; did not match any elements.&#x27;
          };
        }

        return result;
      };

      try {
        behavior.call(self, $window, $document, done);
      } catch(e) {
        if (e.type &amp;&amp; e.type === &#x27;selector&#x27;) {
          done(e.message);
        } else {
          throw e;
        }
      }
    });
  }, line);
};

/**
 * Shared DSL statements that are useful to all scenarios.
 */

 /**
 * Usage:
 *    pause() pauses until you call resume() in the console
 */
angular.scenario.dsl(&#x27;pause&#x27;, function() {
  return function() {
    return this.addFuture(&#x27;pausing for you to resume&#x27;, function(done) {
      this.emit(&#x27;InteractivePause&#x27;, this.spec, this.step);
      this.$window.resume = function() { done(); };
    });
  };
});

/**
 * Usage:
 *    sleep(seconds) pauses the test for specified number of seconds
 */
angular.scenario.dsl(&#x27;sleep&#x27;, function() {
  return function(time) {
    return this.addFuture(&#x27;sleep for &#x27; + time + &#x27; seconds&#x27;, function(done) {
      this.$window.setTimeout(function() { done(null, time * 1000); }, time * 1000);
    });
  };
});

/**
 * Usage:
 *    browser().navigateTo(url) Loads the url into the frame
 *    browser().navigateTo(url, fn) where fn(url) is called and returns the URL to navigate to
 *    browser().reload() refresh the page (reload the same URL)
 *    browser().window.href() window.location.href
 *    browser().window.path() window.location.pathname
 *    browser().window.search() window.location.search
 *    browser().window.hash() window.location.hash without # prefix
 *    browser().location().url() see ng.$location#url
 *    browser().location().path() see ng.$location#path
 *    browser().location().search() see ng.$location#search
 *    browser().location().hash() see ng.$location#hash
 */
angular.scenario.dsl(&#x27;browser&#x27;, function() {
  var chain = {};

  chain.navigateTo = function(url, delegate) {
    var application = this.application;
    return this.addFuture(&quot;browser navigate to &#x27;&quot; + url + &quot;&#x27;&quot;, function(done) {
      if (delegate) {
        url = delegate.call(this, url);
      }
      application.navigateTo(url, function() {
        done(null, url);
      }, done);
    });
  };

  chain.reload = function() {
    var application = this.application;
    return this.addFutureAction(&#x27;browser reload&#x27;, function($window, $document, done) {
      var href = $window.location.href;
      application.navigateTo(href, function() {
        done(null, href);
      }, done);
    });
  };

  chain.window = function() {
    var api = {};

    api.href = function() {
      return this.addFutureAction(&#x27;window.location.href&#x27;, function($window, $document, done) {
        done(null, $window.location.href);
      });
    };

    api.path = function() {
      return this.addFutureAction(&#x27;window.location.path&#x27;, function($window, $document, done) {
        done(null, $window.location.pathname);
      });
    };

    api.search = function() {
      return this.addFutureAction(&#x27;window.location.search&#x27;, function($window, $document, done) {
        done(null, $window.location.search);
      });
    };

    api.hash = function() {
      return this.addFutureAction(&#x27;window.location.hash&#x27;, function($window, $document, done) {
        done(null, $window.location.hash.replace(&#x27;#&#x27;, &#x27;&#x27;));
      });
    };

    return api;
  };

  chain.location = function() {
    var api = {};

    api.url = function() {
      return this.addFutureAction(&#x27;$location.url()&#x27;, function($window, $document, done) {
        done(null, $document.injector().get(&#x27;$location&#x27;).url());
      });
    };

    api.path = function() {
      return this.addFutureAction(&#x27;$location.path()&#x27;, function($window, $document, done) {
        done(null, $document.injector().get(&#x27;$location&#x27;).path());
      });
    };

    api.search = function() {
      return this.addFutureAction(&#x27;$location.search()&#x27;, function($window, $document, done) {
        done(null, $document.injector().get(&#x27;$location&#x27;).search());
      });
    };

    api.hash = function() {
      return this.addFutureAction(&#x27;$location.hash()&#x27;, function($window, $document, done) {
        done(null, $document.injector().get(&#x27;$location&#x27;).hash());
      });
    };

    return api;
  };

  return function() {
    return chain;
  };
});

/**
 * Usage:
 *    expect(future).{matcher} where matcher is one of the matchers defined
 *    with angular.scenario.matcher
 *
 * ex. expect(binding(&quot;name&quot;)).toEqual(&quot;Elliott&quot;)
 */
angular.scenario.dsl(&#x27;expect&#x27;, function() {
  var chain = angular.extend({}, angular.scenario.matcher);

  chain.not = function() {
    this.inverse = true;
    return chain;
  };

  return function(future) {
    this.future = future;
    return chain;
  };
});

/**
 * Usage:
 *    using(selector, label) scopes the next DSL element selection
 *
 * ex.
 *   using(&#x27;#foo&#x27;, &quot;&#x27;Foo&#x27; text field&quot;).input(&#x27;bar&#x27;)
 */
angular.scenario.dsl(&#x27;using&#x27;, function() {
  return function(selector, label) {
    this.selector = _jQuery.trim((this.selector||&#x27;&#x27;) + &#x27; &#x27; + selector);
    if (angular.isString(label) &amp;&amp; label.length) {
      this.label = label + &#x27; ( &#x27; + this.selector + &#x27; )&#x27;;
    } else {
      this.label = this.selector;
    }
    return this.dsl;
  };
});

/**
 * Usage:
 *    binding(name) returns the value of the first matching binding
 */
angular.scenario.dsl(&#x27;binding&#x27;, function() {
  return function(name) {
    return this.addFutureAction(&quot;select binding &#x27;&quot; + name + &quot;&#x27;&quot;, function($window, $document, done) {
      var values = $document.elements().bindings($window.angular.element, name);
      if (!values.length) {
        return done(&quot;Binding selector &#x27;&quot; + name + &quot;&#x27; did not match.&quot;);
      }
      done(null, values[0]);
    });
  };
});

/**
 * Usage:
 *    input(name).enter(value) enters value in input with specified name
 *    input(name).check() checks checkbox
 *    input(name).select(value) selects the radio button with specified name/value
 *    input(name).val() returns the value of the input.
 */
angular.scenario.dsl(&#x27;input&#x27;, function() {
  var chain = {};
  var supportInputEvent =  &#x27;oninput&#x27; in document.createElement(&#x27;div&#x27;) &amp;&amp; msie != 9;

  chain.enter = function(value, event) {
    return this.addFutureAction(&quot;input &#x27;&quot; + this.name + &quot;&#x27; enter &#x27;&quot; + value + &quot;&#x27;&quot;, function($window, $document, done) {
      var input = $document.elements(&#x27;[ng\\:model=&quot;$1&quot;]&#x27;, this.name).filter(&#x27;:input&#x27;);
      input.val(value);
      input.trigger(event || (supportInputEvent ? &#x27;input&#x27; : &#x27;change&#x27;));
      done();
    });
  };

  chain.check = function() {
    return this.addFutureAction(&quot;checkbox &#x27;&quot; + this.name + &quot;&#x27; toggle&quot;, function($window, $document, done) {
      var input = $document.elements(&#x27;[ng\\:model=&quot;$1&quot;]&#x27;, this.name).filter(&#x27;:checkbox&#x27;);
      input.trigger(&#x27;click&#x27;);
      done();
    });
  };

  chain.select = function(value) {
    return this.addFutureAction(&quot;radio button &#x27;&quot; + this.name + &quot;&#x27; toggle &#x27;&quot; + value + &quot;&#x27;&quot;, function($window, $document, done) {
      var input = $document.
        elements(&#x27;[ng\\:model=&quot;$1&quot;][value=&quot;$2&quot;]&#x27;, this.name, value).filter(&#x27;:radio&#x27;);
      input.trigger(&#x27;click&#x27;);
      done();
    });
  };

  chain.val = function() {
    return this.addFutureAction(&quot;return input val&quot;, function($window, $document, done) {
      var input = $document.elements(&#x27;[ng\\:model=&quot;$1&quot;]&#x27;, this.name).filter(&#x27;:input&#x27;);
      done(null,input.val());
    });
  };

  return function(name) {
    this.name = name;
    return chain;
  };
});


/**
 * Usage:
 *    repeater(&#x27;#products table&#x27;, &#x27;Product List&#x27;).count() number of rows
 *    repeater(&#x27;#products table&#x27;, &#x27;Product List&#x27;).row(1) all bindings in row as an array
 *    repeater(&#x27;#products table&#x27;, &#x27;Product List&#x27;).column(&#x27;product.name&#x27;) all values across all rows in an array
 */
angular.scenario.dsl(&#x27;repeater&#x27;, function() {
  var chain = {};

  chain.count = function() {
    return this.addFutureAction(&quot;repeater &#x27;&quot; + this.label + &quot;&#x27; count&quot;, function($window, $document, done) {
      try {
        done(null, $document.elements().length);
      } catch (e) {
        done(null, 0);
      }
    });
  };

  chain.column = function(binding) {
    return this.addFutureAction(&quot;repeater &#x27;&quot; + this.label + &quot;&#x27; column &#x27;&quot; + binding + &quot;&#x27;&quot;, function($window, $document, done) {
      done(null, $document.elements().bindings($window.angular.element, binding));
    });
  };

  chain.row = function(index) {
    return this.addFutureAction(&quot;repeater &#x27;&quot; + this.label + &quot;&#x27; row &#x27;&quot; + index + &quot;&#x27;&quot;, function($window, $document, done) {
      var matches = $document.elements().slice(index, index + 1);
      if (!matches.length)
        return done(&#x27;row &#x27; + index + &#x27; out of bounds&#x27;);
      done(null, matches.bindings($window.angular.element));
    });
  };

  return function(selector, label) {
    this.dsl.using(selector, label);
    return chain;
  };
});

/**
 * Usage:
 *    select(name).option(&#x27;value&#x27;) select one option
 *    select(name).options(&#x27;value1&#x27;, &#x27;value2&#x27;, ...) select options from a multi select
 */
angular.scenario.dsl(&#x27;select&#x27;, function() {
  var chain = {};

  chain.option = function(value) {
    return this.addFutureAction(&quot;select &#x27;&quot; + this.name + &quot;&#x27; option &#x27;&quot; + value + &quot;&#x27;&quot;, function($window, $document, done) {
      var select = $document.elements(&#x27;select[ng\\:model=&quot;$1&quot;]&#x27;, this.name);
      var option = select.find(&#x27;option[value=&quot;&#x27; + value + &#x27;&quot;]&#x27;);
      if (option.length) {
        select.val(value);
      } else {
        option = select.find(&#x27;option:contains(&quot;&#x27; + value + &#x27;&quot;)&#x27;);
        if (option.length) {
          select.val(option.val());
        } else {
            return done(&quot;option &#x27;&quot; + value + &quot;&#x27; not found&quot;);
        }
      }
      select.trigger(&#x27;change&#x27;);
      done();
    });
  };

  chain.options = function() {
    var values = arguments;
    return this.addFutureAction(&quot;select &#x27;&quot; + this.name + &quot;&#x27; options &#x27;&quot; + values + &quot;&#x27;&quot;, function($window, $document, done) {
      var select = $document.elements(&#x27;select[multiple][ng\\:model=&quot;$1&quot;]&#x27;, this.name);
      select.val(values);
      select.trigger(&#x27;change&#x27;);
      done();
    });
  };

  return function(name) {
    this.name = name;
    return chain;
  };
});

/**
 * Usage:
 *    element(selector, label).count() get the number of elements that match selector
 *    element(selector, label).click() clicks an element
 *    element(selector, label).mouseover() mouseover an element
 *    element(selector, label).mousedown() mousedown an element
 *    element(selector, label).mouseup() mouseup an element
 *    element(selector, label).query(fn) executes fn(selectedElements, done)
 *    element(selector, label).{method}() gets the value (as defined by jQuery, ex. val)
 *    element(selector, label).{method}(value) sets the value (as defined by jQuery, ex. val)
 *    element(selector, label).{method}(key) gets the value (as defined by jQuery, ex. attr)
 *    element(selector, label).{method}(key, value) sets the value (as defined by jQuery, ex. attr)
 */
angular.scenario.dsl(&#x27;element&#x27;, function() {
  var KEY_VALUE_METHODS = [&#x27;attr&#x27;, &#x27;css&#x27;, &#x27;prop&#x27;];
  var VALUE_METHODS = [
    &#x27;val&#x27;, &#x27;text&#x27;, &#x27;html&#x27;, &#x27;height&#x27;, &#x27;innerHeight&#x27;, &#x27;outerHeight&#x27;, &#x27;width&#x27;,
    &#x27;innerWidth&#x27;, &#x27;outerWidth&#x27;, &#x27;position&#x27;, &#x27;scrollLeft&#x27;, &#x27;scrollTop&#x27;, &#x27;offset&#x27;
  ];
  var chain = {};

  chain.count = function() {
    return this.addFutureAction(&quot;element &#x27;&quot; + this.label + &quot;&#x27; count&quot;, function($window, $document, done) {
      try {
        done(null, $document.elements().length);
      } catch (e) {
        done(null, 0);
      }
    });
  };

  chain.click = function() {
    return this.addFutureAction(&quot;element &#x27;&quot; + this.label + &quot;&#x27; click&quot;, function($window, $document, done) {
      var elements = $document.elements();
      var href = elements.attr(&#x27;href&#x27;);
      var eventProcessDefault = elements.trigger(&#x27;click&#x27;)[0];

      if (href &amp;&amp; elements[0].nodeName.toUpperCase() === &#x27;A&#x27; &amp;&amp; eventProcessDefault) {
        this.application.navigateTo(href, function() {
          done();
        }, done);
      } else {
        done();
      }
    });
  };

  chain.dblclick = function() {
    return this.addFutureAction(&quot;element &#x27;&quot; + this.label + &quot;&#x27; dblclick&quot;, function($window, $document, done) {
      var elements = $document.elements();
      var href = elements.attr(&#x27;href&#x27;);
      var eventProcessDefault = elements.trigger(&#x27;dblclick&#x27;)[0];

      if (href &amp;&amp; elements[0].nodeName.toUpperCase() === &#x27;A&#x27; &amp;&amp; eventProcessDefault) {
        this.application.navigateTo(href, function() {
          done();
        }, done);
      } else {
        done();
      }
    });
  };

  chain.mouseover = function() {
    return this.addFutureAction(&quot;element &#x27;&quot; + this.label + &quot;&#x27; mouseover&quot;, function($window, $document, done) {
      var elements = $document.elements();
      elements.trigger(&#x27;mouseover&#x27;);
      done();
    });
  };

  chain.mousedown = function() {
      return this.addFutureAction(&quot;element &#x27;&quot; + this.label + &quot;&#x27; mousedown&quot;, function($window, $document, done) {
        var elements = $document.elements();
        elements.trigger(&#x27;mousedown&#x27;);
        done();
      });
    };

  chain.mouseup = function() {
      return this.addFutureAction(&quot;element &#x27;&quot; + this.label + &quot;&#x27; mouseup&quot;, function($window, $document, done) {
        var elements = $document.elements();
        elements.trigger(&#x27;mouseup&#x27;);
        done();
      });
    };

  chain.query = function(fn) {
    return this.addFutureAction(&#x27;element &#x27; + this.label + &#x27; custom query&#x27;, function($window, $document, done) {
      fn.call(this, $document.elements(), done);
    });
  };

  angular.forEach(KEY_VALUE_METHODS, function(methodName) {
    chain[methodName] = function(name, value) {
      var args = arguments,
          futureName = (args.length == 1)
              ? &quot;element &#x27;&quot; + this.label + &quot;&#x27; get &quot; + methodName + &quot; &#x27;&quot; + name + &quot;&#x27;&quot;
              : &quot;element &#x27;&quot; + this.label + &quot;&#x27; set &quot; + methodName + &quot; &#x27;&quot; + name + &quot;&#x27; to &quot; + &quot;&#x27;&quot; + value + &quot;&#x27;&quot;;

      return this.addFutureAction(futureName, function($window, $document, done) {
        var element = $document.elements();
        done(null, element[methodName].apply(element, args));
      });
    };
  });

  angular.forEach(VALUE_METHODS, function(methodName) {
    chain[methodName] = function(value) {
      var args = arguments,
          futureName = (args.length == 0)
              ? &quot;element &#x27;&quot; + this.label + &quot;&#x27; &quot; + methodName
              : futureName = &quot;element &#x27;&quot; + this.label + &quot;&#x27; set &quot; + methodName + &quot; to &#x27;&quot; + value + &quot;&#x27;&quot;;

      return this.addFutureAction(futureName, function($window, $document, done) {
        var element = $document.elements();
        done(null, element[methodName].apply(element, args));
      });
    };
  });

  return function(selector, label) {
    this.dsl.using(selector, label);
    return chain;
  };
});

/**
 * Matchers for implementing specs. Follows the Jasmine spec conventions.
 */

angular.scenario.matcher(&#x27;toEqual&#x27;, function(expected) {
  return angular.equals(this.actual, expected);
});

angular.scenario.matcher(&#x27;toBe&#x27;, function(expected) {
  return this.actual === expected;
});

angular.scenario.matcher(&#x27;toBeDefined&#x27;, function() {
  return angular.isDefined(this.actual);
});

angular.scenario.matcher(&#x27;toBeTruthy&#x27;, function() {
  return this.actual;
});

angular.scenario.matcher(&#x27;toBeFalsy&#x27;, function() {
  return !this.actual;
});

angular.scenario.matcher(&#x27;toMatch&#x27;, function(expected) {
  return new RegExp(expected).test(this.actual);
});

angular.scenario.matcher(&#x27;toBeNull&#x27;, function() {
  return this.actual === null;
});

angular.scenario.matcher(&#x27;toContain&#x27;, function(expected) {
  return includes(this.actual, expected);
});

angular.scenario.matcher(&#x27;toBeLessThan&#x27;, function(expected) {
  return this.actual &lt; expected;
});

angular.scenario.matcher(&#x27;toBeGreaterThan&#x27;, function(expected) {
  return this.actual &gt; expected;
});

/**
 * User Interface for the Scenario Runner.
 *
 * TODO(esprehn): This should be refactored now that ObjectModel exists
 *  to use angular bindings for the UI.
 */
angular.scenario.output(&#x27;html&#x27;, function(context, runner, model) {
  var specUiMap = {},
      lastStepUiMap = {};

  context.append(
    &#x27;&lt;div id=&quot;header&quot;&gt;&#x27; +
    &#x27;  &lt;h1&gt;&lt;span class=&quot;angular&quot;&gt;AngularJS&lt;/span&gt;: Scenario Test Runner&lt;/h1&gt;&#x27; +
    &#x27;  &lt;ul id=&quot;status-legend&quot; class=&quot;status-display&quot;&gt;&#x27; +
    &#x27;    &lt;li class=&quot;status-error&quot;&gt;0 Errors&lt;/li&gt;&#x27; +
    &#x27;    &lt;li class=&quot;status-failure&quot;&gt;0 Failures&lt;/li&gt;&#x27; +
    &#x27;    &lt;li class=&quot;status-success&quot;&gt;0 Passed&lt;/li&gt;&#x27; +
    &#x27;  &lt;/ul&gt;&#x27; +
    &#x27;&lt;/div&gt;&#x27; +
    &#x27;&lt;div id=&quot;specs&quot;&gt;&#x27; +
    &#x27;  &lt;div class=&quot;test-children&quot;&gt;&lt;/div&gt;&#x27; +
    &#x27;&lt;/div&gt;&#x27;
  );

  runner.on(&#x27;InteractivePause&#x27;, function(spec) {
    var ui = lastStepUiMap[spec.id];
    ui.find(&#x27;.test-title&#x27;).
      html(&#x27;paused... &lt;a href=&quot;javascript:resume()&quot;&gt;resume&lt;/a&gt; when ready.&#x27;);
  });

  runner.on(&#x27;SpecBegin&#x27;, function(spec) {
    var ui = findContext(spec);
    ui.find(&#x27;&gt; .tests&#x27;).append(
      &#x27;&lt;li class=&quot;status-pending test-it&quot;&gt;&lt;/li&gt;&#x27;
    );
    ui = ui.find(&#x27;&gt; .tests li:last&#x27;);
    ui.append(
      &#x27;&lt;div class=&quot;test-info&quot;&gt;&#x27; +
      &#x27;  &lt;p class=&quot;test-title&quot;&gt;&#x27; +
      &#x27;    &lt;span class=&quot;timer-result&quot;&gt;&lt;/span&gt;&#x27; +
      &#x27;    &lt;span class=&quot;test-name&quot;&gt;&lt;/span&gt;&#x27; +
      &#x27;  &lt;/p&gt;&#x27; +
      &#x27;&lt;/div&gt;&#x27; +
      &#x27;&lt;div class=&quot;scrollpane&quot;&gt;&#x27; +
      &#x27;  &lt;ol class=&quot;test-actions&quot;&gt;&lt;/ol&gt;&#x27; +
      &#x27;&lt;/div&gt;&#x27;
    );
    ui.find(&#x27;&gt; .test-info .test-name&#x27;).text(spec.name);
    ui.find(&#x27;&gt; .test-info&#x27;).click(function() {
      var scrollpane = ui.find(&#x27;&gt; .scrollpane&#x27;);
      var actions = scrollpane.find(&#x27;&gt; .test-actions&#x27;);
      var name = context.find(&#x27;&gt; .test-info .test-name&#x27;);
      if (actions.find(&#x27;:visible&#x27;).length) {
        actions.hide();
        name.removeClass(&#x27;open&#x27;).addClass(&#x27;closed&#x27;);
      } else {
        actions.show();
        scrollpane.attr(&#x27;scrollTop&#x27;, scrollpane.attr(&#x27;scrollHeight&#x27;));
        name.removeClass(&#x27;closed&#x27;).addClass(&#x27;open&#x27;);
      }
    });

    specUiMap[spec.id] = ui;
  });

  runner.on(&#x27;SpecError&#x27;, function(spec, error) {
    var ui = specUiMap[spec.id];
    ui.append(&#x27;&lt;pre&gt;&lt;/pre&gt;&#x27;);
    ui.find(&#x27;&gt; pre&#x27;).text(formatException(error));
  });

  runner.on(&#x27;SpecEnd&#x27;, function(spec) {
    var ui = specUiMap[spec.id];
    spec = model.getSpec(spec.id);
    ui.removeClass(&#x27;status-pending&#x27;);
    ui.addClass(&#x27;status-&#x27; + spec.status);
    ui.find(&quot;&gt; .test-info .timer-result&quot;).text(spec.duration + &quot;ms&quot;);
    if (spec.status === &#x27;success&#x27;) {
      ui.find(&#x27;&gt; .test-info .test-name&#x27;).addClass(&#x27;closed&#x27;);
      ui.find(&#x27;&gt; .scrollpane .test-actions&#x27;).hide();
    }
    updateTotals(spec.status);
  });

  runner.on(&#x27;StepBegin&#x27;, function(spec, step) {
    var ui = specUiMap[spec.id];
    spec = model.getSpec(spec.id);
    step = spec.getLastStep();
    ui.find(&#x27;&gt; .scrollpane .test-actions&#x27;).append(&#x27;&lt;li class=&quot;status-pending&quot;&gt;&lt;/li&gt;&#x27;);
    var stepUi = lastStepUiMap[spec.id] = ui.find(&#x27;&gt; .scrollpane .test-actions li:last&#x27;);
    stepUi.append(
      &#x27;&lt;div class=&quot;timer-result&quot;&gt;&lt;/div&gt;&#x27; +
      &#x27;&lt;div class=&quot;test-title&quot;&gt;&lt;/div&gt;&#x27;
    );
    stepUi.find(&#x27;&gt; .test-title&#x27;).text(step.name);
    var scrollpane = stepUi.parents(&#x27;.scrollpane&#x27;);
    scrollpane.attr(&#x27;scrollTop&#x27;, scrollpane.attr(&#x27;scrollHeight&#x27;));
  });

  runner.on(&#x27;StepFailure&#x27;, function(spec, step, error) {
    var ui = lastStepUiMap[spec.id];
    addError(ui, step.line, error);
  });

  runner.on(&#x27;StepError&#x27;, function(spec, step, error) {
    var ui = lastStepUiMap[spec.id];
    addError(ui, step.line, error);
  });

  runner.on(&#x27;StepEnd&#x27;, function(spec, step) {
    var stepUi = lastStepUiMap[spec.id];
    spec = model.getSpec(spec.id);
    step = spec.getLastStep();
    stepUi.find(&#x27;.timer-result&#x27;).text(step.duration + &#x27;ms&#x27;);
    stepUi.removeClass(&#x27;status-pending&#x27;);
    stepUi.addClass(&#x27;status-&#x27; + step.status);
    var scrollpane = specUiMap[spec.id].find(&#x27;&gt; .scrollpane&#x27;);
    scrollpane.attr(&#x27;scrollTop&#x27;, scrollpane.attr(&#x27;scrollHeight&#x27;));
  });

  /**
   * Finds the context of a spec block defined by the passed definition.
   *
   * @param {Object} The definition created by the Describe object.
   */
  function findContext(spec) {
    var currentContext = context.find(&#x27;#specs&#x27;);
    angular.forEach(model.getDefinitionPath(spec), function(defn) {
      var id = &#x27;describe-&#x27; + defn.id;
      if (!context.find(&#x27;#&#x27; + id).length) {
        currentContext.find(&#x27;&gt; .test-children&#x27;).append(
          &#x27;&lt;div class=&quot;test-describe&quot; id=&quot;&#x27; + id + &#x27;&quot;&gt;&#x27; +
          &#x27;  &lt;h2&gt;&lt;/h2&gt;&#x27; +
          &#x27;  &lt;div class=&quot;test-children&quot;&gt;&lt;/div&gt;&#x27; +
          &#x27;  &lt;ul class=&quot;tests&quot;&gt;&lt;/ul&gt;&#x27; +
          &#x27;&lt;/div&gt;&#x27;
        );
        context.find(&#x27;#&#x27; + id).find(&#x27;&gt; h2&#x27;).text(&#x27;describe: &#x27; + defn.name);
      }
      currentContext = context.find(&#x27;#&#x27; + id);
    });
    return context.find(&#x27;#describe-&#x27; + spec.definition.id);
  }

  /**
   * Updates the test counter for the status.
   *
   * @param {string} the status.
   */
  function updateTotals(status) {
    var legend = context.find(&#x27;#status-legend .status-&#x27; + status);
    var parts = legend.text().split(&#x27; &#x27;);
    var value = (parts[0] * 1) + 1;
    legend.text(value + &#x27; &#x27; + parts[1]);
  }

  /**
   * Add an error to a step.
   *
   * @param {Object} The JQuery wrapped context
   * @param {function()} fn() that should return the file/line number of the error
   * @param {Object} the error.
   */
  function addError(context, line, error) {
    context.find(&#x27;.test-title&#x27;).append(&#x27;&lt;pre&gt;&lt;/pre&gt;&#x27;);
    var message = _jQuery.trim(line() + &#x27;\n\n&#x27; + formatException(error));
    context.find(&#x27;.test-title pre:last&#x27;).text(message);
  }
});

/**
 * Generates JSON output into a context.
 */
angular.scenario.output(&#x27;json&#x27;, function(context, runner, model) {
  model.on(&#x27;RunnerEnd&#x27;, function() {
    context.text(angular.toJson(model.value));
  });
});

/**
 * Generates XML output into a context.
 */
angular.scenario.output(&#x27;xml&#x27;, function(context, runner, model) {
  var $ = function(args) {return new context.init(args);};
  model.on(&#x27;RunnerEnd&#x27;, function() {
    var scenario = $(&#x27;&lt;scenario&gt;&lt;/scenario&gt;&#x27;);
    context.append(scenario);
    serializeXml(scenario, model.value);
  });

  /**
   * Convert the tree into XML.
   *
   * @param {Object} context jQuery context to add the XML to.
   * @param {Object} tree node to serialize
   */
  function serializeXml(context, tree) {
     angular.forEach(tree.children, function(child) {
       var describeContext = $(&#x27;&lt;describe&gt;&lt;/describe&gt;&#x27;);
       describeContext.attr(&#x27;id&#x27;, child.id);
       describeContext.attr(&#x27;name&#x27;, child.name);
       context.append(describeContext);
       serializeXml(describeContext, child);
     });
     var its = $(&#x27;&lt;its&gt;&lt;/its&gt;&#x27;);
     context.append(its);
     angular.forEach(tree.specs, function(spec) {
       var it = $(&#x27;&lt;it&gt;&lt;/it&gt;&#x27;);
       it.attr(&#x27;id&#x27;, spec.id);
       it.attr(&#x27;name&#x27;, spec.name);
       it.attr(&#x27;duration&#x27;, spec.duration);
       it.attr(&#x27;status&#x27;, spec.status);
       its.append(it);
       angular.forEach(spec.steps, function(step) {
         var stepContext = $(&#x27;&lt;step&gt;&lt;/step&gt;&#x27;);
         stepContext.attr(&#x27;name&#x27;, step.name);
         stepContext.attr(&#x27;duration&#x27;, step.duration);
         stepContext.attr(&#x27;status&#x27;, step.status);
         it.append(stepContext);
         if (step.error) {
           var error = $(&#x27;&lt;error&gt;&lt;/error&gt;&#x27;);
           stepContext.append(error);
           error.text(formatException(step.error));
         }
       });
     });
   }
});

/**
 * Creates a global value $result with the result of the runner.
 */
angular.scenario.output(&#x27;object&#x27;, function(context, runner, model) {
  runner.$window.$result = model.value;
});

bindJQuery();
publishExternalAPI(angular);

var $runner = new angular.scenario.Runner(window),
    scripts = document.getElementsByTagName(&#x27;script&#x27;),
    script = scripts[scripts.length - 1],
    config = {};

angular.forEach(script.attributes, function(attr) {
  var match = attr.name.match(/ng[:\-](.*)/);
  if (match) {
    config[match[1]] = attr.value || true;
  }
});

if (config.autotest) {
  JQLite(document).ready(function() {
    angular.scenario.setUpAndRun(config);
  });
}
})(window, document);

angular.element(document).find(&#x27;head&#x27;).append(&#x27;&lt;style type=&quot;text/css&quot;&gt;@charset &quot;UTF-8&quot;;\n\n[ng\\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak],\n.ng-cloak, .x-ng-cloak {\n  display: none;\n}\n\nng\\:form {\n  display: block;\n}\n&lt;/style&gt;&#x27;);
angular.element(document).find(&#x27;head&#x27;).append(&#x27;&lt;style type=&quot;text/css&quot;&gt;@charset &quot;UTF-8&quot;;\n/* CSS Document */\n\n/** Structure */\nbody {\n  font-family: Arial, sans-serif;\n  margin: 0;\n  font-size: 14px;\n}\n\n#system-error {\n  font-size: 1.5em;\n  text-align: center;\n}\n\n#json, #xml {\n  display: none;\n}\n\n#header {\n  position: fixed;\n  width: 100%;\n}\n\n#specs {\n  padding-top: 50px;\n}\n\n#header .angular {\n  font-family: Courier New, monospace;\n  font-weight: bold;\n}\n\n#header h1 {\n  font-weight: normal;\n  float: left;\n  font-size: 30px;\n  line-height: 30px;\n  margin: 0;\n  padding: 10px 10px;\n  height: 30px;\n}\n\n#application h2,\n#specs h2 {\n  margin: 0;\n  padding: 0.5em;\n  font-size: 1.1em;\n}\n\n#status-legend {\n  margin-top: 10px;\n  margin-right: 10px;\n}\n\n#header,\n#application,\n.test-info,\n.test-actions li {\n  overflow: hidden;\n}\n\n#application {\n  margin: 10px;\n}\n\n#application iframe {\n  width: 100%;\n  height: 758px;\n}\n\n#application .popout {\n  float: right;\n}\n\n#application iframe {\n  border: none;\n}\n\n.tests li,\n.test-actions li,\n.test-it li,\n.test-it ol,\n.status-display {\n  list-style-type: none;\n}\n\n.tests,\n.test-it ol,\n.status-display {\n  margin: 0;\n  padding: 0;\n}\n\n.test-info {\n  margin-left: 1em;\n  margin-top: 0.5em;\n  border-radius: 8px 0 0 8px;\n  -webkit-border-radius: 8px 0 0 8px;\n  -moz-border-radius: 8px 0 0 8px;\n  cursor: pointer;\n}\n\n.test-info:hover .test-name {\n  text-decoration: underline;\n}\n\n.test-info .closed:before {\n  content: \&#x27;\\25b8\\00A0\&#x27;;\n}\n\n.test-info .open:before {\n  content: \&#x27;\\25be\\00A0\&#x27;;\n  font-weight: bold;\n}\n\n.test-it ol {\n  margin-left: 2.5em;\n}\n\n.status-display,\n.status-display li {\n  float: right;\n}\n\n.status-display li {\n  padding: 5px 10px;\n}\n\n.timer-result,\n.test-title {\n  display: inline-block;\n  margin: 0;\n  padding: 4px;\n}\n\n.test-actions .test-title,\n.test-actions .test-result {\n  display: table-cell;\n  padding-left: 0.5em;\n  padding-right: 0.5em;\n}\n\n.test-actions {\n  display: table;\n}\n\n.test-actions li {\n  display: table-row;\n}\n\n.timer-result {\n  width: 4em;\n  padding: 0 10px;\n  text-align: right;\n  font-family: monospace;\n}\n\n.test-it pre,\n.test-actions pre {\n  clear: left;\n  color: black;\n  margin-left: 6em;\n}\n\n.test-describe {\n  padding-bottom: 0.5em;\n}\n\n.test-describe .test-describe {\n  margin: 5px 5px 10px 2em;\n}\n\n.test-actions .status-pending .test-title:before {\n  content: \&#x27;\\00bb\\00A0\&#x27;;\n}\n\n.scrollpane {\n   max-height: 20em;\n   overflow: auto;\n}\n\n/** Colors */\n\n#header {\n  background-color: #F2C200;\n}\n\n#specs h2 {\n  border-top: 2px solid #BABAD1;\n}\n\n#specs h2,\n#application h2 {\n  background-color: #efefef;\n}\n\n#application {\n  border: 1px solid #BABAD1;\n}\n\n.test-describe .test-describe {\n  border-left: 1px solid #BABAD1;\n  border-right: 1px solid #BABAD1;\n  border-bottom: 1px solid #BABAD1;\n}\n\n.status-display {\n  border: 1px solid #777;\n}\n\n.status-display .status-pending,\n.status-pending .test-info {\n  background-color: #F9EEBC;\n}\n\n.status-display .status-success,\n.status-success .test-info {\n  background-color: #B1D7A1;\n}\n\n.status-display .status-failure,\n.status-failure .test-info {\n  background-color: #FF8286;\n}\n\n.status-display .status-error,\n.status-error .test-info {\n  background-color: black;\n  color: white;\n}\n\n.test-actions .status-success .test-title {\n  color: #30B30A;\n}\n\n.test-actions .status-failure .test-title {\n  color: #DF0000;\n}\n\n.test-actions .status-error .test-title {\n  color: black;\n}\n\n.test-actions .timer-result {\n  color: #888;\n}\n&lt;/style&gt;&#x27;);
    </pre>
</div>

                </div>
            </div>
        </div>
    </div>
<a id="gotoTop" class='well well-small' href='#'>
    Top
</a>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.min.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/config.js"></script>
<script src="../assets/js/doc.js"></script>
</body>
</html>
