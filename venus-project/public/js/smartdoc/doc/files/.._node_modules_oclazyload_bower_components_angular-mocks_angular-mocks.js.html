<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>..\node_modules\oclazyload\bower_components\angular-mocks\angular-mocks.js - SmartDoc</title>
  
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.min.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-smart">
 <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container-fluid">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
               <a class="navbar-brand mainlogo" href="https://github.com/zhh77/smartdoc">
             
            <img alt="SmartDoc" src="../assets/css/logo.png" title="SmartDoc">
            
                SmartDoc
          </a>
            </div>
            <div id="navbar" class="navbar-collapse collapse">
                 <ul class="nav navbar-nav">
                    
                    <li><a href="https://github.com/zhh77/smartdoc">Home</a>
                    </li>
                    
                    <li><a href="/">Document</a>
                    </li>
                    
                    <li><a href="https://github.com/zhh77/smartdoc">About</a>
                    </li>
                    
                </ul>
               <div class="navbar-form navbar-right filterAPi" autocomplete="off">
                <input type="text" id='txtSearchAPI' class="form-control search-query" placeholder="Search for API" />
                 <ul id="filterList" class="filterItems dropdown-menu" role="menu"></ul>
                </div>
            </div>
        </div>
    </nav>
    <div id="sidebar">
    <h3>Modules/Classes</h3>
        <div id="api-tabview-filter">
            <input id='txtSearch' type="search" class="form-control" placeholder="Type to filter Modules/Classes">
        </div>
        <dl id="sidebar_list">
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/273.html">273</a>
                </dt>
                <dd>
                    <ul>
                   
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/alienjs.html">alienjs</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/window.require.html">window.require</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/Countdown.html">Countdown</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/Date.html">Date</a>
                </dt>
                <dd>
                    <ul>
                   
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/jquery.html">jquery</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/jquery.transitionEnd.html">jquery.transitionEnd</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.support.transition.html">jquery.support.transition</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.animationEnd.html">jquery.animationEnd</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/jquery-ui.html">jquery-ui</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/jquery.ajaxPanel.html">jquery.ajaxPanel</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.dialog.html">jquery.dialog</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/Array.html">Array</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.browserLowVersion.html">jquery.browserLowVersion</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.confirm.html">jquery.confirm</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.alert.html">jquery.alert</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/ng.html">ng</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/EventEmitter Manages event registering and emitting..html">EventEmitter Manages event registering and emitting.</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/ngMock.html">ngMock</a>
                </dt>
                <dd>
                    <ul>
                   
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/ngMockE2E.html">ngMockE2E</a>
                </dt>
                <dd>
                    <ul>
                   
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/ui.html">ui</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/AjaxPanel.html">AjaxPanel</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/Date.Dialog.html">Date.Dialog</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/WebUploader.html">WebUploader</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/Base.html">Base</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/Mediator.html">Mediator</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/options.Uploader.html">options.Uploader</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/File.File.html">File.File</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/File.Queue.html">File.Queue</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/Uploader.html">Uploader</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/window.html">window</a>
                </dt>
                <dd>
                    <ul>
                   
                    </ul>
                </dd>
             
        </dl>
</div>
   
    <div class="stdoc-content">
        <!--     <form id="options-form" class="form-inline pull-right">
        Show:
        <label for="api-show-inherited" class="checkbox">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected" class="checkbox">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private" class="checkbox">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated" class="checkbox">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </form>

 -->
        <div class="apidocs">
            <div id="docs-main">
                <div class="content">
                    <div class="page-header">
    <h1>..\node_modules\oclazyload\bower_components\angular-mocks\angular-mocks.js <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums" id='src_code'>
/**
 * @license AngularJS v1.3.14
 * (c) 2010-2014 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular, undefined) {

&#x27;use strict&#x27;;

/**
 * @ngdoc object
 * @name angular.mock
 * @description
 *
 * Namespace from &#x27;angular-mocks.js&#x27; which contains testing related code.
 */
angular.mock = {};

/**
 * ! This is a private undocumented service !
 *
 * @name $browser
 *
 * @description
 * This service is a mock implementation of {@link ng.$browser}. It provides fake
 * implementation for commonly used browser apis that are hard to test, e.g. setTimeout, xhr,
 * cookies, etc...
 *
 * The api of this service is the same as that of the real {@link ng.$browser $browser}, except
 * that there are several helper methods available which can be used in tests.
 */
angular.mock.$BrowserProvider = function() {
  this.$get = function() {
    return new angular.mock.$Browser();
  };
};

angular.mock.$Browser = function() {
  var self = this;

  this.isMock = true;
  self.$$url = &quot;http://server/&quot;;
  self.$$lastUrl = self.$$url; // used by url polling fn
  self.pollFns = [];

  // TODO(vojta): remove this temporary api
  self.$$completeOutstandingRequest = angular.noop;
  self.$$incOutstandingRequestCount = angular.noop;


  // register url polling fn

  self.onUrlChange = function(listener) {
    self.pollFns.push(
      function() {
        if (self.$$lastUrl !== self.$$url || self.$$state !== self.$$lastState) {
          self.$$lastUrl = self.$$url;
          self.$$lastState = self.$$state;
          listener(self.$$url, self.$$state);
        }
      }
    );

    return listener;
  };

  self.$$checkUrlChange = angular.noop;

  self.cookieHash = {};
  self.lastCookieHash = {};
  self.deferredFns = [];
  self.deferredNextId = 0;

  self.defer = function(fn, delay) {
    delay = delay || 0;
    self.deferredFns.push({time:(self.defer.now + delay), fn:fn, id: self.deferredNextId});
    self.deferredFns.sort(function(a, b) { return a.time - b.time;});
    return self.deferredNextId++;
  };


  /**
   * @name $browser#defer.now
   *
   * @description
   * Current milliseconds mock time.
   */
  self.defer.now = 0;


  self.defer.cancel = function(deferId) {
    var fnIndex;

    angular.forEach(self.deferredFns, function(fn, index) {
      if (fn.id === deferId) fnIndex = index;
    });

    if (fnIndex !== undefined) {
      self.deferredFns.splice(fnIndex, 1);
      return true;
    }

    return false;
  };


  /**
   * @name $browser#defer.flush
   *
   * @description
   * Flushes all pending requests and executes the defer callbacks.
   *
   * @param {number=} number of milliseconds to flush. See {@link #defer.now}
   */
  self.defer.flush = function(delay) {
    if (angular.isDefined(delay)) {
      self.defer.now += delay;
    } else {
      if (self.deferredFns.length) {
        self.defer.now = self.deferredFns[self.deferredFns.length - 1].time;
      } else {
        throw new Error(&#x27;No deferred tasks to be flushed&#x27;);
      }
    }

    while (self.deferredFns.length &amp;&amp; self.deferredFns[0].time &lt;= self.defer.now) {
      self.deferredFns.shift().fn();
    }
  };

  self.$$baseHref = &#x27;/&#x27;;
  self.baseHref = function() {
    return this.$$baseHref;
  };
};
angular.mock.$Browser.prototype = {

/**
  * @name $browser#poll
  *
  * @description
  * run all fns in pollFns
  */
  poll: function poll() {
    angular.forEach(this.pollFns, function(pollFn) {
      pollFn();
    });
  },

  addPollFn: function(pollFn) {
    this.pollFns.push(pollFn);
    return pollFn;
  },

  url: function(url, replace, state) {
    if (angular.isUndefined(state)) {
      state = null;
    }
    if (url) {
      this.$$url = url;
      // Native pushState serializes &amp; copies the object; simulate it.
      this.$$state = angular.copy(state);
      return this;
    }

    return this.$$url;
  },

  state: function() {
    return this.$$state;
  },

  cookies:  function(name, value) {
    if (name) {
      if (angular.isUndefined(value)) {
        delete this.cookieHash[name];
      } else {
        if (angular.isString(value) &amp;&amp;       //strings only
            value.length &lt;= 4096) {          //strict cookie storage limits
          this.cookieHash[name] = value;
        }
      }
    } else {
      if (!angular.equals(this.cookieHash, this.lastCookieHash)) {
        this.lastCookieHash = angular.copy(this.cookieHash);
        this.cookieHash = angular.copy(this.cookieHash);
      }
      return this.cookieHash;
    }
  },

  notifyWhenNoOutstandingRequests: function(fn) {
    fn();
  }
};


/**
 * @ngdoc provider
 * @name $exceptionHandlerProvider
 *
 * @description
 * Configures the mock implementation of {@link ng.$exceptionHandler} to rethrow or to log errors
 * passed to the &#x60;$exceptionHandler&#x60;.
 */

/**
 * @ngdoc service
 * @name $exceptionHandler
 *
 * @description
 * Mock implementation of {@link ng.$exceptionHandler} that rethrows or logs errors passed
 * to it. See {@link ngMock.$exceptionHandlerProvider $exceptionHandlerProvider} for configuration
 * information.
 *
 *
 * &#x60;&#x60;&#x60;js
 *   describe(&#x27;$exceptionHandlerProvider&#x27;, function() {
 *
 *     it(&#x27;should capture log messages and exceptions&#x27;, function() {
 *
 *       module(function($exceptionHandlerProvider) {
 *         $exceptionHandlerProvider.mode(&#x27;log&#x27;);
 *       });
 *
 *       inject(function($log, $exceptionHandler, $timeout) {
 *         $timeout(function() { $log.log(1); });
 *         $timeout(function() { $log.log(2); throw &#x27;banana peel&#x27;; });
 *         $timeout(function() { $log.log(3); });
 *         expect($exceptionHandler.errors).toEqual([]);
 *         expect($log.assertEmpty());
 *         $timeout.flush();
 *         expect($exceptionHandler.errors).toEqual([&#x27;banana peel&#x27;]);
 *         expect($log.log.logs).toEqual([[1], [2], [3]]);
 *       });
 *     });
 *   });
 * &#x60;&#x60;&#x60;
 */

angular.mock.$ExceptionHandlerProvider = function() {
  var handler;

  /**
   * @ngdoc method
   * @name $exceptionHandlerProvider#mode
   *
   * @description
   * Sets the logging mode.
   *
   * @param {string} mode Mode of operation, defaults to &#x60;rethrow&#x60;.
   *
   *   - &#x60;log&#x60;: Sometimes it is desirable to test that an error is thrown, for this case the &#x60;log&#x60;
   *            mode stores an array of errors in &#x60;$exceptionHandler.errors&#x60;, to allow later
   *            assertion of them. See {@link ngMock.$log#assertEmpty assertEmpty()} and
   *            {@link ngMock.$log#reset reset()}
   *   - &#x60;rethrow&#x60;: If any errors are passed to the handler in tests, it typically means that there
   *                is a bug in the application or test, so this mock will make these tests fail.
   *                For any implementations that expect exceptions to be thrown, the &#x60;rethrow&#x60; mode
   *                will also maintain a log of thrown errors.
   */
  this.mode = function(mode) {

    switch (mode) {
      case &#x27;log&#x27;:
      case &#x27;rethrow&#x27;:
        var errors = [];
        handler = function(e) {
          if (arguments.length == 1) {
            errors.push(e);
          } else {
            errors.push([].slice.call(arguments, 0));
          }
          if (mode === &quot;rethrow&quot;) {
            throw e;
          }
        };
        handler.errors = errors;
        break;
      default:
        throw new Error(&quot;Unknown mode &#x27;&quot; + mode + &quot;&#x27;, only &#x27;log&#x27;/&#x27;rethrow&#x27; modes are allowed!&quot;);
    }
  };

  this.$get = function() {
    return handler;
  };

  this.mode(&#x27;rethrow&#x27;);
};


/**
 * @ngdoc service
 * @name $log
 *
 * @description
 * Mock implementation of {@link ng.$log} that gathers all logged messages in arrays
 * (one array per logging level). These arrays are exposed as &#x60;logs&#x60; property of each of the
 * level-specific log function, e.g. for level &#x60;error&#x60; the array is exposed as &#x60;$log.error.logs&#x60;.
 *
 */
angular.mock.$LogProvider = function() {
  var debug = true;

  function concat(array1, array2, index) {
    return array1.concat(Array.prototype.slice.call(array2, index));
  }

  this.debugEnabled = function(flag) {
    if (angular.isDefined(flag)) {
      debug = flag;
      return this;
    } else {
      return debug;
    }
  };

  this.$get = function() {
    var $log = {
      log: function() { $log.log.logs.push(concat([], arguments, 0)); },
      warn: function() { $log.warn.logs.push(concat([], arguments, 0)); },
      info: function() { $log.info.logs.push(concat([], arguments, 0)); },
      error: function() { $log.error.logs.push(concat([], arguments, 0)); },
      debug: function() {
        if (debug) {
          $log.debug.logs.push(concat([], arguments, 0));
        }
      }
    };

    /**
     * @ngdoc method
     * @name $log#reset
     *
     * @description
     * Reset all of the logging arrays to empty.
     */
    $log.reset = function() {
      /**
       * @ngdoc property
       * @name $log#log.logs
       *
       * @description
       * Array of messages logged using {@link ng.$log#log &#x60;log()&#x60;}.
       *
       * @example
       * &#x60;&#x60;&#x60;js
       * $log.log(&#x27;Some Log&#x27;);
       * var first = $log.log.logs.unshift();
       * &#x60;&#x60;&#x60;
       */
      $log.log.logs = [];
      /**
       * @ngdoc property
       * @name $log#info.logs
       *
       * @description
       * Array of messages logged using {@link ng.$log#info &#x60;info()&#x60;}.
       *
       * @example
       * &#x60;&#x60;&#x60;js
       * $log.info(&#x27;Some Info&#x27;);
       * var first = $log.info.logs.unshift();
       * &#x60;&#x60;&#x60;
       */
      $log.info.logs = [];
      /**
       * @ngdoc property
       * @name $log#warn.logs
       *
       * @description
       * Array of messages logged using {@link ng.$log#warn &#x60;warn()&#x60;}.
       *
       * @example
       * &#x60;&#x60;&#x60;js
       * $log.warn(&#x27;Some Warning&#x27;);
       * var first = $log.warn.logs.unshift();
       * &#x60;&#x60;&#x60;
       */
      $log.warn.logs = [];
      /**
       * @ngdoc property
       * @name $log#error.logs
       *
       * @description
       * Array of messages logged using {@link ng.$log#error &#x60;error()&#x60;}.
       *
       * @example
       * &#x60;&#x60;&#x60;js
       * $log.error(&#x27;Some Error&#x27;);
       * var first = $log.error.logs.unshift();
       * &#x60;&#x60;&#x60;
       */
      $log.error.logs = [];
        /**
       * @ngdoc property
       * @name $log#debug.logs
       *
       * @description
       * Array of messages logged using {@link ng.$log#debug &#x60;debug()&#x60;}.
       *
       * @example
       * &#x60;&#x60;&#x60;js
       * $log.debug(&#x27;Some Error&#x27;);
       * var first = $log.debug.logs.unshift();
       * &#x60;&#x60;&#x60;
       */
      $log.debug.logs = [];
    };

    /**
     * @ngdoc method
     * @name $log#assertEmpty
     *
     * @description
     * Assert that all of the logging methods have no logged messages. If any messages are present,
     * an exception is thrown.
     */
    $log.assertEmpty = function() {
      var errors = [];
      angular.forEach([&#x27;error&#x27;, &#x27;warn&#x27;, &#x27;info&#x27;, &#x27;log&#x27;, &#x27;debug&#x27;], function(logLevel) {
        angular.forEach($log[logLevel].logs, function(log) {
          angular.forEach(log, function(logItem) {
            errors.push(&#x27;MOCK $log (&#x27; + logLevel + &#x27;): &#x27; + String(logItem) + &#x27;\n&#x27; +
                        (logItem.stack || &#x27;&#x27;));
          });
        });
      });
      if (errors.length) {
        errors.unshift(&quot;Expected $log to be empty! Either a message was logged unexpectedly, or &quot; +
          &quot;an expected log message was not checked and removed:&quot;);
        errors.push(&#x27;&#x27;);
        throw new Error(errors.join(&#x27;\n---------\n&#x27;));
      }
    };

    $log.reset();
    return $log;
  };
};


/**
 * @ngdoc service
 * @name $interval
 *
 * @description
 * Mock implementation of the $interval service.
 *
 * Use {@link ngMock.$interval#flush &#x60;$interval.flush(millis)&#x60;} to
 * move forward by &#x60;millis&#x60; milliseconds and trigger any functions scheduled to run in that
 * time.
 *
 * @param {function()} fn A function that should be called repeatedly.
 * @param {number} delay Number of milliseconds between each function call.
 * @param {number=} [count=0] Number of times to repeat. If not set, or 0, will repeat
 *   indefinitely.
 * @param {boolean=} [invokeApply=true] If set to &#x60;false&#x60; skips model dirty checking, otherwise
 *   will invoke &#x60;fn&#x60; within the {@link ng.$rootScope.Scope#$apply $apply} block.
 * @returns {promise} A promise which will be notified on each iteration.
 */
angular.mock.$IntervalProvider = function() {
  this.$get = [&#x27;$browser&#x27;, &#x27;$rootScope&#x27;, &#x27;$q&#x27;, &#x27;$$q&#x27;,
       function($browser,   $rootScope,   $q,   $$q) {
    var repeatFns = [],
        nextRepeatId = 0,
        now = 0;

    var $interval = function(fn, delay, count, invokeApply) {
      var iteration = 0,
          skipApply = (angular.isDefined(invokeApply) &amp;&amp; !invokeApply),
          deferred = (skipApply ? $$q : $q).defer(),
          promise = deferred.promise;

      count = (angular.isDefined(count)) ? count : 0;
      promise.then(null, null, fn);

      promise.$$intervalId = nextRepeatId;

      function tick() {
        deferred.notify(iteration++);

        if (count &gt; 0 &amp;&amp; iteration &gt;= count) {
          var fnIndex;
          deferred.resolve(iteration);

          angular.forEach(repeatFns, function(fn, index) {
            if (fn.id === promise.$$intervalId) fnIndex = index;
          });

          if (fnIndex !== undefined) {
            repeatFns.splice(fnIndex, 1);
          }
        }

        if (skipApply) {
          $browser.defer.flush();
        } else {
          $rootScope.$apply();
        }
      }

      repeatFns.push({
        nextTime:(now + delay),
        delay: delay,
        fn: tick,
        id: nextRepeatId,
        deferred: deferred
      });
      repeatFns.sort(function(a, b) { return a.nextTime - b.nextTime;});

      nextRepeatId++;
      return promise;
    };
    /**
     * @ngdoc method
     * @name $interval#cancel
     *
     * @description
     * Cancels a task associated with the &#x60;promise&#x60;.
     *
     * @param {promise} promise A promise from calling the &#x60;$interval&#x60; function.
     * @returns {boolean} Returns &#x60;true&#x60; if the task was successfully cancelled.
     */
    $interval.cancel = function(promise) {
      if (!promise) return false;
      var fnIndex;

      angular.forEach(repeatFns, function(fn, index) {
        if (fn.id === promise.$$intervalId) fnIndex = index;
      });

      if (fnIndex !== undefined) {
        repeatFns[fnIndex].deferred.reject(&#x27;canceled&#x27;);
        repeatFns.splice(fnIndex, 1);
        return true;
      }

      return false;
    };

    /**
     * @ngdoc method
     * @name $interval#flush
     * @description
     *
     * Runs interval tasks scheduled to be run in the next &#x60;millis&#x60; milliseconds.
     *
     * @param {number=} millis maximum timeout amount to flush up until.
     *
     * @return {number} The amount of time moved forward.
     */
    $interval.flush = function(millis) {
      now += millis;
      while (repeatFns.length &amp;&amp; repeatFns[0].nextTime &lt;= now) {
        var task = repeatFns[0];
        task.fn();
        task.nextTime += task.delay;
        repeatFns.sort(function(a, b) { return a.nextTime - b.nextTime;});
      }
      return millis;
    };

    return $interval;
  }];
};


/* jshint -W101 */
/* The R_ISO8061_STR regex is never going to fit into the 100 char limit!
 * This directive should go inside the anonymous function but a bug in JSHint means that it would
 * not be enacted early enough to prevent the warning.
 */
var R_ISO8061_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?:\:?(\d\d)(?:\:?(\d\d)(?:\.(\d{3}))?)?)?(Z|([+-])(\d\d):?(\d\d)))?$/;

function jsonStringToDate(string) {
  var match;
  if (match = string.match(R_ISO8061_STR)) {
    var date = new Date(0),
        tzHour = 0,
        tzMin  = 0;
    if (match[9]) {
      tzHour = int(match[9] + match[10]);
      tzMin = int(match[9] + match[11]);
    }
    date.setUTCFullYear(int(match[1]), int(match[2]) - 1, int(match[3]));
    date.setUTCHours(int(match[4] || 0) - tzHour,
                     int(match[5] || 0) - tzMin,
                     int(match[6] || 0),
                     int(match[7] || 0));
    return date;
  }
  return string;
}

function int(str) {
  return parseInt(str, 10);
}

function padNumber(num, digits, trim) {
  var neg = &#x27;&#x27;;
  if (num &lt; 0) {
    neg =  &#x27;-&#x27;;
    num = -num;
  }
  num = &#x27;&#x27; + num;
  while (num.length &lt; digits) num = &#x27;0&#x27; + num;
  if (trim)
    num = num.substr(num.length - digits);
  return neg + num;
}


/**
 * @ngdoc type
 * @name angular.mock.TzDate
 * @description
 *
 * *NOTE*: this is not an injectable instance, just a globally available mock class of &#x60;Date&#x60;.
 *
 * Mock of the Date type which has its timezone specified via constructor arg.
 *
 * The main purpose is to create Date-like instances with timezone fixed to the specified timezone
 * offset, so that we can test code that depends on local timezone settings without dependency on
 * the time zone settings of the machine where the code is running.
 *
 * @param {number} offset Offset of the *desired* timezone in hours (fractions will be honored)
 * @param {(number|string)} timestamp Timestamp representing the desired time in *UTC*
 *
 * @example
 * !!!! WARNING !!!!!
 * This is not a complete Date object so only methods that were implemented can be called safely.
 * To make matters worse, TzDate instances inherit stuff from Date via a prototype.
 *
 * We do our best to intercept calls to &quot;unimplemented&quot; methods, but since the list of methods is
 * incomplete we might be missing some non-standard methods. This can result in errors like:
 * &quot;Date.prototype.foo called on incompatible Object&quot;.
 *
 * &#x60;&#x60;&#x60;js
 * var newYearInBratislava = new TzDate(-1, &#x27;2009-12-31T23:00:00Z&#x27;);
 * newYearInBratislava.getTimezoneOffset() =&gt; -60;
 * newYearInBratislava.getFullYear() =&gt; 2010;
 * newYearInBratislava.getMonth() =&gt; 0;
 * newYearInBratislava.getDate() =&gt; 1;
 * newYearInBratislava.getHours() =&gt; 0;
 * newYearInBratislava.getMinutes() =&gt; 0;
 * newYearInBratislava.getSeconds() =&gt; 0;
 * &#x60;&#x60;&#x60;
 *
 */
angular.mock.TzDate = function(offset, timestamp) {
  var self = new Date(0);
  if (angular.isString(timestamp)) {
    var tsStr = timestamp;

    self.origDate = jsonStringToDate(timestamp);

    timestamp = self.origDate.getTime();
    if (isNaN(timestamp))
      throw {
        name: &quot;Illegal Argument&quot;,
        message: &quot;Arg &#x27;&quot; + tsStr + &quot;&#x27; passed into TzDate constructor is not a valid date string&quot;
      };
  } else {
    self.origDate = new Date(timestamp);
  }

  var localOffset = new Date(timestamp).getTimezoneOffset();
  self.offsetDiff = localOffset * 60 * 1000 - offset * 1000 * 60 * 60;
  self.date = new Date(timestamp + self.offsetDiff);

  self.getTime = function() {
    return self.date.getTime() - self.offsetDiff;
  };

  self.toLocaleDateString = function() {
    return self.date.toLocaleDateString();
  };

  self.getFullYear = function() {
    return self.date.getFullYear();
  };

  self.getMonth = function() {
    return self.date.getMonth();
  };

  self.getDate = function() {
    return self.date.getDate();
  };

  self.getHours = function() {
    return self.date.getHours();
  };

  self.getMinutes = function() {
    return self.date.getMinutes();
  };

  self.getSeconds = function() {
    return self.date.getSeconds();
  };

  self.getMilliseconds = function() {
    return self.date.getMilliseconds();
  };

  self.getTimezoneOffset = function() {
    return offset * 60;
  };

  self.getUTCFullYear = function() {
    return self.origDate.getUTCFullYear();
  };

  self.getUTCMonth = function() {
    return self.origDate.getUTCMonth();
  };

  self.getUTCDate = function() {
    return self.origDate.getUTCDate();
  };

  self.getUTCHours = function() {
    return self.origDate.getUTCHours();
  };

  self.getUTCMinutes = function() {
    return self.origDate.getUTCMinutes();
  };

  self.getUTCSeconds = function() {
    return self.origDate.getUTCSeconds();
  };

  self.getUTCMilliseconds = function() {
    return self.origDate.getUTCMilliseconds();
  };

  self.getDay = function() {
    return self.date.getDay();
  };

  // provide this method only on browsers that already have it
  if (self.toISOString) {
    self.toISOString = function() {
      return padNumber(self.origDate.getUTCFullYear(), 4) + &#x27;-&#x27; +
            padNumber(self.origDate.getUTCMonth() + 1, 2) + &#x27;-&#x27; +
            padNumber(self.origDate.getUTCDate(), 2) + &#x27;T&#x27; +
            padNumber(self.origDate.getUTCHours(), 2) + &#x27;:&#x27; +
            padNumber(self.origDate.getUTCMinutes(), 2) + &#x27;:&#x27; +
            padNumber(self.origDate.getUTCSeconds(), 2) + &#x27;.&#x27; +
            padNumber(self.origDate.getUTCMilliseconds(), 3) + &#x27;Z&#x27;;
    };
  }

  //hide all methods not implemented in this mock that the Date prototype exposes
  var unimplementedMethods = [&#x27;getUTCDay&#x27;,
      &#x27;getYear&#x27;, &#x27;setDate&#x27;, &#x27;setFullYear&#x27;, &#x27;setHours&#x27;, &#x27;setMilliseconds&#x27;,
      &#x27;setMinutes&#x27;, &#x27;setMonth&#x27;, &#x27;setSeconds&#x27;, &#x27;setTime&#x27;, &#x27;setUTCDate&#x27;, &#x27;setUTCFullYear&#x27;,
      &#x27;setUTCHours&#x27;, &#x27;setUTCMilliseconds&#x27;, &#x27;setUTCMinutes&#x27;, &#x27;setUTCMonth&#x27;, &#x27;setUTCSeconds&#x27;,
      &#x27;setYear&#x27;, &#x27;toDateString&#x27;, &#x27;toGMTString&#x27;, &#x27;toJSON&#x27;, &#x27;toLocaleFormat&#x27;, &#x27;toLocaleString&#x27;,
      &#x27;toLocaleTimeString&#x27;, &#x27;toSource&#x27;, &#x27;toString&#x27;, &#x27;toTimeString&#x27;, &#x27;toUTCString&#x27;, &#x27;valueOf&#x27;];

  angular.forEach(unimplementedMethods, function(methodName) {
    self[methodName] = function() {
      throw new Error(&quot;Method &#x27;&quot; + methodName + &quot;&#x27; is not implemented in the TzDate mock&quot;);
    };
  });

  return self;
};

//make &quot;tzDateInstance instanceof Date&quot; return true
angular.mock.TzDate.prototype = Date.prototype;
/* jshint +W101 */

angular.mock.animate = angular.module(&#x27;ngAnimateMock&#x27;, [&#x27;ng&#x27;])

  .config([&#x27;$provide&#x27;, function($provide) {

    var reflowQueue = [];
    $provide.value(&#x27;$$animateReflow&#x27;, function(fn) {
      var index = reflowQueue.length;
      reflowQueue.push(fn);
      return function cancel() {
        reflowQueue.splice(index, 1);
      };
    });

    $provide.decorator(&#x27;$animate&#x27;, [&#x27;$delegate&#x27;, &#x27;$$asyncCallback&#x27;, &#x27;$timeout&#x27;, &#x27;$browser&#x27;,
                            function($delegate,   $$asyncCallback,   $timeout,   $browser) {
      var animate = {
        queue: [],
        cancel: $delegate.cancel,
        enabled: $delegate.enabled,
        triggerCallbackEvents: function() {
          $$asyncCallback.flush();
        },
        triggerCallbackPromise: function() {
          $timeout.flush(0);
        },
        triggerCallbacks: function() {
          this.triggerCallbackEvents();
          this.triggerCallbackPromise();
        },
        triggerReflow: function() {
          angular.forEach(reflowQueue, function(fn) {
            fn();
          });
          reflowQueue = [];
        }
      };

      angular.forEach(
        [&#x27;animate&#x27;,&#x27;enter&#x27;,&#x27;leave&#x27;,&#x27;move&#x27;,&#x27;addClass&#x27;,&#x27;removeClass&#x27;,&#x27;setClass&#x27;], function(method) {
        animate[method] = function() {
          animate.queue.push({
            event: method,
            element: arguments[0],
            options: arguments[arguments.length - 1],
            args: arguments
          });
          return $delegate[method].apply($delegate, arguments);
        };
      });

      return animate;
    }]);

  }]);


/**
 * @ngdoc function
 * @name angular.mock.dump
 * @description
 *
 * *NOTE*: this is not an injectable instance, just a globally available function.
 *
 * Method for serializing common angular objects (scope, elements, etc..) into strings, useful for
 * debugging.
 *
 * This method is also available on window, where it can be used to display objects on debug
 * console.
 *
 * @param {*} object - any object to turn into string.
 * @return {string} a serialized string of the argument
 */
angular.mock.dump = function(object) {
  return serialize(object);

  function serialize(object) {
    var out;

    if (angular.isElement(object)) {
      object = angular.element(object);
      out = angular.element(&#x27;&lt;div&gt;&lt;/div&gt;&#x27;);
      angular.forEach(object, function(element) {
        out.append(angular.element(element).clone());
      });
      out = out.html();
    } else if (angular.isArray(object)) {
      out = [];
      angular.forEach(object, function(o) {
        out.push(serialize(o));
      });
      out = &#x27;[ &#x27; + out.join(&#x27;, &#x27;) + &#x27; ]&#x27;;
    } else if (angular.isObject(object)) {
      if (angular.isFunction(object.$eval) &amp;&amp; angular.isFunction(object.$apply)) {
        out = serializeScope(object);
      } else if (object instanceof Error) {
        out = object.stack || (&#x27;&#x27; + object.name + &#x27;: &#x27; + object.message);
      } else {
        // TODO(i): this prevents methods being logged,
        // we should have a better way to serialize objects
        out = angular.toJson(object, true);
      }
    } else {
      out = String(object);
    }

    return out;
  }

  function serializeScope(scope, offset) {
    offset = offset ||  &#x27;  &#x27;;
    var log = [offset + &#x27;Scope(&#x27; + scope.$id + &#x27;): {&#x27;];
    for (var key in scope) {
      if (Object.prototype.hasOwnProperty.call(scope, key) &amp;&amp; !key.match(/^(\$|this)/)) {
        log.push(&#x27;  &#x27; + key + &#x27;: &#x27; + angular.toJson(scope[key]));
      }
    }
    var child = scope.$$childHead;
    while (child) {
      log.push(serializeScope(child, offset + &#x27;  &#x27;));
      child = child.$$nextSibling;
    }
    log.push(&#x27;}&#x27;);
    return log.join(&#x27;\n&#x27; + offset);
  }
};

/**
 * @ngdoc service
 * @name $httpBackend
 * @description
 * Fake HTTP backend implementation suitable for unit testing applications that use the
 * {@link ng.$http $http service}.
 *
 * *Note*: For fake HTTP backend implementation suitable for end-to-end testing or backend-less
 * development please see {@link ngMockE2E.$httpBackend e2e $httpBackend mock}.
 *
 * During unit testing, we want our unit tests to run quickly and have no external dependencies so
 * we don’t want to send [XHR](https://developer.mozilla.org/en/xmlhttprequest) or
 * [JSONP](http://en.wikipedia.org/wiki/JSONP) requests to a real server. All we really need is
 * to verify whether a certain request has been sent or not, or alternatively just let the
 * application make requests, respond with pre-trained responses and assert that the end result is
 * what we expect it to be.
 *
 * This mock implementation can be used to respond with static or dynamic responses via the
 * &#x60;expect&#x60; and &#x60;when&#x60; apis and their shortcuts (&#x60;expectGET&#x60;, &#x60;whenPOST&#x60;, etc).
 *
 * When an Angular application needs some data from a server, it calls the $http service, which
 * sends the request to a real server using $httpBackend service. With dependency injection, it is
 * easy to inject $httpBackend mock (which has the same API as $httpBackend) and use it to verify
 * the requests and respond with some testing data without sending a request to a real server.
 *
 * There are two ways to specify what test data should be returned as http responses by the mock
 * backend when the code under test makes http requests:
 *
 * - &#x60;$httpBackend.expect&#x60; - specifies a request expectation
 * - &#x60;$httpBackend.when&#x60; - specifies a backend definition
 *
 *
 * # Request Expectations vs Backend Definitions
 *
 * Request expectations provide a way to make assertions about requests made by the application and
 * to define responses for those requests. The test will fail if the expected requests are not made
 * or they are made in the wrong order.
 *
 * Backend definitions allow you to define a fake backend for your application which doesn&#x27;t assert
 * if a particular request was made or not, it just returns a trained response if a request is made.
 * The test will pass whether or not the request gets made during testing.
 *
 *
 * &lt;table class=&quot;table&quot;&gt;
 *   &lt;tr&gt;&lt;th width=&quot;220px&quot;&gt;&lt;/th&gt;&lt;th&gt;Request expectations&lt;/th&gt;&lt;th&gt;Backend definitions&lt;/th&gt;&lt;/tr&gt;
 *   &lt;tr&gt;
 *     &lt;th&gt;Syntax&lt;/th&gt;
 *     &lt;td&gt;.expect(...).respond(...)&lt;/td&gt;
 *     &lt;td&gt;.when(...).respond(...)&lt;/td&gt;
 *   &lt;/tr&gt;
 *   &lt;tr&gt;
 *     &lt;th&gt;Typical usage&lt;/th&gt;
 *     &lt;td&gt;strict unit tests&lt;/td&gt;
 *     &lt;td&gt;loose (black-box) unit testing&lt;/td&gt;
 *   &lt;/tr&gt;
 *   &lt;tr&gt;
 *     &lt;th&gt;Fulfills multiple requests&lt;/th&gt;
 *     &lt;td&gt;NO&lt;/td&gt;
 *     &lt;td&gt;YES&lt;/td&gt;
 *   &lt;/tr&gt;
 *   &lt;tr&gt;
 *     &lt;th&gt;Order of requests matters&lt;/th&gt;
 *     &lt;td&gt;YES&lt;/td&gt;
 *     &lt;td&gt;NO&lt;/td&gt;
 *   &lt;/tr&gt;
 *   &lt;tr&gt;
 *     &lt;th&gt;Request required&lt;/th&gt;
 *     &lt;td&gt;YES&lt;/td&gt;
 *     &lt;td&gt;NO&lt;/td&gt;
 *   &lt;/tr&gt;
 *   &lt;tr&gt;
 *     &lt;th&gt;Response required&lt;/th&gt;
 *     &lt;td&gt;optional (see below)&lt;/td&gt;
 *     &lt;td&gt;YES&lt;/td&gt;
 *   &lt;/tr&gt;
 * &lt;/table&gt;
 *
 * In cases where both backend definitions and request expectations are specified during unit
 * testing, the request expectations are evaluated first.
 *
 * If a request expectation has no response specified, the algorithm will search your backend
 * definitions for an appropriate response.
 *
 * If a request didn&#x27;t match any expectation or if the expectation doesn&#x27;t have the response
 * defined, the backend definitions are evaluated in sequential order to see if any of them match
 * the request. The response from the first matched definition is returned.
 *
 *
 * # Flushing HTTP requests
 *
 * The $httpBackend used in production always responds to requests asynchronously. If we preserved
 * this behavior in unit testing, we&#x27;d have to create async unit tests, which are hard to write,
 * to follow and to maintain. But neither can the testing mock respond synchronously; that would
 * change the execution of the code under test. For this reason, the mock $httpBackend has a
 * &#x60;flush()&#x60; method, which allows the test to explicitly flush pending requests. This preserves
 * the async api of the backend, while allowing the test to execute synchronously.
 *
 *
 * # Unit testing with mock $httpBackend
 * The following code shows how to setup and use the mock backend when unit testing a controller.
 * First we create the controller under test:
 *
  &#x60;&#x60;&#x60;js
  // The module code
  angular
    .module(&#x27;MyApp&#x27;, [])
    .controller(&#x27;MyController&#x27;, MyController);

  // The controller code
  function MyController($scope, $http) {
    var authToken;

    $http.get(&#x27;/auth.py&#x27;).success(function(data, status, headers) {
      authToken = headers(&#x27;A-Token&#x27;);
      $scope.user = data;
    });

    $scope.saveMessage = function(message) {
      var headers = { &#x27;Authorization&#x27;: authToken };
      $scope.status = &#x27;Saving...&#x27;;

      $http.post(&#x27;/add-msg.py&#x27;, message, { headers: headers } ).success(function(response) {
        $scope.status = &#x27;&#x27;;
      }).error(function() {
        $scope.status = &#x27;ERROR!&#x27;;
      });
    };
  }
  &#x60;&#x60;&#x60;
 *
 * Now we setup the mock backend and create the test specs:
 *
  &#x60;&#x60;&#x60;js
    // testing controller
    describe(&#x27;MyController&#x27;, function() {
       var $httpBackend, $rootScope, createController, authRequestHandler;

       // Set up the module
       beforeEach(module(&#x27;MyApp&#x27;));

       beforeEach(inject(function($injector) {
         // Set up the mock http service responses
         $httpBackend = $injector.get(&#x27;$httpBackend&#x27;);
         // backend definition common for all tests
         authRequestHandler = $httpBackend.when(&#x27;GET&#x27;, &#x27;/auth.py&#x27;)
                                .respond({userId: &#x27;userX&#x27;}, {&#x27;A-Token&#x27;: &#x27;xxx&#x27;});

         // Get hold of a scope (i.e. the root scope)
         $rootScope = $injector.get(&#x27;$rootScope&#x27;);
         // The $controller service is used to create instances of controllers
         var $controller = $injector.get(&#x27;$controller&#x27;);

         createController = function() {
           return $controller(&#x27;MyController&#x27;, {&#x27;$scope&#x27; : $rootScope });
         };
       }));


       afterEach(function() {
         $httpBackend.verifyNoOutstandingExpectation();
         $httpBackend.verifyNoOutstandingRequest();
       });


       it(&#x27;should fetch authentication token&#x27;, function() {
         $httpBackend.expectGET(&#x27;/auth.py&#x27;);
         var controller = createController();
         $httpBackend.flush();
       });


       it(&#x27;should fail authentication&#x27;, function() {

         // Notice how you can change the response even after it was set
         authRequestHandler.respond(401, &#x27;&#x27;);

         $httpBackend.expectGET(&#x27;/auth.py&#x27;);
         var controller = createController();
         $httpBackend.flush();
         expect($rootScope.status).toBe(&#x27;Failed...&#x27;);
       });


       it(&#x27;should send msg to server&#x27;, function() {
         var controller = createController();
         $httpBackend.flush();

         // now you don’t care about the authentication, but
         // the controller will still send the request and
         // $httpBackend will respond without you having to
         // specify the expectation and response for this request

         $httpBackend.expectPOST(&#x27;/add-msg.py&#x27;, &#x27;message content&#x27;).respond(201, &#x27;&#x27;);
         $rootScope.saveMessage(&#x27;message content&#x27;);
         expect($rootScope.status).toBe(&#x27;Saving...&#x27;);
         $httpBackend.flush();
         expect($rootScope.status).toBe(&#x27;&#x27;);
       });


       it(&#x27;should send auth header&#x27;, function() {
         var controller = createController();
         $httpBackend.flush();

         $httpBackend.expectPOST(&#x27;/add-msg.py&#x27;, undefined, function(headers) {
           // check if the header was send, if it wasn&#x27;t the expectation won&#x27;t
           // match the request and the test will fail
           return headers[&#x27;Authorization&#x27;] == &#x27;xxx&#x27;;
         }).respond(201, &#x27;&#x27;);

         $rootScope.saveMessage(&#x27;whatever&#x27;);
         $httpBackend.flush();
       });
    });
   &#x60;&#x60;&#x60;
 */
angular.mock.$HttpBackendProvider = function() {
  this.$get = [&#x27;$rootScope&#x27;, &#x27;$timeout&#x27;, createHttpBackendMock];
};

/**
 * General factory function for $httpBackend mock.
 * Returns instance for unit testing (when no arguments specified):
 *   - passing through is disabled
 *   - auto flushing is disabled
 *
 * Returns instance for e2e testing (when &#x60;$delegate&#x60; and &#x60;$browser&#x60; specified):
 *   - passing through (delegating request to real backend) is enabled
 *   - auto flushing is enabled
 *
 * @param {Object=} $delegate Real $httpBackend instance (allow passing through if specified)
 * @param {Object=} $browser Auto-flushing enabled if specified
 * @return {Object} Instance of $httpBackend mock
 */
function createHttpBackendMock($rootScope, $timeout, $delegate, $browser) {
  var definitions = [],
      expectations = [],
      responses = [],
      responsesPush = angular.bind(responses, responses.push),
      copy = angular.copy;

  function createResponse(status, data, headers, statusText) {
    if (angular.isFunction(status)) return status;

    return function() {
      return angular.isNumber(status)
          ? [status, data, headers, statusText]
          : [200, status, data, headers];
    };
  }

  // TODO(vojta): change params to: method, url, data, headers, callback
  function $httpBackend(method, url, data, callback, headers, timeout, withCredentials) {
    var xhr = new MockXhr(),
        expectation = expectations[0],
        wasExpected = false;

    function prettyPrint(data) {
      return (angular.isString(data) || angular.isFunction(data) || data instanceof RegExp)
          ? data
          : angular.toJson(data);
    }

    function wrapResponse(wrapped) {
      if (!$browser &amp;&amp; timeout) {
        timeout.then ? timeout.then(handleTimeout) : $timeout(handleTimeout, timeout);
      }

      return handleResponse;

      function handleResponse() {
        var response = wrapped.response(method, url, data, headers);
        xhr.$$respHeaders = response[2];
        callback(copy(response[0]), copy(response[1]), xhr.getAllResponseHeaders(),
                 copy(response[3] || &#x27;&#x27;));
      }

      function handleTimeout() {
        for (var i = 0, ii = responses.length; i &lt; ii; i++) {
          if (responses[i] === handleResponse) {
            responses.splice(i, 1);
            callback(-1, undefined, &#x27;&#x27;);
            break;
          }
        }
      }
    }

    if (expectation &amp;&amp; expectation.match(method, url)) {
      if (!expectation.matchData(data))
        throw new Error(&#x27;Expected &#x27; + expectation + &#x27; with different data\n&#x27; +
            &#x27;EXPECTED: &#x27; + prettyPrint(expectation.data) + &#x27;\nGOT:      &#x27; + data);

      if (!expectation.matchHeaders(headers))
        throw new Error(&#x27;Expected &#x27; + expectation + &#x27; with different headers\n&#x27; +
                        &#x27;EXPECTED: &#x27; + prettyPrint(expectation.headers) + &#x27;\nGOT:      &#x27; +
                        prettyPrint(headers));

      expectations.shift();

      if (expectation.response) {
        responses.push(wrapResponse(expectation));
        return;
      }
      wasExpected = true;
    }

    var i = -1, definition;
    while ((definition = definitions[++i])) {
      if (definition.match(method, url, data, headers || {})) {
        if (definition.response) {
          // if $browser specified, we do auto flush all requests
          ($browser ? $browser.defer : responsesPush)(wrapResponse(definition));
        } else if (definition.passThrough) {
          $delegate(method, url, data, callback, headers, timeout, withCredentials);
        } else throw new Error(&#x27;No response defined !&#x27;);
        return;
      }
    }
    throw wasExpected ?
        new Error(&#x27;No response defined !&#x27;) :
        new Error(&#x27;Unexpected request: &#x27; + method + &#x27; &#x27; + url + &#x27;\n&#x27; +
                  (expectation ? &#x27;Expected &#x27; + expectation : &#x27;No more request expected&#x27;));
  }

  /**
   * @ngdoc method
   * @name $httpBackend#when
   * @description
   * Creates a new backend definition.
   *
   * @param {string} method HTTP method.
   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
   *   and returns true if the url match the current definition.
   * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives
   *   data string and returns true if the data is as expected.
   * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header
   *   object and returns true if the headers match the current definition.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   *   request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   *   order to change how a matched request is handled.
   *
   *  - respond –
   *      &#x60;{function([status,] data[, headers, statusText])
   *      | function(function(method, url, data, headers)}&#x60;
   *    – The respond method takes a set of static data to be returned or a function that can
   *    return an array containing response status (number), response data (string), response
   *    headers (Object), and the text for the status (string). The respond method returns the
   *    &#x60;requestHandler&#x60; object for possible overrides.
   */
  $httpBackend.when = function(method, url, data, headers) {
    var definition = new MockHttpExpectation(method, url, data, headers),
        chain = {
          respond: function(status, data, headers, statusText) {
            definition.passThrough = undefined;
            definition.response = createResponse(status, data, headers, statusText);
            return chain;
          }
        };

    if ($browser) {
      chain.passThrough = function() {
        definition.response = undefined;
        definition.passThrough = true;
        return chain;
      };
    }

    definitions.push(definition);
    return chain;
  };

  /**
   * @ngdoc method
   * @name $httpBackend#whenGET
   * @description
   * Creates a new backend definition for GET requests. For more info see &#x60;when()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
   *   and returns true if the url match the current definition.
   * @param {(Object|function(Object))=} headers HTTP headers.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   * request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   * order to change how a matched request is handled.
   */

  /**
   * @ngdoc method
   * @name $httpBackend#whenHEAD
   * @description
   * Creates a new backend definition for HEAD requests. For more info see &#x60;when()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
   *   and returns true if the url match the current definition.
   * @param {(Object|function(Object))=} headers HTTP headers.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   * request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   * order to change how a matched request is handled.
   */

  /**
   * @ngdoc method
   * @name $httpBackend#whenDELETE
   * @description
   * Creates a new backend definition for DELETE requests. For more info see &#x60;when()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
   *   and returns true if the url match the current definition.
   * @param {(Object|function(Object))=} headers HTTP headers.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   * request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   * order to change how a matched request is handled.
   */

  /**
   * @ngdoc method
   * @name $httpBackend#whenPOST
   * @description
   * Creates a new backend definition for POST requests. For more info see &#x60;when()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
   *   and returns true if the url match the current definition.
   * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives
   *   data string and returns true if the data is as expected.
   * @param {(Object|function(Object))=} headers HTTP headers.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   * request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   * order to change how a matched request is handled.
   */

  /**
   * @ngdoc method
   * @name $httpBackend#whenPUT
   * @description
   * Creates a new backend definition for PUT requests.  For more info see &#x60;when()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
   *   and returns true if the url match the current definition.
   * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives
   *   data string and returns true if the data is as expected.
   * @param {(Object|function(Object))=} headers HTTP headers.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   * request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   * order to change how a matched request is handled.
   */

  /**
   * @ngdoc method
   * @name $httpBackend#whenJSONP
   * @description
   * Creates a new backend definition for JSONP requests. For more info see &#x60;when()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
   *   and returns true if the url match the current definition.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   * request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   * order to change how a matched request is handled.
   */
  createShortMethods(&#x27;when&#x27;);


  /**
   * @ngdoc method
   * @name $httpBackend#expect
   * @description
   * Creates a new request expectation.
   *
   * @param {string} method HTTP method.
   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
   *   and returns true if the url match the current definition.
   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that
   *  receives data string and returns true if the data is as expected, or Object if request body
   *  is in JSON format.
   * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header
   *   object and returns true if the headers match the current expectation.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   *  request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   *  order to change how a matched request is handled.
   *
   *  - respond –
   *    &#x60;{function([status,] data[, headers, statusText])
   *    | function(function(method, url, data, headers)}&#x60;
   *    – The respond method takes a set of static data to be returned or a function that can
   *    return an array containing response status (number), response data (string), response
   *    headers (Object), and the text for the status (string). The respond method returns the
   *    &#x60;requestHandler&#x60; object for possible overrides.
   */
  $httpBackend.expect = function(method, url, data, headers) {
    var expectation = new MockHttpExpectation(method, url, data, headers),
        chain = {
          respond: function(status, data, headers, statusText) {
            expectation.response = createResponse(status, data, headers, statusText);
            return chain;
          }
        };

    expectations.push(expectation);
    return chain;
  };


  /**
   * @ngdoc method
   * @name $httpBackend#expectGET
   * @description
   * Creates a new request expectation for GET requests. For more info see &#x60;expect()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
   *   and returns true if the url match the current definition.
   * @param {Object=} headers HTTP headers.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   * request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   * order to change how a matched request is handled. See #expect for more info.
   */

  /**
   * @ngdoc method
   * @name $httpBackend#expectHEAD
   * @description
   * Creates a new request expectation for HEAD requests. For more info see &#x60;expect()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
   *   and returns true if the url match the current definition.
   * @param {Object=} headers HTTP headers.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   *   request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   *   order to change how a matched request is handled.
   */

  /**
   * @ngdoc method
   * @name $httpBackend#expectDELETE
   * @description
   * Creates a new request expectation for DELETE requests. For more info see &#x60;expect()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
   *   and returns true if the url match the current definition.
   * @param {Object=} headers HTTP headers.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   *   request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   *   order to change how a matched request is handled.
   */

  /**
   * @ngdoc method
   * @name $httpBackend#expectPOST
   * @description
   * Creates a new request expectation for POST requests. For more info see &#x60;expect()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
   *   and returns true if the url match the current definition.
   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that
   *  receives data string and returns true if the data is as expected, or Object if request body
   *  is in JSON format.
   * @param {Object=} headers HTTP headers.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   *   request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   *   order to change how a matched request is handled.
   */

  /**
   * @ngdoc method
   * @name $httpBackend#expectPUT
   * @description
   * Creates a new request expectation for PUT requests. For more info see &#x60;expect()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
   *   and returns true if the url match the current definition.
   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that
   *  receives data string and returns true if the data is as expected, or Object if request body
   *  is in JSON format.
   * @param {Object=} headers HTTP headers.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   *   request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   *   order to change how a matched request is handled.
   */

  /**
   * @ngdoc method
   * @name $httpBackend#expectPATCH
   * @description
   * Creates a new request expectation for PATCH requests. For more info see &#x60;expect()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
   *   and returns true if the url match the current definition.
   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that
   *  receives data string and returns true if the data is as expected, or Object if request body
   *  is in JSON format.
   * @param {Object=} headers HTTP headers.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   *   request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   *   order to change how a matched request is handled.
   */

  /**
   * @ngdoc method
   * @name $httpBackend#expectJSONP
   * @description
   * Creates a new request expectation for JSONP requests. For more info see &#x60;expect()&#x60;.
   *
   * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
   *   and returns true if the url match the current definition.
   * @returns {requestHandler} Returns an object with &#x60;respond&#x60; method that controls how a matched
   *   request is handled. You can save this object for later use and invoke &#x60;respond&#x60; again in
   *   order to change how a matched request is handled.
   */
  createShortMethods(&#x27;expect&#x27;);


  /**
   * @ngdoc method
   * @name $httpBackend#flush
   * @description
   * Flushes all pending requests using the trained responses.
   *
   * @param {number=} count Number of responses to flush (in the order they arrived). If undefined,
   *   all pending requests will be flushed. If there are no pending requests when the flush method
   *   is called an exception is thrown (as this typically a sign of programming error).
   */
  $httpBackend.flush = function(count, digest) {
    if (digest !== false) $rootScope.$digest();
    if (!responses.length) throw new Error(&#x27;No pending request to flush !&#x27;);

    if (angular.isDefined(count) &amp;&amp; count !== null) {
      while (count--) {
        if (!responses.length) throw new Error(&#x27;No more pending request to flush !&#x27;);
        responses.shift()();
      }
    } else {
      while (responses.length) {
        responses.shift()();
      }
    }
    $httpBackend.verifyNoOutstandingExpectation(digest);
  };


  /**
   * @ngdoc method
   * @name $httpBackend#verifyNoOutstandingExpectation
   * @description
   * Verifies that all of the requests defined via the &#x60;expect&#x60; api were made. If any of the
   * requests were not made, verifyNoOutstandingExpectation throws an exception.
   *
   * Typically, you would call this method following each test case that asserts requests using an
   * &quot;afterEach&quot; clause.
   *
   * &#x60;&#x60;&#x60;js
   *   afterEach($httpBackend.verifyNoOutstandingExpectation);
   * &#x60;&#x60;&#x60;
   */
  $httpBackend.verifyNoOutstandingExpectation = function(digest) {
    if (digest !== false) $rootScope.$digest();
    if (expectations.length) {
      throw new Error(&#x27;Unsatisfied requests: &#x27; + expectations.join(&#x27;, &#x27;));
    }
  };


  /**
   * @ngdoc method
   * @name $httpBackend#verifyNoOutstandingRequest
   * @description
   * Verifies that there are no outstanding requests that need to be flushed.
   *
   * Typically, you would call this method following each test case that asserts requests using an
   * &quot;afterEach&quot; clause.
   *
   * &#x60;&#x60;&#x60;js
   *   afterEach($httpBackend.verifyNoOutstandingRequest);
   * &#x60;&#x60;&#x60;
   */
  $httpBackend.verifyNoOutstandingRequest = function() {
    if (responses.length) {
      throw new Error(&#x27;Unflushed requests: &#x27; + responses.length);
    }
  };


  /**
   * @ngdoc method
   * @name $httpBackend#resetExpectations
   * @description
   * Resets all request expectations, but preserves all backend definitions. Typically, you would
   * call resetExpectations during a multiple-phase test when you want to reuse the same instance of
   * $httpBackend mock.
   */
  $httpBackend.resetExpectations = function() {
    expectations.length = 0;
    responses.length = 0;
  };

  return $httpBackend;


  function createShortMethods(prefix) {
    angular.forEach([&#x27;GET&#x27;, &#x27;DELETE&#x27;, &#x27;JSONP&#x27;, &#x27;HEAD&#x27;], function(method) {
     $httpBackend[prefix + method] = function(url, headers) {
       return $httpBackend[prefix](method, url, undefined, headers);
     };
    });

    angular.forEach([&#x27;PUT&#x27;, &#x27;POST&#x27;, &#x27;PATCH&#x27;], function(method) {
      $httpBackend[prefix + method] = function(url, data, headers) {
        return $httpBackend[prefix](method, url, data, headers);
      };
    });
  }
}

function MockHttpExpectation(method, url, data, headers) {

  this.data = data;
  this.headers = headers;

  this.match = function(m, u, d, h) {
    if (method != m) return false;
    if (!this.matchUrl(u)) return false;
    if (angular.isDefined(d) &amp;&amp; !this.matchData(d)) return false;
    if (angular.isDefined(h) &amp;&amp; !this.matchHeaders(h)) return false;
    return true;
  };

  this.matchUrl = function(u) {
    if (!url) return true;
    if (angular.isFunction(url.test)) return url.test(u);
    if (angular.isFunction(url)) return url(u);
    return url == u;
  };

  this.matchHeaders = function(h) {
    if (angular.isUndefined(headers)) return true;
    if (angular.isFunction(headers)) return headers(h);
    return angular.equals(headers, h);
  };

  this.matchData = function(d) {
    if (angular.isUndefined(data)) return true;
    if (data &amp;&amp; angular.isFunction(data.test)) return data.test(d);
    if (data &amp;&amp; angular.isFunction(data)) return data(d);
    if (data &amp;&amp; !angular.isString(data)) {
      return angular.equals(angular.fromJson(angular.toJson(data)), angular.fromJson(d));
    }
    return data == d;
  };

  this.toString = function() {
    return method + &#x27; &#x27; + url;
  };
}

function createMockXhr() {
  return new MockXhr();
}

function MockXhr() {

  // hack for testing $http, $httpBackend
  MockXhr.$$lastInstance = this;

  this.open = function(method, url, async) {
    this.$$method = method;
    this.$$url = url;
    this.$$async = async;
    this.$$reqHeaders = {};
    this.$$respHeaders = {};
  };

  this.send = function(data) {
    this.$$data = data;
  };

  this.setRequestHeader = function(key, value) {
    this.$$reqHeaders[key] = value;
  };

  this.getResponseHeader = function(name) {
    // the lookup must be case insensitive,
    // that&#x27;s why we try two quick lookups first and full scan last
    var header = this.$$respHeaders[name];
    if (header) return header;

    name = angular.lowercase(name);
    header = this.$$respHeaders[name];
    if (header) return header;

    header = undefined;
    angular.forEach(this.$$respHeaders, function(headerVal, headerName) {
      if (!header &amp;&amp; angular.lowercase(headerName) == name) header = headerVal;
    });
    return header;
  };

  this.getAllResponseHeaders = function() {
    var lines = [];

    angular.forEach(this.$$respHeaders, function(value, key) {
      lines.push(key + &#x27;: &#x27; + value);
    });
    return lines.join(&#x27;\n&#x27;);
  };

  this.abort = angular.noop;
}


/**
 * @ngdoc service
 * @name $timeout
 * @description
 *
 * This service is just a simple decorator for {@link ng.$timeout $timeout} service
 * that adds a &quot;flush&quot; and &quot;verifyNoPendingTasks&quot; methods.
 */

angular.mock.$TimeoutDecorator = [&#x27;$delegate&#x27;, &#x27;$browser&#x27;, function($delegate, $browser) {

  /**
   * @ngdoc method
   * @name $timeout#flush
   * @description
   *
   * Flushes the queue of pending tasks.
   *
   * @param {number=} delay maximum timeout amount to flush up until
   */
  $delegate.flush = function(delay) {
    $browser.defer.flush(delay);
  };

  /**
   * @ngdoc method
   * @name $timeout#verifyNoPendingTasks
   * @description
   *
   * Verifies that there are no pending tasks that need to be flushed.
   */
  $delegate.verifyNoPendingTasks = function() {
    if ($browser.deferredFns.length) {
      throw new Error(&#x27;Deferred tasks to flush (&#x27; + $browser.deferredFns.length + &#x27;): &#x27; +
          formatPendingTasksAsString($browser.deferredFns));
    }
  };

  function formatPendingTasksAsString(tasks) {
    var result = [];
    angular.forEach(tasks, function(task) {
      result.push(&#x27;{id: &#x27; + task.id + &#x27;, &#x27; + &#x27;time: &#x27; + task.time + &#x27;}&#x27;);
    });

    return result.join(&#x27;, &#x27;);
  }

  return $delegate;
}];

angular.mock.$RAFDecorator = [&#x27;$delegate&#x27;, function($delegate) {
  var queue = [];
  var rafFn = function(fn) {
    var index = queue.length;
    queue.push(fn);
    return function() {
      queue.splice(index, 1);
    };
  };

  rafFn.supported = $delegate.supported;

  rafFn.flush = function() {
    if (queue.length === 0) {
      throw new Error(&#x27;No rAF callbacks present&#x27;);
    }

    var length = queue.length;
    for (var i = 0; i &lt; length; i++) {
      queue[i]();
    }

    queue = [];
  };

  return rafFn;
}];

angular.mock.$AsyncCallbackDecorator = [&#x27;$delegate&#x27;, function($delegate) {
  var callbacks = [];
  var addFn = function(fn) {
    callbacks.push(fn);
  };
  addFn.flush = function() {
    angular.forEach(callbacks, function(fn) {
      fn();
    });
    callbacks = [];
  };
  return addFn;
}];

/**
 *
 */
angular.mock.$RootElementProvider = function() {
  this.$get = function() {
    return angular.element(&#x27;&lt;div ng-app&gt;&lt;/div&gt;&#x27;);
  };
};

/**
 * @ngdoc module
 * @name ngMock
 * @packageName angular-mocks
 * @description
 *
 * # ngMock
 *
 * The &#x60;ngMock&#x60; module provides support to inject and mock Angular services into unit tests.
 * In addition, ngMock also extends various core ng services such that they can be
 * inspected and controlled in a synchronous manner within test code.
 *
 *
 * &lt;div doc-module-components=&quot;ngMock&quot;&gt;&lt;/div&gt;
 *
 */
angular.module(&#x27;ngMock&#x27;, [&#x27;ng&#x27;]).provider({
  $browser: angular.mock.$BrowserProvider,
  $exceptionHandler: angular.mock.$ExceptionHandlerProvider,
  $log: angular.mock.$LogProvider,
  $interval: angular.mock.$IntervalProvider,
  $httpBackend: angular.mock.$HttpBackendProvider,
  $rootElement: angular.mock.$RootElementProvider
}).config([&#x27;$provide&#x27;, function($provide) {
  $provide.decorator(&#x27;$timeout&#x27;, angular.mock.$TimeoutDecorator);
  $provide.decorator(&#x27;$$rAF&#x27;, angular.mock.$RAFDecorator);
  $provide.decorator(&#x27;$$asyncCallback&#x27;, angular.mock.$AsyncCallbackDecorator);
  $provide.decorator(&#x27;$rootScope&#x27;, angular.mock.$RootScopeDecorator);
}]);

/**
 * @ngdoc module
 * @name ngMockE2E
 * @module ngMockE2E
 * @packageName angular-mocks
 * @description
 *
 * The &#x60;ngMockE2E&#x60; is an angular module which contains mocks suitable for end-to-end testing.
 * Currently there is only one mock present in this module -
 * the {@link ngMockE2E.$httpBackend e2e $httpBackend} mock.
 */
angular.module(&#x27;ngMockE2E&#x27;, [&#x27;ng&#x27;]).config([&#x27;$provide&#x27;, function($provide) {
  $provide.decorator(&#x27;$httpBackend&#x27;, angular.mock.e2e.$httpBackendDecorator);
}]);

/**
 * @ngdoc service
 * @name $httpBackend
 * @module ngMockE2E
 * @description
 * Fake HTTP backend implementation suitable for end-to-end testing or backend-less development of
 * applications that use the {@link ng.$http $http service}.
 *
 * *Note*: For fake http backend implementation suitable for unit testing please see
 * {@link ngMock.$httpBackend unit-testing $httpBackend mock}.
 *
 * This implementation can be used to respond with static or dynamic responses via the &#x60;when&#x60; api
 * and its shortcuts (&#x60;whenGET&#x60;, &#x60;whenPOST&#x60;, etc) and optionally pass through requests to the
 * real $httpBackend for specific requests (e.g. to interact with certain remote apis or to fetch
 * templates from a webserver).
 *
 * As opposed to unit-testing, in an end-to-end testing scenario or in scenario when an application
 * is being developed with the real backend api replaced with a mock, it is often desirable for
 * certain category of requests to bypass the mock and issue a real http request (e.g. to fetch
 * templates or static files from the webserver). To configure the backend with this behavior
 * use the &#x60;passThrough&#x60; request handler of &#x60;when&#x60; instead of &#x60;respond&#x60;.
 *
 * Additionally, we don&#x27;t want to manually have to flush mocked out requests like we do during unit
 * testing. For this reason the e2e $httpBackend flushes mocked out requests
 * automatically, closely simulating the behavior of the XMLHttpRequest object.
 *
 * To setup the application to run with this http backend, you have to create a module that depends
 * on the &#x60;ngMockE2E&#x60; and your application modules and defines the fake backend:
 *
 * &#x60;&#x60;&#x60;js
 *   myAppDev = angular.module(&#x27;myAppDev&#x27;, [&#x27;myApp&#x27;, &#x27;ngMockE2E&#x27;]);
 *   myAppDev.run(function($httpBackend) {
 *     phones = [{name: &#x27;phone1&#x27;}, {name: &#x27;phone2&#x27;}];
 *
 *     // returns the current list of phones
 *     $httpBackend.whenGET(&#x27;/phones&#x27;).respond(phones);
 *
 *     // adds a new phone to the phones array
 *     $httpBackend.whenPOST(&#x27;/phones&#x27;).respond(function(method, url, data) {
 *       var phone = angular.fromJson(data);
 *       phones.push(phone);
 *       return [200, phone, {}];
 *     });
 *     $httpBackend.whenGET(/^\/templates\//).passThrough();
 *     //...
 *   });
 * &#x60;&#x60;&#x60;
 *
 * Afterwards, bootstrap your app with this new module.
 */

/**
 * @ngdoc method
 * @name $httpBackend#when
 * @module ngMockE2E
 * @description
 * Creates a new backend definition.
 *
 * @param {string} method HTTP method.
 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
 *   and returns true if the url match the current definition.
 * @param {(string|RegExp)=} data HTTP request body.
 * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header
 *   object and returns true if the headers match the current definition.
 * @returns {requestHandler} Returns an object with &#x60;respond&#x60; and &#x60;passThrough&#x60; methods that
 *   control how a matched request is handled. You can save this object for later use and invoke
 *   &#x60;respond&#x60; or &#x60;passThrough&#x60; again in order to change how a matched request is handled.
 *
 *  - respond –
 *    &#x60;{function([status,] data[, headers, statusText])
 *    | function(function(method, url, data, headers)}&#x60;
 *    – The respond method takes a set of static data to be returned or a function that can return
 *    an array containing response status (number), response data (string), response headers
 *    (Object), and the text for the status (string).
 *  - passThrough – &#x60;{function()}&#x60; – Any request matching a backend definition with
 *    &#x60;passThrough&#x60; handler will be passed through to the real backend (an XHR request will be made
 *    to the server.)
 *  - Both methods return the &#x60;requestHandler&#x60; object for possible overrides.
 */

/**
 * @ngdoc method
 * @name $httpBackend#whenGET
 * @module ngMockE2E
 * @description
 * Creates a new backend definition for GET requests. For more info see &#x60;when()&#x60;.
 *
 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
 *   and returns true if the url match the current definition.
 * @param {(Object|function(Object))=} headers HTTP headers.
 * @returns {requestHandler} Returns an object with &#x60;respond&#x60; and &#x60;passThrough&#x60; methods that
 *   control how a matched request is handled. You can save this object for later use and invoke
 *   &#x60;respond&#x60; or &#x60;passThrough&#x60; again in order to change how a matched request is handled.
 */

/**
 * @ngdoc method
 * @name $httpBackend#whenHEAD
 * @module ngMockE2E
 * @description
 * Creates a new backend definition for HEAD requests. For more info see &#x60;when()&#x60;.
 *
 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
 *   and returns true if the url match the current definition.
 * @param {(Object|function(Object))=} headers HTTP headers.
 * @returns {requestHandler} Returns an object with &#x60;respond&#x60; and &#x60;passThrough&#x60; methods that
 *   control how a matched request is handled. You can save this object for later use and invoke
 *   &#x60;respond&#x60; or &#x60;passThrough&#x60; again in order to change how a matched request is handled.
 */

/**
 * @ngdoc method
 * @name $httpBackend#whenDELETE
 * @module ngMockE2E
 * @description
 * Creates a new backend definition for DELETE requests. For more info see &#x60;when()&#x60;.
 *
 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
 *   and returns true if the url match the current definition.
 * @param {(Object|function(Object))=} headers HTTP headers.
 * @returns {requestHandler} Returns an object with &#x60;respond&#x60; and &#x60;passThrough&#x60; methods that
 *   control how a matched request is handled. You can save this object for later use and invoke
 *   &#x60;respond&#x60; or &#x60;passThrough&#x60; again in order to change how a matched request is handled.
 */

/**
 * @ngdoc method
 * @name $httpBackend#whenPOST
 * @module ngMockE2E
 * @description
 * Creates a new backend definition for POST requests. For more info see &#x60;when()&#x60;.
 *
 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
 *   and returns true if the url match the current definition.
 * @param {(string|RegExp)=} data HTTP request body.
 * @param {(Object|function(Object))=} headers HTTP headers.
 * @returns {requestHandler} Returns an object with &#x60;respond&#x60; and &#x60;passThrough&#x60; methods that
 *   control how a matched request is handled. You can save this object for later use and invoke
 *   &#x60;respond&#x60; or &#x60;passThrough&#x60; again in order to change how a matched request is handled.
 */

/**
 * @ngdoc method
 * @name $httpBackend#whenPUT
 * @module ngMockE2E
 * @description
 * Creates a new backend definition for PUT requests.  For more info see &#x60;when()&#x60;.
 *
 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
 *   and returns true if the url match the current definition.
 * @param {(string|RegExp)=} data HTTP request body.
 * @param {(Object|function(Object))=} headers HTTP headers.
 * @returns {requestHandler} Returns an object with &#x60;respond&#x60; and &#x60;passThrough&#x60; methods that
 *   control how a matched request is handled. You can save this object for later use and invoke
 *   &#x60;respond&#x60; or &#x60;passThrough&#x60; again in order to change how a matched request is handled.
 */

/**
 * @ngdoc method
 * @name $httpBackend#whenPATCH
 * @module ngMockE2E
 * @description
 * Creates a new backend definition for PATCH requests.  For more info see &#x60;when()&#x60;.
 *
 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
 *   and returns true if the url match the current definition.
 * @param {(string|RegExp)=} data HTTP request body.
 * @param {(Object|function(Object))=} headers HTTP headers.
 * @returns {requestHandler} Returns an object with &#x60;respond&#x60; and &#x60;passThrough&#x60; methods that
 *   control how a matched request is handled. You can save this object for later use and invoke
 *   &#x60;respond&#x60; or &#x60;passThrough&#x60; again in order to change how a matched request is handled.
 */

/**
 * @ngdoc method
 * @name $httpBackend#whenJSONP
 * @module ngMockE2E
 * @description
 * Creates a new backend definition for JSONP requests. For more info see &#x60;when()&#x60;.
 *
 * @param {string|RegExp|function(string)} url HTTP url or function that receives the url
 *   and returns true if the url match the current definition.
 * @returns {requestHandler} Returns an object with &#x60;respond&#x60; and &#x60;passThrough&#x60; methods that
 *   control how a matched request is handled. You can save this object for later use and invoke
 *   &#x60;respond&#x60; or &#x60;passThrough&#x60; again in order to change how a matched request is handled.
 */
angular.mock.e2e = {};
angular.mock.e2e.$httpBackendDecorator =
  [&#x27;$rootScope&#x27;, &#x27;$timeout&#x27;, &#x27;$delegate&#x27;, &#x27;$browser&#x27;, createHttpBackendMock];


/**
 * @ngdoc type
 * @name $rootScope.Scope
 * @module ngMock
 * @description
 * {@link ng.$rootScope.Scope Scope} type decorated with helper methods useful for testing. These
 * methods are automatically available on any {@link ng.$rootScope.Scope Scope} instance when
 * &#x60;ngMock&#x60; module is loaded.
 *
 * In addition to all the regular &#x60;Scope&#x60; methods, the following helper methods are available:
 */
angular.mock.$RootScopeDecorator = [&#x27;$delegate&#x27;, function($delegate) {

  var $rootScopePrototype = Object.getPrototypeOf($delegate);

  $rootScopePrototype.$countChildScopes = countChildScopes;
  $rootScopePrototype.$countWatchers = countWatchers;

  return $delegate;

  // ------------------------------------------------------------------------------------------ //

  /**
   * @ngdoc method
   * @name $rootScope.Scope#$countChildScopes
   * @module ngMock
   * @description
   * Counts all the direct and indirect child scopes of the current scope.
   *
   * The current scope is excluded from the count. The count includes all isolate child scopes.
   *
   * @returns {number} Total number of child scopes.
   */
  function countChildScopes() {
    // jshint validthis: true
    var count = 0; // exclude the current scope
    var pendingChildHeads = [this.$$childHead];
    var currentScope;

    while (pendingChildHeads.length) {
      currentScope = pendingChildHeads.shift();

      while (currentScope) {
        count += 1;
        pendingChildHeads.push(currentScope.$$childHead);
        currentScope = currentScope.$$nextSibling;
      }
    }

    return count;
  }


  /**
   * @ngdoc method
   * @name $rootScope.Scope#$countWatchers
   * @module ngMock
   * @description
   * Counts all the watchers of direct and indirect child scopes of the current scope.
   *
   * The watchers of the current scope are included in the count and so are all the watchers of
   * isolate child scopes.
   *
   * @returns {number} Total number of watchers.
   */
  function countWatchers() {
    // jshint validthis: true
    var count = this.$$watchers ? this.$$watchers.length : 0; // include the current scope
    var pendingChildHeads = [this.$$childHead];
    var currentScope;

    while (pendingChildHeads.length) {
      currentScope = pendingChildHeads.shift();

      while (currentScope) {
        count += currentScope.$$watchers ? currentScope.$$watchers.length : 0;
        pendingChildHeads.push(currentScope.$$childHead);
        currentScope = currentScope.$$nextSibling;
      }
    }

    return count;
  }
}];


if (window.jasmine || window.mocha) {

  var currentSpec = null,
      annotatedFunctions = [],
      isSpecRunning = function() {
        return !!currentSpec;
      };

  angular.mock.$$annotate = angular.injector.$$annotate;
  angular.injector.$$annotate = function(fn) {
    if (typeof fn === &#x27;function&#x27; &amp;&amp; !fn.$inject) {
      annotatedFunctions.push(fn);
    }
    return angular.mock.$$annotate.apply(this, arguments);
  };


  (window.beforeEach || window.setup)(function() {
    annotatedFunctions = [];
    currentSpec = this;
  });

  (window.afterEach || window.teardown)(function() {
    var injector = currentSpec.$injector;

    annotatedFunctions.forEach(function(fn) {
      delete fn.$inject;
    });

    angular.forEach(currentSpec.$modules, function(module) {
      if (module &amp;&amp; module.$$hashKey) {
        module.$$hashKey = undefined;
      }
    });

    currentSpec.$injector = null;
    currentSpec.$modules = null;
    currentSpec = null;

    if (injector) {
      injector.get(&#x27;$rootElement&#x27;).off();
      injector.get(&#x27;$browser&#x27;).pollFns.length = 0;
    }

    // clean up jquery&#x27;s fragment cache
    angular.forEach(angular.element.fragments, function(val, key) {
      delete angular.element.fragments[key];
    });

    MockXhr.$$lastInstance = null;

    angular.forEach(angular.callbacks, function(val, key) {
      delete angular.callbacks[key];
    });
    angular.callbacks.counter = 0;
  });

  /**
   * @ngdoc function
   * @name angular.mock.module
   * @description
   *
   * *NOTE*: This function is also published on window for easy access.&lt;br&gt;
   * *NOTE*: This function is declared ONLY WHEN running tests with jasmine or mocha
   *
   * This function registers a module configuration code. It collects the configuration information
   * which will be used when the injector is created by {@link angular.mock.inject inject}.
   *
   * See {@link angular.mock.inject inject} for usage example
   *
   * @param {...(string|Function|Object)} fns any number of modules which are represented as string
   *        aliases or as anonymous module initialization functions. The modules are used to
   *        configure the injector. The &#x27;ng&#x27; and &#x27;ngMock&#x27; modules are automatically loaded. If an
   *        object literal is passed they will be registered as values in the module, the key being
   *        the module name and the value being what is returned.
   */
  window.module = angular.mock.module = function() {
    var moduleFns = Array.prototype.slice.call(arguments, 0);
    return isSpecRunning() ? workFn() : workFn;
    /////////////////////
    function workFn() {
      if (currentSpec.$injector) {
        throw new Error(&#x27;Injector already created, can not register a module!&#x27;);
      } else {
        var modules = currentSpec.$modules || (currentSpec.$modules = []);
        angular.forEach(moduleFns, function(module) {
          if (angular.isObject(module) &amp;&amp; !angular.isArray(module)) {
            modules.push(function($provide) {
              angular.forEach(module, function(value, key) {
                $provide.value(key, value);
              });
            });
          } else {
            modules.push(module);
          }
        });
      }
    }
  };

  /**
   * @ngdoc function
   * @name angular.mock.inject
   * @description
   *
   * *NOTE*: This function is also published on window for easy access.&lt;br&gt;
   * *NOTE*: This function is declared ONLY WHEN running tests with jasmine or mocha
   *
   * The inject function wraps a function into an injectable function. The inject() creates new
   * instance of {@link auto.$injector $injector} per test, which is then used for
   * resolving references.
   *
   *
   * ## Resolving References (Underscore Wrapping)
   * Often, we would like to inject a reference once, in a &#x60;beforeEach()&#x60; block and reuse this
   * in multiple &#x60;it()&#x60; clauses. To be able to do this we must assign the reference to a variable
   * that is declared in the scope of the &#x60;describe()&#x60; block. Since we would, most likely, want
   * the variable to have the same name of the reference we have a problem, since the parameter
   * to the &#x60;inject()&#x60; function would hide the outer variable.
   *
   * To help with this, the injected parameters can, optionally, be enclosed with underscores.
   * These are ignored by the injector when the reference name is resolved.
   *
   * For example, the parameter &#x60;_myService_&#x60; would be resolved as the reference &#x60;myService&#x60;.
   * Since it is available in the function body as _myService_, we can then assign it to a variable
   * defined in an outer scope.
   *
   * &#x60;&#x60;&#x60;
   * // Defined out reference variable outside
   * var myService;
   *
   * // Wrap the parameter in underscores
   * beforeEach( inject( function(_myService_){
   *   myService = _myService_;
   * }));
   *
   * // Use myService in a series of tests.
   * it(&#x27;makes use of myService&#x27;, function() {
   *   myService.doStuff();
   * });
   *
   * &#x60;&#x60;&#x60;
   *
   * See also {@link angular.mock.module angular.mock.module}
   *
   * ## Example
   * Example of what a typical jasmine tests looks like with the inject method.
   * &#x60;&#x60;&#x60;js
   *
   *   angular.module(&#x27;myApplicationModule&#x27;, [])
   *       .value(&#x27;mode&#x27;, &#x27;app&#x27;)
   *       .value(&#x27;version&#x27;, &#x27;v1.0.1&#x27;);
   *
   *
   *   describe(&#x27;MyApp&#x27;, function() {
   *
   *     // You need to load modules that you want to test,
   *     // it loads only the &quot;ng&quot; module by default.
   *     beforeEach(module(&#x27;myApplicationModule&#x27;));
   *
   *
   *     // inject() is used to inject arguments of all given functions
   *     it(&#x27;should provide a version&#x27;, inject(function(mode, version) {
   *       expect(version).toEqual(&#x27;v1.0.1&#x27;);
   *       expect(mode).toEqual(&#x27;app&#x27;);
   *     }));
   *
   *
   *     // The inject and module method can also be used inside of the it or beforeEach
   *     it(&#x27;should override a version and test the new version is injected&#x27;, function() {
   *       // module() takes functions or strings (module aliases)
   *       module(function($provide) {
   *         $provide.value(&#x27;version&#x27;, &#x27;overridden&#x27;); // override version here
   *       });
   *
   *       inject(function(version) {
   *         expect(version).toEqual(&#x27;overridden&#x27;);
   *       });
   *     });
   *   });
   *
   * &#x60;&#x60;&#x60;
   *
   * @param {...Function} fns any number of functions which will be injected using the injector.
   */



  var ErrorAddingDeclarationLocationStack = function(e, errorForStack) {
    this.message = e.message;
    this.name = e.name;
    if (e.line) this.line = e.line;
    if (e.sourceId) this.sourceId = e.sourceId;
    if (e.stack &amp;&amp; errorForStack)
      this.stack = e.stack + &#x27;\n&#x27; + errorForStack.stack;
    if (e.stackArray) this.stackArray = e.stackArray;
  };
  ErrorAddingDeclarationLocationStack.prototype.toString = Error.prototype.toString;

  window.inject = angular.mock.inject = function() {
    var blockFns = Array.prototype.slice.call(arguments, 0);
    var errorForStack = new Error(&#x27;Declaration Location&#x27;);
    return isSpecRunning() ? workFn.call(currentSpec) : workFn;
    /////////////////////
    function workFn() {
      var modules = currentSpec.$modules || [];
      var strictDi = !!currentSpec.$injectorStrict;
      modules.unshift(&#x27;ngMock&#x27;);
      modules.unshift(&#x27;ng&#x27;);
      var injector = currentSpec.$injector;
      if (!injector) {
        if (strictDi) {
          // If strictDi is enabled, annotate the providerInjector blocks
          angular.forEach(modules, function(moduleFn) {
            if (typeof moduleFn === &quot;function&quot;) {
              angular.injector.$$annotate(moduleFn);
            }
          });
        }
        injector = currentSpec.$injector = angular.injector(modules, strictDi);
        currentSpec.$injectorStrict = strictDi;
      }
      for (var i = 0, ii = blockFns.length; i &lt; ii; i++) {
        if (currentSpec.$injectorStrict) {
          // If the injector is strict / strictDi, and the spec wants to inject using automatic
          // annotation, then annotate the function here.
          injector.annotate(blockFns[i]);
        }
        try {
          /* jshint -W040 *//* Jasmine explicitly provides a &#x60;this&#x60; object when calling functions */
          injector.invoke(blockFns[i] || angular.noop, this);
          /* jshint +W040 */
        } catch (e) {
          if (e.stack &amp;&amp; errorForStack) {
            throw new ErrorAddingDeclarationLocationStack(e, errorForStack);
          }
          throw e;
        } finally {
          errorForStack = null;
        }
      }
    }
  };


  angular.mock.inject.strictDi = function(value) {
    value = arguments.length ? !!value : true;
    return isSpecRunning() ? workFn() : workFn;

    function workFn() {
      if (value !== currentSpec.$injectorStrict) {
        if (currentSpec.$injector) {
          throw new Error(&#x27;Injector already created, can not modify strict annotations&#x27;);
        } else {
          currentSpec.$injectorStrict = value;
        }
      }
    }
  };
}


})(window, window.angular);

    </pre>
</div>

                </div>
            </div>
        </div>
    </div>
<a id="gotoTop" class='well well-small' href='#'>
    Top
</a>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.min.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/config.js"></script>
<script src="../assets/js/doc.js"></script>
</body>
</html>
