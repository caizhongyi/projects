<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>..\node_modules\webuploader-0.1.5\webuploader.withoutimage.js - SmartDoc</title>
  
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.min.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-smart">
 <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container-fluid">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
               <a class="navbar-brand mainlogo" href="https://github.com/zhh77/smartdoc">
             
            <img alt="SmartDoc" src="../assets/css/logo.png" title="SmartDoc">
            
                SmartDoc
          </a>
            </div>
            <div id="navbar" class="navbar-collapse collapse">
                 <ul class="nav navbar-nav">
                    
                    <li><a href="https://github.com/zhh77/smartdoc">Home</a>
                    </li>
                    
                    <li><a href="/">Document</a>
                    </li>
                    
                    <li><a href="https://github.com/zhh77/smartdoc">About</a>
                    </li>
                    
                </ul>
               <div class="navbar-form navbar-right filterAPi" autocomplete="off">
                <input type="text" id='txtSearchAPI' class="form-control search-query" placeholder="Search for API" />
                 <ul id="filterList" class="filterItems dropdown-menu" role="menu"></ul>
                </div>
            </div>
        </div>
    </nav>
    <div id="sidebar">
    <h3>Modules/Classes</h3>
        <div id="api-tabview-filter">
            <input id='txtSearch' type="search" class="form-control" placeholder="Type to filter Modules/Classes">
        </div>
        <dl id="sidebar_list">
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/273.html">273</a>
                </dt>
                <dd>
                    <ul>
                   
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/alienjs.html">alienjs</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/window.require.html">window.require</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/Countdown.html">Countdown</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/Date.html">Date</a>
                </dt>
                <dd>
                    <ul>
                   
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/jquery.html">jquery</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/jquery.transitionEnd.html">jquery.transitionEnd</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.support.transition.html">jquery.support.transition</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.animationEnd.html">jquery.animationEnd</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/jquery-ui.html">jquery-ui</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/jquery.ajaxPanel.html">jquery.ajaxPanel</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.dialog.html">jquery.dialog</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/Array.html">Array</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.browserLowVersion.html">jquery.browserLowVersion</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.confirm.html">jquery.confirm</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.alert.html">jquery.alert</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/ng.html">ng</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/EventEmitter Manages event registering and emitting..html">EventEmitter Manages event registering and emitting.</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/ngMock.html">ngMock</a>
                </dt>
                <dd>
                    <ul>
                   
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/ngMockE2E.html">ngMockE2E</a>
                </dt>
                <dd>
                    <ul>
                   
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/ui.html">ui</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/AjaxPanel.html">AjaxPanel</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/Date.Dialog.html">Date.Dialog</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/WebUploader.html">WebUploader</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/Base.html">Base</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/Mediator.html">Mediator</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/options.Uploader.html">options.Uploader</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/File.File.html">File.File</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/File.Queue.html">File.Queue</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/Uploader.html">Uploader</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/window.html">window</a>
                </dt>
                <dd>
                    <ul>
                   
                    </ul>
                </dd>
             
        </dl>
</div>
   
    <div class="stdoc-content">
        <!--     <form id="options-form" class="form-inline pull-right">
        Show:
        <label for="api-show-inherited" class="checkbox">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected" class="checkbox">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private" class="checkbox">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated" class="checkbox">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </form>

 -->
        <div class="apidocs">
            <div id="docs-main">
                <div class="content">
                    <div class="page-header">
    <h1>..\node_modules\webuploader-0.1.5\webuploader.withoutimage.js <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums" id='src_code'>
/*! WebUploader 0.1.5 */


/**
 * @fileOverview 让内部各个部件的代码可以用[amd](https://github.com/amdjs/amdjs-api/wiki/AMD)模块定义方式组织起来。
 *
 * AMD API 内部的简单不完全实现，请忽略。只有当WebUploader被合并成一个文件的时候才会引入。
 */
(function( root, factory ) {
    var modules = {},

        // 内部require, 简单不完全实现。
        // https://github.com/amdjs/amdjs-api/wiki/require
        _require = function( deps, callback ) {
            var args, len, i;

            // 如果deps不是数组，则直接返回指定module
            if ( typeof deps === &#x27;string&#x27; ) {
                return getModule( deps );
            } else {
                args = [];
                for( len = deps.length, i = 0; i &lt; len; i++ ) {
                    args.push( getModule( deps[ i ] ) );
                }

                return callback.apply( null, args );
            }
        },

        // 内部define，暂时不支持不指定id.
        _define = function( id, deps, factory ) {
            if ( arguments.length === 2 ) {
                factory = deps;
                deps = null;
            }

            _require( deps || [], function() {
                setModule( id, factory, arguments );
            });
        },

        // 设置module, 兼容CommonJs写法。
        setModule = function( id, factory, args ) {
            var module = {
                    exports: factory
                },
                returned;

            if ( typeof factory === &#x27;function&#x27; ) {
                args.length || (args = [ _require, module.exports, module ]);
                returned = factory.apply( null, args );
                returned !== undefined &amp;&amp; (module.exports = returned);
            }

            modules[ id ] = module.exports;
        },

        // 根据id获取module
        getModule = function( id ) {
            var module = modules[ id ] || root[ id ];

            if ( !module ) {
                throw new Error( &#x27;&#x60;&#x27; + id + &#x27;&#x60; is undefined&#x27; );
            }

            return module;
        },

        // 将所有modules，将路径ids装换成对象。
        exportsTo = function( obj ) {
            var key, host, parts, part, last, ucFirst;

            // make the first character upper case.
            ucFirst = function( str ) {
                return str &amp;&amp; (str.charAt( 0 ).toUpperCase() + str.substr( 1 ));
            };

            for ( key in modules ) {
                host = obj;

                if ( !modules.hasOwnProperty( key ) ) {
                    continue;
                }

                parts = key.split(&#x27;/&#x27;);
                last = ucFirst( parts.pop() );

                while( (part = ucFirst( parts.shift() )) ) {
                    host[ part ] = host[ part ] || {};
                    host = host[ part ];
                }

                host[ last ] = modules[ key ];
            }

            return obj;
        },

        makeExport = function( dollar ) {
            root.__dollar = dollar;

            // exports every module.
            return exportsTo( factory( root, _define, _require ) );
        },

        origin;

    if ( typeof module === &#x27;object&#x27; &amp;&amp; typeof module.exports === &#x27;object&#x27; ) {

        // For CommonJS and CommonJS-like environments where a proper window is present,
        module.exports = makeExport();
    } else if ( typeof define === &#x27;function&#x27; &amp;&amp; define.amd ) {

        // Allow using this built library as an AMD module
        // in another project. That other project will only
        // see this AMD call, not the internal modules in
        // the closure below.
        define([ &#x27;jquery&#x27; ], makeExport );
    } else {

        // Browser globals case. Just assign the
        // result to a property on the global.
        origin = root.WebUploader;
        root.WebUploader = makeExport();
        root.WebUploader.noConflict = function() {
            root.WebUploader = origin;
        };
    }
})( window, function( window, define, require ) {


    /**
     * @fileOverview jQuery or Zepto
     */
    define(&#x27;dollar-third&#x27;,[],function() {
        var $ = window.__dollar || window.jQuery || window.Zepto;
    
        if ( !$ ) {
            throw new Error(&#x27;jQuery or Zepto not found!&#x27;);
        }
    
        return $;
    });
    /**
     * @fileOverview Dom 操作相关
     */
    define(&#x27;dollar&#x27;,[
        &#x27;dollar-third&#x27;
    ], function( _ ) {
        return _;
    });
    /**
     * @fileOverview 使用jQuery的Promise
     */
    define(&#x27;promise-third&#x27;,[
        &#x27;dollar&#x27;
    ], function( $ ) {
        return {
            Deferred: $.Deferred,
            when: $.when,
    
            isPromise: function( anything ) {
                return anything &amp;&amp; typeof anything.then === &#x27;function&#x27;;
            }
        };
    });
    /**
     * @fileOverview Promise/A+
     */
    define(&#x27;promise&#x27;,[
        &#x27;promise-third&#x27;
    ], function( _ ) {
        return _;
    });
    /**
     * @fileOverview 基础类方法。
     */
    
    /**
     * Web Uploader内部类的详细说明，以下提及的功能类，都可以在&#x60;WebUploader&#x60;这个变量中访问到。
     *
     * As you know, Web Uploader的每个文件都是用过[AMD](https://github.com/amdjs/amdjs-api/wiki/AMD)规范中的&#x60;define&#x60;组织起来的, 每个Module都会有个module id.
     * 默认module id为该文件的路径，而此路径将会转化成名字空间存放在WebUploader中。如：
     *
     * * module &#x60;base&#x60;：WebUploader.Base
     * * module &#x60;file&#x60;: WebUploader.File
     * * module &#x60;lib/dnd&#x60;: WebUploader.Lib.Dnd
     * * module &#x60;runtime/html5/dnd&#x60;: WebUploader.Runtime.Html5.Dnd
     *
     *
     * 以下文档中对类的使用可能省略掉了&#x60;WebUploader&#x60;前缀。
     * @module WebUploader
     * @title WebUploader API文档
     */
    define(&#x27;base&#x27;,[
        &#x27;dollar&#x27;,
        &#x27;promise&#x27;
    ], function( $, promise ) {
    
        var noop = function() {},
            call = Function.call;
    
        // http://jsperf.com/uncurrythis
        // 反科里化
        function uncurryThis( fn ) {
            return function() {
                return call.apply( fn, arguments );
            };
        }
    
        function bindFn( fn, context ) {
            return function() {
                return fn.apply( context, arguments );
            };
        }
    
        function createObject( proto ) {
            var f;
    
            if ( Object.create ) {
                return Object.create( proto );
            } else {
                f = function() {};
                f.prototype = proto;
                return new f();
            }
        }
    
    
        /**
         * 基础类，提供一些简单常用的方法。
         * @class Base
         */
        return {
    
            /**
             * @property {String} version 当前版本号。
             */
            version: &#x27;0.1.5&#x27;,
    
            /**
             * @property {jQuery|Zepto} $ 引用依赖的jQuery或者Zepto对象。
             */
            $: $,
    
            Deferred: promise.Deferred,
    
            isPromise: promise.isPromise,
    
            when: promise.when,
    
            /**
             * @description  简单的浏览器检查结果。
             *
             * * &#x60;webkit&#x60;  webkit版本号，如果浏览器为非webkit内核，此属性为&#x60;undefined&#x60;。
             * * &#x60;chrome&#x60;  chrome浏览器版本号，如果浏览器为chrome，此属性为&#x60;undefined&#x60;。
             * * &#x60;ie&#x60;  ie浏览器版本号，如果浏览器为非ie，此属性为&#x60;undefined&#x60;。**暂不支持ie10+**
             * * &#x60;firefox&#x60;  firefox浏览器版本号，如果浏览器为非firefox，此属性为&#x60;undefined&#x60;。
             * * &#x60;safari&#x60;  safari浏览器版本号，如果浏览器为非safari，此属性为&#x60;undefined&#x60;。
             * * &#x60;opera&#x60;  opera浏览器版本号，如果浏览器为非opera，此属性为&#x60;undefined&#x60;。
             *
             * @property {Object} [browser]
             */
            browser: (function( ua ) {
                var ret = {},
                    webkit = ua.match( /WebKit\/([\d.]+)/ ),
                    chrome = ua.match( /Chrome\/([\d.]+)/ ) ||
                        ua.match( /CriOS\/([\d.]+)/ ),
    
                    ie = ua.match( /MSIE\s([\d\.]+)/ ) ||
                        ua.match( /(?:trident)(?:.*rv:([\w.]+))?/i ),
                    firefox = ua.match( /Firefox\/([\d.]+)/ ),
                    safari = ua.match( /Safari\/([\d.]+)/ ),
                    opera = ua.match( /OPR\/([\d.]+)/ );
    
                webkit &amp;&amp; (ret.webkit = parseFloat( webkit[ 1 ] ));
                chrome &amp;&amp; (ret.chrome = parseFloat( chrome[ 1 ] ));
                ie &amp;&amp; (ret.ie = parseFloat( ie[ 1 ] ));
                firefox &amp;&amp; (ret.firefox = parseFloat( firefox[ 1 ] ));
                safari &amp;&amp; (ret.safari = parseFloat( safari[ 1 ] ));
                opera &amp;&amp; (ret.opera = parseFloat( opera[ 1 ] ));
    
                return ret;
            })( navigator.userAgent ),
    
            /**
             * @description  操作系统检查结果。
             *
             * * &#x60;android&#x60;  如果在android浏览器环境下，此值为对应的android版本号，否则为&#x60;undefined&#x60;。
             * * &#x60;ios&#x60; 如果在ios浏览器环境下，此值为对应的ios版本号，否则为&#x60;undefined&#x60;。
             * @property {Object} [os]
             */
            os: (function( ua ) {
                var ret = {},
    
                    // osx = !!ua.match( /\(Macintosh\; Intel / ),
                    android = ua.match( /(?:Android);?[\s\/]+([\d.]+)?/ ),
                    ios = ua.match( /(?:iPad|iPod|iPhone).*OS\s([\d_]+)/ );
    
                // osx &amp;&amp; (ret.osx = true);
                android &amp;&amp; (ret.android = parseFloat( android[ 1 ] ));
                ios &amp;&amp; (ret.ios = parseFloat( ios[ 1 ].replace( /_/g, &#x27;.&#x27; ) ));
    
                return ret;
            })( navigator.userAgent ),
    
            /**
             * 实现类与类之间的继承。
             * @method inherits
             * @grammar Base.inherits( super ) =&gt; child
             * @grammar Base.inherits( super, protos ) =&gt; child
             * @grammar Base.inherits( super, protos, statics ) =&gt; child
             * @param  {Class} super 父类
             * @param  {Object | Function} [protos] 子类或者对象。如果对象中包含constructor，子类将是用此属性值。
             * @param  {Function} [protos.constructor] 子类构造器，不指定的话将创建个临时的直接执行父类构造器的方法。
             * @param  {Object} [statics] 静态属性或方法。
             * @return {Class} 返回子类。
             * @example
             * function Person() {
             *     console.log( &#x27;Super&#x27; );
             * }
             * Person.prototype.hello = function() {
             *     console.log( &#x27;hello&#x27; );
             * };
             *
             * var Manager = Base.inherits( Person, {
             *     world: function() {
             *         console.log( &#x27;World&#x27; );
             *     }
             * });
             *
             * // 因为没有指定构造器，父类的构造器将会执行。
             * var instance = new Manager();    // =&gt; Super
             *
             * // 继承子父类的方法
             * instance.hello();    // =&gt; hello
             * instance.world();    // =&gt; World
             *
             * // 子类的__super__属性指向父类
             * console.log( Manager.__super__ === Person );    // =&gt; true
             */
            inherits: function( Super, protos, staticProtos ) {
                var child;
    
                if ( typeof protos === &#x27;function&#x27; ) {
                    child = protos;
                    protos = null;
                } else if ( protos &amp;&amp; protos.hasOwnProperty(&#x27;constructor&#x27;) ) {
                    child = protos.constructor;
                } else {
                    child = function() {
                        return Super.apply( this, arguments );
                    };
                }
    
                // 复制静态方法
                $.extend( true, child, Super, staticProtos || {} );
    
                /* jshint camelcase: false */
    
                // 让子类的__super__属性指向父类。
                child.__super__ = Super.prototype;
    
                // 构建原型，添加原型方法或属性。
                // 暂时用Object.create实现。
                child.prototype = createObject( Super.prototype );
                protos &amp;&amp; $.extend( true, child.prototype, protos );
    
                return child;
            },
    
            /**
             * 一个不做任何事情的方法。可以用来赋值给默认的callback.
             * @method noop
             */
            noop: noop,
    
            /**
             * 返回一个新的方法，此方法将已指定的&#x60;context&#x60;来执行。
             * @grammar Base.bindFn( fn, context ) =&gt; Function
             * @method bindFn
             * @example
             * var doSomething = function() {
             *         console.log( this.name );
             *     },
             *     obj = {
             *         name: &#x27;Object Name&#x27;
             *     },
             *     aliasFn = Base.bind( doSomething, obj );
             *
             *  aliasFn();    // =&gt; Object Name
             *
             */
            bindFn: bindFn,
    
            /**
             * 引用Console.log如果存在的话，否则引用一个[空函数noop](#WebUploader:Base.noop)。
             * @grammar Base.log( args... ) =&gt; undefined
             * @method log
             */
            log: (function() {
                if ( window.console ) {
                    return bindFn( console.log, console );
                }
                return noop;
            })(),
    
            nextTick: (function() {
    
                return function( cb ) {
                    setTimeout( cb, 1 );
                };
    
                // @bug 当浏览器不在当前窗口时就停了。
                // var next = window.requestAnimationFrame ||
                //     window.webkitRequestAnimationFrame ||
                //     window.mozRequestAnimationFrame ||
                //     function( cb ) {
                //         window.setTimeout( cb, 1000 / 60 );
                //     };
    
                // // fix: Uncaught TypeError: Illegal invocation
                // return bindFn( next, window );
            })(),
    
            /**
             * 被[uncurrythis](http://www.2ality.com/2011/11/uncurrying-this.html)的数组slice方法。
             * 将用来将非数组对象转化成数组对象。
             * @grammar Base.slice( target, start[, end] ) =&gt; Array
             * @method slice
             * @example
             * function doSomthing() {
             *     var args = Base.slice( arguments, 1 );
             *     console.log( args );
             * }
             *
             * doSomthing( &#x27;ignored&#x27;, &#x27;arg2&#x27;, &#x27;arg3&#x27; );    // =&gt; Array [&quot;arg2&quot;, &quot;arg3&quot;]
             */
            slice: uncurryThis( [].slice ),
    
            /**
             * 生成唯一的ID
             * @method guid
             * @grammar Base.guid() =&gt; String
             * @grammar Base.guid( prefx ) =&gt; String
             */
            guid: (function() {
                var counter = 0;
    
                return function( prefix ) {
                    var guid = (+new Date()).toString( 32 ),
                        i = 0;
    
                    for ( ; i &lt; 5; i++ ) {
                        guid += Math.floor( Math.random() * 65535 ).toString( 32 );
                    }
    
                    return (prefix || &#x27;wu_&#x27;) + guid + (counter++).toString( 32 );
                };
            })(),
    
            /**
             * 格式化文件大小, 输出成带单位的字符串
             * @method formatSize
             * @grammar Base.formatSize( size ) =&gt; String
             * @grammar Base.formatSize( size, pointLength ) =&gt; String
             * @grammar Base.formatSize( size, pointLength, units ) =&gt; String
             * @param {Number} size 文件大小
             * @param {Number} [pointLength=2] 精确到的小数点数。
             * @param {Array} [units=[ &#x27;B&#x27;, &#x27;K&#x27;, &#x27;M&#x27;, &#x27;G&#x27;, &#x27;TB&#x27; ]] 单位数组。从字节，到千字节，一直往上指定。如果单位数组里面只指定了到了K(千字节)，同时文件大小大于M, 此方法的输出将还是显示成多少K.
             * @example
             * console.log( Base.formatSize( 100 ) );    // =&gt; 100B
             * console.log( Base.formatSize( 1024 ) );    // =&gt; 1.00K
             * console.log( Base.formatSize( 1024, 0 ) );    // =&gt; 1K
             * console.log( Base.formatSize( 1024 * 1024 ) );    // =&gt; 1.00M
             * console.log( Base.formatSize( 1024 * 1024 * 1024 ) );    // =&gt; 1.00G
             * console.log( Base.formatSize( 1024 * 1024 * 1024, 0, [&#x27;B&#x27;, &#x27;KB&#x27;, &#x27;MB&#x27;] ) );    // =&gt; 1024MB
             */
            formatSize: function( size, pointLength, units ) {
                var unit;
    
                units = units || [ &#x27;B&#x27;, &#x27;K&#x27;, &#x27;M&#x27;, &#x27;G&#x27;, &#x27;TB&#x27; ];
    
                while ( (unit = units.shift()) &amp;&amp; size &gt; 1024 ) {
                    size = size / 1024;
                }
    
                return (unit === &#x27;B&#x27; ? size : size.toFixed( pointLength || 2 )) +
                        unit;
            }
        };
    });
    /**
     * 事件处理类，可以独立使用，也可以扩展给对象使用。
     * @fileOverview Mediator
     */
    define(&#x27;mediator&#x27;,[
        &#x27;base&#x27;
    ], function( Base ) {
        var $ = Base.$,
            slice = [].slice,
            separator = /\s+/,
            protos;
    
        // 根据条件过滤出事件handlers.
        function findHandlers( arr, name, callback, context ) {
            return $.grep( arr, function( handler ) {
                return handler &amp;&amp;
                        (!name || handler.e === name) &amp;&amp;
                        (!callback || handler.cb === callback ||
                        handler.cb._cb === callback) &amp;&amp;
                        (!context || handler.ctx === context);
            });
        }
    
        function eachEvent( events, callback, iterator ) {
            // 不支持对象，只支持多个event用空格隔开
            $.each( (events || &#x27;&#x27;).split( separator ), function( _, key ) {
                iterator( key, callback );
            });
        }
    
        function triggerHanders( events, args ) {
            var stoped = false,
                i = -1,
                len = events.length,
                handler;
    
            while ( ++i &lt; len ) {
                handler = events[ i ];
    
                if ( handler.cb.apply( handler.ctx2, args ) === false ) {
                    stoped = true;
                    break;
                }
            }
    
            return !stoped;
        }
    
        protos = {
    
            /**
             * 绑定事件。
             *
             * &#x60;callback&#x60;方法在执行时，arguments将会来源于trigger的时候携带的参数。如
             * &#x60;&#x60;&#x60;javascript
             * var obj = {};
             *
             * // 使得obj有事件行为
             * Mediator.installTo( obj );
             *
             * obj.on( &#x27;testa&#x27;, function( arg1, arg2 ) {
             *     console.log( arg1, arg2 ); // =&gt; &#x27;arg1&#x27;, &#x27;arg2&#x27;
             * });
             *
             * obj.trigger( &#x27;testa&#x27;, &#x27;arg1&#x27;, &#x27;arg2&#x27; );
             * &#x60;&#x60;&#x60;
             *
             * 如果&#x60;callback&#x60;中，某一个方法&#x60;return false&#x60;了，则后续的其他&#x60;callback&#x60;都不会被执行到。
             * 切会影响到&#x60;trigger&#x60;方法的返回值，为&#x60;false&#x60;。
             *
             * &#x60;on&#x60;还可以用来添加一个特殊事件&#x60;all&#x60;, 这样所有的事件触发都会响应到。同时此类&#x60;callback&#x60;中的arguments有一个不同处，
             * 就是第一个参数为&#x60;type&#x60;，记录当前是什么事件在触发。此类&#x60;callback&#x60;的优先级比脚低，会再正常&#x60;callback&#x60;执行完后触发。
             * &#x60;&#x60;&#x60;javascript
             * obj.on( &#x27;all&#x27;, function( type, arg1, arg2 ) {
             *     console.log( type, arg1, arg2 ); // =&gt; &#x27;testa&#x27;, &#x27;arg1&#x27;, &#x27;arg2&#x27;
             * });
             * &#x60;&#x60;&#x60;
             *
             * @method on
             * @grammar on( name, callback[, context] ) =&gt; self
             * @param  {String}   name     事件名，支持多个事件用空格隔开
             * @param  {Function} callback 事件处理器
             * @param  {Object}   [context]  事件处理器的上下文。
             * @return {self} 返回自身，方便链式
             * @chainable
             * @class Mediator
             */
            on: function( name, callback, context ) {
                var me = this,
                    set;
    
                if ( !callback ) {
                    return this;
                }
    
                set = this._events || (this._events = []);
    
                eachEvent( name, callback, function( name, callback ) {
                    var handler = { e: name };
    
                    handler.cb = callback;
                    handler.ctx = context;
                    handler.ctx2 = context || me;
                    handler.id = set.length;
    
                    set.push( handler );
                });
    
                return this;
            },
    
            /**
             * 绑定事件，且当handler执行完后，自动解除绑定。
             * @method once
             * @grammar once( name, callback[, context] ) =&gt; self
             * @param  {String}   name     事件名
             * @param  {Function} callback 事件处理器
             * @param  {Object}   [context]  事件处理器的上下文。
             * @return {self} 返回自身，方便链式
             * @chainable
             */
            once: function( name, callback, context ) {
                var me = this;
    
                if ( !callback ) {
                    return me;
                }
    
                eachEvent( name, callback, function( name, callback ) {
                    var once = function() {
                            me.off( name, once );
                            return callback.apply( context || me, arguments );
                        };
    
                    once._cb = callback;
                    me.on( name, once, context );
                });
    
                return me;
            },
    
            /**
             * 解除事件绑定
             * @method off
             * @grammar off( [name[, callback[, context] ] ] ) =&gt; self
             * @param  {String}   [name]     事件名
             * @param  {Function} [callback] 事件处理器
             * @param  {Object}   [context]  事件处理器的上下文。
             * @return {self} 返回自身，方便链式
             * @chainable
             */
            off: function( name, cb, ctx ) {
                var events = this._events;
    
                if ( !events ) {
                    return this;
                }
    
                if ( !name &amp;&amp; !cb &amp;&amp; !ctx ) {
                    this._events = [];
                    return this;
                }
    
                eachEvent( name, cb, function( name, cb ) {
                    $.each( findHandlers( events, name, cb, ctx ), function() {
                        delete events[ this.id ];
                    });
                });
    
                return this;
            },
    
            /**
             * 触发事件
             * @method trigger
             * @grammar trigger( name[, args...] ) =&gt; self
             * @param  {String}   type     事件名
             * @param  {*} [...] 任意参数
             * @return {Boolean} 如果handler中return false了，则返回false, 否则返回true
             */
            trigger: function( type ) {
                var args, events, allEvents;
    
                if ( !this._events || !type ) {
                    return this;
                }
    
                args = slice.call( arguments, 1 );
                events = findHandlers( this._events, type );
                allEvents = findHandlers( this._events, &#x27;all&#x27; );
    
                return triggerHanders( events, args ) &amp;&amp;
                        triggerHanders( allEvents, arguments );
            }
        };
    
        /**
         * 中介者，它本身是个单例，但可以通过[installTo](#WebUploader:Mediator:installTo)方法，使任何对象具备事件行为。
         * 主要目的是负责模块与模块之间的合作，降低耦合度。
         *
         * @class Mediator
         */
        return $.extend({
    
            /**
             * 可以通过这个接口，使任何对象具备事件功能。
             * @method installTo
             * @param  {Object} obj 需要具备事件行为的对象。
             * @return {Object} 返回obj.
             */
            installTo: function( obj ) {
                return $.extend( obj, protos );
            }
    
        }, protos );
    });
    /**
     * @fileOverview Uploader上传类
     */
    define(&#x27;uploader&#x27;,[
        &#x27;base&#x27;,
        &#x27;mediator&#x27;
    ], function( Base, Mediator ) {
    
        var $ = Base.$;
    
        /**
         * 上传入口类。
         * @class Uploader
         * @constructor
         * @grammar new Uploader( opts ) =&gt; Uploader
         * @example
         * var uploader = WebUploader.Uploader({
         *     swf: &#x27;path_of_swf/Uploader.swf&#x27;,
         *
         *     // 开起分片上传。
         *     chunked: true
         * });
         */
        function Uploader( opts ) {
            this.options = $.extend( true, {}, Uploader.options, opts );
            this._init( this.options );
        }
    
        // default Options
        // widgets中有相应扩展
        Uploader.options = {};
        Mediator.installTo( Uploader.prototype );
    
        // 批量添加纯命令式方法。
        $.each({
            upload: &#x27;start-upload&#x27;,
            stop: &#x27;stop-upload&#x27;,
            getFile: &#x27;get-file&#x27;,
            getFiles: &#x27;get-files&#x27;,
            addFile: &#x27;add-file&#x27;,
            addFiles: &#x27;add-file&#x27;,
            sort: &#x27;sort-files&#x27;,
            removeFile: &#x27;remove-file&#x27;,
            cancelFile: &#x27;cancel-file&#x27;,
            skipFile: &#x27;skip-file&#x27;,
            retry: &#x27;retry&#x27;,
            isInProgress: &#x27;is-in-progress&#x27;,
            makeThumb: &#x27;make-thumb&#x27;,
            md5File: &#x27;md5-file&#x27;,
            getDimension: &#x27;get-dimension&#x27;,
            addButton: &#x27;add-btn&#x27;,
            predictRuntimeType: &#x27;predict-runtime-type&#x27;,
            refresh: &#x27;refresh&#x27;,
            disable: &#x27;disable&#x27;,
            enable: &#x27;enable&#x27;,
            reset: &#x27;reset&#x27;
        }, function( fn, command ) {
            Uploader.prototype[ fn ] = function() {
                return this.request( command, arguments );
            };
        });
    
        $.extend( Uploader.prototype, {
            state: &#x27;pending&#x27;,
    
            _init: function( opts ) {
                var me = this;
    
                me.request( &#x27;init&#x27;, opts, function() {
                    me.state = &#x27;ready&#x27;;
                    me.trigger(&#x27;ready&#x27;);
                });
            },
    
            /**
             * 获取或者设置Uploader配置项。
             * @method option
             * @grammar option( key ) =&gt; *
             * @grammar option( key, val ) =&gt; self
             * @example
             *
             * // 初始状态图片上传前不会压缩
             * var uploader = new WebUploader.Uploader({
             *     compress: null;
             * });
             *
             * // 修改后图片上传前，尝试将图片压缩到1600 * 1600
             * uploader.option( &#x27;compress&#x27;, {
             *     width: 1600,
             *     height: 1600
             * });
             */
            option: function( key, val ) {
                var opts = this.options;
    
                // setter
                if ( arguments.length &gt; 1 ) {
    
                    if ( $.isPlainObject( val ) &amp;&amp;
                            $.isPlainObject( opts[ key ] ) ) {
                        $.extend( opts[ key ], val );
                    } else {
                        opts[ key ] = val;
                    }
    
                } else {    // getter
                    return key ? opts[ key ] : opts;
                }
            },
    
            /**
             * 获取文件统计信息。返回一个包含一下信息的对象。
             * * &#x60;successNum&#x60; 上传成功的文件数
             * * &#x60;progressNum&#x60; 上传中的文件数
             * * &#x60;cancelNum&#x60; 被删除的文件数
             * * &#x60;invalidNum&#x60; 无效的文件数
             * * &#x60;uploadFailNum&#x60; 上传失败的文件数
             * * &#x60;queueNum&#x60; 还在队列中的文件数
             * * &#x60;interruptNum&#x60; 被暂停的文件数
             * @method getStats
             * @grammar getStats() =&gt; Object
             */
            getStats: function() {
                // return this._mgr.getStats.apply( this._mgr, arguments );
                var stats = this.request(&#x27;get-stats&#x27;);
    
                return stats ? {
                    successNum: stats.numOfSuccess,
                    progressNum: stats.numOfProgress,
    
                    // who care?
                    // queueFailNum: 0,
                    cancelNum: stats.numOfCancel,
                    invalidNum: stats.numOfInvalid,
                    uploadFailNum: stats.numOfUploadFailed,
                    queueNum: stats.numOfQueue,
                    interruptNum: stats.numofInterrupt
                } : {};
            },
    
            // 需要重写此方法来来支持opts.onEvent和instance.onEvent的处理器
            trigger: function( type/*, args...*/ ) {
                var args = [].slice.call( arguments, 1 ),
                    opts = this.options,
                    name = &#x27;on&#x27; + type.substring( 0, 1 ).toUpperCase() +
                        type.substring( 1 );
    
                if (
                        // 调用通过on方法注册的handler.
                        Mediator.trigger.apply( this, arguments ) === false ||
    
                        // 调用opts.onEvent
                        $.isFunction( opts[ name ] ) &amp;&amp;
                        opts[ name ].apply( this, args ) === false ||
    
                        // 调用this.onEvent
                        $.isFunction( this[ name ] ) &amp;&amp;
                        this[ name ].apply( this, args ) === false ||
    
                        // 广播所有uploader的事件。
                        Mediator.trigger.apply( Mediator,
                        [ this, type ].concat( args ) ) === false ) {
    
                    return false;
                }
    
                return true;
            },
    
            /**
             * 销毁 webuploader 实例
             * @method destroy
             * @grammar destroy() =&gt; undefined
             */
            destroy: function() {
                this.request( &#x27;destroy&#x27;, arguments );
                this.off();
            },
    
            // widgets/widget.js将补充此方法的详细文档。
            request: Base.noop
        });
    
        /**
         * 创建Uploader实例，等同于new Uploader( opts );
         * @method create
         * @class Base
         * @static
         * @grammar Base.create( opts ) =&gt; Uploader
         */
        Base.create = Uploader.create = function( opts ) {
            return new Uploader( opts );
        };
    
        // 暴露Uploader，可以通过它来扩展业务逻辑。
        Base.Uploader = Uploader;
    
        return Uploader;
    });
    /**
     * @fileOverview Runtime管理器，负责Runtime的选择, 连接
     */
    define(&#x27;runtime/runtime&#x27;,[
        &#x27;base&#x27;,
        &#x27;mediator&#x27;
    ], function( Base, Mediator ) {
    
        var $ = Base.$,
            factories = {},
    
            // 获取对象的第一个key
            getFirstKey = function( obj ) {
                for ( var key in obj ) {
                    if ( obj.hasOwnProperty( key ) ) {
                        return key;
                    }
                }
                return null;
            };
    
        // 接口类。
        function Runtime( options ) {
            this.options = $.extend({
                container: document.body
            }, options );
            this.uid = Base.guid(&#x27;rt_&#x27;);
        }
    
        $.extend( Runtime.prototype, {
    
            getContainer: function() {
                var opts = this.options,
                    parent, container;
    
                if ( this._container ) {
                    return this._container;
                }
    
                parent = $( opts.container || document.body );
                container = $( document.createElement(&#x27;div&#x27;) );
    
                container.attr( &#x27;id&#x27;, &#x27;rt_&#x27; + this.uid );
                container.css({
                    position: &#x27;absolute&#x27;,
                    top: &#x27;0px&#x27;,
                    left: &#x27;0px&#x27;,
                    width: &#x27;1px&#x27;,
                    height: &#x27;1px&#x27;,
                    overflow: &#x27;hidden&#x27;
                });
    
                parent.append( container );
                parent.addClass(&#x27;webuploader-container&#x27;);
                this._container = container;
                this._parent = parent;
                return container;
            },
    
            init: Base.noop,
            exec: Base.noop,
    
            destroy: function() {
                this._container &amp;&amp; this._container.remove();
                this._parent &amp;&amp; this._parent.removeClass(&#x27;webuploader-container&#x27;);
                this.off();
            }
        });
    
        Runtime.orders = &#x27;html5,flash&#x27;;
    
    
        /**
         * 添加Runtime实现。
         * @param {String} type    类型
         * @param {Runtime} factory 具体Runtime实现。
         */
        Runtime.addRuntime = function( type, factory ) {
            factories[ type ] = factory;
        };
    
        Runtime.hasRuntime = function( type ) {
            return !!(type ? factories[ type ] : getFirstKey( factories ));
        };
    
        Runtime.create = function( opts, orders ) {
            var type, runtime;
    
            orders = orders || Runtime.orders;
            $.each( orders.split( /\s*,\s*/g ), function() {
                if ( factories[ this ] ) {
                    type = this;
                    return false;
                }
            });
    
            type = type || getFirstKey( factories );
    
            if ( !type ) {
                throw new Error(&#x27;Runtime Error&#x27;);
            }
    
            runtime = new factories[ type ]( opts );
            return runtime;
        };
    
        Mediator.installTo( Runtime.prototype );
        return Runtime;
    });
    
    /**
     * @fileOverview Runtime管理器，负责Runtime的选择, 连接
     */
    define(&#x27;runtime/client&#x27;,[
        &#x27;base&#x27;,
        &#x27;mediator&#x27;,
        &#x27;runtime/runtime&#x27;
    ], function( Base, Mediator, Runtime ) {
    
        var cache;
    
        cache = (function() {
            var obj = {};
    
            return {
                add: function( runtime ) {
                    obj[ runtime.uid ] = runtime;
                },
    
                get: function( ruid, standalone ) {
                    var i;
    
                    if ( ruid ) {
                        return obj[ ruid ];
                    }
    
                    for ( i in obj ) {
                        // 有些类型不能重用，比如filepicker.
                        if ( standalone &amp;&amp; obj[ i ].__standalone ) {
                            continue;
                        }
    
                        return obj[ i ];
                    }
    
                    return null;
                },
    
                remove: function( runtime ) {
                    delete obj[ runtime.uid ];
                }
            };
        })();
    
        function RuntimeClient( component, standalone ) {
            var deferred = Base.Deferred(),
                runtime;
    
            this.uid = Base.guid(&#x27;client_&#x27;);
    
            // 允许runtime没有初始化之前，注册一些方法在初始化后执行。
            this.runtimeReady = function( cb ) {
                return deferred.done( cb );
            };
    
            this.connectRuntime = function( opts, cb ) {
    
                // already connected.
                if ( runtime ) {
                    throw new Error(&#x27;already connected!&#x27;);
                }
    
                deferred.done( cb );
    
                if ( typeof opts === &#x27;string&#x27; &amp;&amp; cache.get( opts ) ) {
                    runtime = cache.get( opts );
                }
    
                // 像filePicker只能独立存在，不能公用。
                runtime = runtime || cache.get( null, standalone );
    
                // 需要创建
                if ( !runtime ) {
                    runtime = Runtime.create( opts, opts.runtimeOrder );
                    runtime.__promise = deferred.promise();
                    runtime.once( &#x27;ready&#x27;, deferred.resolve );
                    runtime.init();
                    cache.add( runtime );
                    runtime.__client = 1;
                } else {
                    // 来自cache
                    Base.$.extend( runtime.options, opts );
                    runtime.__promise.then( deferred.resolve );
                    runtime.__client++;
                }
    
                standalone &amp;&amp; (runtime.__standalone = standalone);
                return runtime;
            };
    
            this.getRuntime = function() {
                return runtime;
            };
    
            this.disconnectRuntime = function() {
                if ( !runtime ) {
                    return;
                }
    
                runtime.__client--;
    
                if ( runtime.__client &lt;= 0 ) {
                    cache.remove( runtime );
                    delete runtime.__promise;
                    runtime.destroy();
                }
    
                runtime = null;
            };
    
            this.exec = function() {
                if ( !runtime ) {
                    return;
                }
    
                var args = Base.slice( arguments );
                component &amp;&amp; args.unshift( component );
    
                return runtime.exec.apply( this, args );
            };
    
            this.getRuid = function() {
                return runtime &amp;&amp; runtime.uid;
            };
    
            this.destroy = (function( destroy ) {
                return function() {
                    destroy &amp;&amp; destroy.apply( this, arguments );
                    this.trigger(&#x27;destroy&#x27;);
                    this.off();
                    this.exec(&#x27;destroy&#x27;);
                    this.disconnectRuntime();
                };
            })( this.destroy );
        }
    
        Mediator.installTo( RuntimeClient.prototype );
        return RuntimeClient;
    });
    /**
     * @fileOverview 错误信息
     */
    define(&#x27;lib/dnd&#x27;,[
        &#x27;base&#x27;,
        &#x27;mediator&#x27;,
        &#x27;runtime/client&#x27;
    ], function( Base, Mediator, RuntimeClent ) {
    
        var $ = Base.$;
    
        function DragAndDrop( opts ) {
            opts = this.options = $.extend({}, DragAndDrop.options, opts );
    
            opts.container = $( opts.container );
    
            if ( !opts.container.length ) {
                return;
            }
    
            RuntimeClent.call( this, &#x27;DragAndDrop&#x27; );
        }
    
        DragAndDrop.options = {
            accept: null,
            disableGlobalDnd: false
        };
    
        Base.inherits( RuntimeClent, {
            constructor: DragAndDrop,
    
            init: function() {
                var me = this;
    
                me.connectRuntime( me.options, function() {
                    me.exec(&#x27;init&#x27;);
                    me.trigger(&#x27;ready&#x27;);
                });
            }
        });
    
        Mediator.installTo( DragAndDrop.prototype );
    
        return DragAndDrop;
    });
    /**
     * @fileOverview 组件基类。
     */
    define(&#x27;widgets/widget&#x27;,[
        &#x27;base&#x27;,
        &#x27;uploader&#x27;
    ], function( Base, Uploader ) {
    
        var $ = Base.$,
            _init = Uploader.prototype._init,
            _destroy = Uploader.prototype.destroy,
            IGNORE = {},
            widgetClass = [];
    
        function isArrayLike( obj ) {
            if ( !obj ) {
                return false;
            }
    
            var length = obj.length,
                type = $.type( obj );
    
            if ( obj.nodeType === 1 &amp;&amp; length ) {
                return true;
            }
    
            return type === &#x27;array&#x27; || type !== &#x27;function&#x27; &amp;&amp; type !== &#x27;string&#x27; &amp;&amp;
                    (length === 0 || typeof length === &#x27;number&#x27; &amp;&amp; length &gt; 0 &amp;&amp;
                    (length - 1) in obj);
        }
    
        function Widget( uploader ) {
            this.owner = uploader;
            this.options = uploader.options;
        }
    
        $.extend( Widget.prototype, {
    
            init: Base.noop,
    
            // 类Backbone的事件监听声明，监听uploader实例上的事件
            // widget直接无法监听事件，事件只能通过uploader来传递
            invoke: function( apiName, args ) {
    
                /*
                    {
                        &#x27;make-thumb&#x27;: &#x27;makeThumb&#x27;
                    }
                 */
                var map = this.responseMap;
    
                // 如果无API响应声明则忽略
                if ( !map || !(apiName in map) || !(map[ apiName ] in this) ||
                        !$.isFunction( this[ map[ apiName ] ] ) ) {
    
                    return IGNORE;
                }
    
                return this[ map[ apiName ] ].apply( this, args );
    
            },
    
            /**
             * 发送命令。当传入&#x60;callback&#x60;或者&#x60;handler&#x60;中返回&#x60;promise&#x60;时。返回一个当所有&#x60;handler&#x60;中的promise都完成后完成的新&#x60;promise&#x60;。
             * @method request
             * @grammar request( command, args ) =&gt; * | Promise
             * @grammar request( command, args, callback ) =&gt; Promise
             * @for  Uploader
             */
            request: function() {
                return this.owner.request.apply( this.owner, arguments );
            }
        });
    
        // 扩展Uploader.
        $.extend( Uploader.prototype, {
    
            /**
             * @property {String | Array} [disableWidgets=undefined]
             * @namespace options
             * @for Uploader
             * @description 默认所有 Uploader.register 了的 widget 都会被加载，如果禁用某一部分，请通过此 option 指定黑名单。
             */
    
            // 覆写_init用来初始化widgets
            _init: function() {
                var me = this,
                    widgets = me._widgets = [],
                    deactives = me.options.disableWidgets || &#x27;&#x27;;
    
                $.each( widgetClass, function( _, klass ) {
                    (!deactives || !~deactives.indexOf( klass._name )) &amp;&amp;
                        widgets.push( new klass( me ) );
                });
    
                return _init.apply( me, arguments );
            },
    
            request: function( apiName, args, callback ) {
                var i = 0,
                    widgets = this._widgets,
                    len = widgets &amp;&amp; widgets.length,
                    rlts = [],
                    dfds = [],
                    widget, rlt, promise, key;
    
                args = isArrayLike( args ) ? args : [ args ];
    
                for ( ; i &lt; len; i++ ) {
                    widget = widgets[ i ];
                    rlt = widget.invoke( apiName, args );
    
                    if ( rlt !== IGNORE ) {
    
                        // Deferred对象
                        if ( Base.isPromise( rlt ) ) {
                            dfds.push( rlt );
                        } else {
                            rlts.push( rlt );
                        }
                    }
                }
    
                // 如果有callback，则用异步方式。
                if ( callback || dfds.length ) {
                    promise = Base.when.apply( Base, dfds );
                    key = promise.pipe ? &#x27;pipe&#x27; : &#x27;then&#x27;;
    
                    // 很重要不能删除。删除了会死循环。
                    // 保证执行顺序。让callback总是在下一个 tick 中执行。
                    return promise[ key ](function() {
                                var deferred = Base.Deferred(),
                                    args = arguments;
    
                                if ( args.length === 1 ) {
                                    args = args[ 0 ];
                                }
    
                                setTimeout(function() {
                                    deferred.resolve( args );
                                }, 1 );
    
                                return deferred.promise();
                            })[ callback ? key : &#x27;done&#x27; ]( callback || Base.noop );
                } else {
                    return rlts[ 0 ];
                }
            },
    
            destroy: function() {
                _destroy.apply( this, arguments );
                this._widgets = null;
            }
        });
    
        /**
         * 添加组件
         * @grammar Uploader.register(proto);
         * @grammar Uploader.register(map, proto);
         * @param  {object} responseMap API 名称与函数实现的映射
         * @param  {object} proto 组件原型，构造函数通过 constructor 属性定义
         * @method Uploader.register
         * @for Uploader
         * @example
         * Uploader.register({
         *     &#x27;make-thumb&#x27;: &#x27;makeThumb&#x27;
         * }, {
         *     init: function( options ) {},
         *     makeThumb: function() {}
         * });
         *
         * Uploader.register({
         *     &#x27;make-thumb&#x27;: function() {
         *         
         *     }
         * });
         */
        Uploader.register = Widget.register = function( responseMap, widgetProto ) {
            var map = { init: &#x27;init&#x27;, destroy: &#x27;destroy&#x27;, name: &#x27;anonymous&#x27; },
                klass;
    
            if ( arguments.length === 1 ) {
                widgetProto = responseMap;
    
                // 自动生成 map 表。
                $.each(widgetProto, function(key) {
                    if ( key[0] === &#x27;_&#x27; || key === &#x27;name&#x27; ) {
                        key === &#x27;name&#x27; &amp;&amp; (map.name = widgetProto.name);
                        return;
                    }
    
                    map[key.replace(/[A-Z]/g, &#x27;-$&amp;&#x27;).toLowerCase()] = key;
                });
    
            } else {
                map = $.extend( map, responseMap );
            }
    
            widgetProto.responseMap = map;
            klass = Base.inherits( Widget, widgetProto );
            klass._name = map.name;
            widgetClass.push( klass );
    
            return klass;
        };
    
        /**
         * 删除插件，只有在注册时指定了名字的才能被删除。
         * @grammar Uploader.unRegister(name);
         * @param  {string} name 组件名字
         * @method Uploader.unRegister
         * @for Uploader
         * @example
         *
         * Uploader.register({
         *     name: &#x27;custom&#x27;,
         *     
         *     &#x27;make-thumb&#x27;: function() {
         *         
         *     }
         * });
         *
         * Uploader.unRegister(&#x27;custom&#x27;);
         */
        Uploader.unRegister = Widget.unRegister = function( name ) {
            if ( !name || name === &#x27;anonymous&#x27; ) {
                return;
            }
            
            // 删除指定的插件。
            for ( var i = widgetClass.length; i--; ) {
                if ( widgetClass[i]._name === name ) {
                    widgetClass.splice(i, 1)
                }
            }
        };
    
        return Widget;
    });
    /**
     * @fileOverview DragAndDrop Widget。
     */
    define(&#x27;widgets/filednd&#x27;,[
        &#x27;base&#x27;,
        &#x27;uploader&#x27;,
        &#x27;lib/dnd&#x27;,
        &#x27;widgets/widget&#x27;
    ], function( Base, Uploader, Dnd ) {
        var $ = Base.$;
    
        Uploader.options.dnd = &#x27;&#x27;;
    
        /**
         * @property {Selector} [dnd=undefined]  指定Drag And Drop拖拽的容器，如果不指定，则不启动。
         * @namespace options
         * @for Uploader
         */
        
        /**
         * @property {Selector} [disableGlobalDnd=false]  是否禁掉整个页面的拖拽功能，如果不禁用，图片拖进来的时候会默认被浏览器打开。
         * @namespace options
         * @for Uploader
         */
    
        /**
         * @event dndAccept
         * @param {DataTransferItemList} items DataTransferItem
         * @description 阻止此事件可以拒绝某些类型的文件拖入进来。目前只有 chrome 提供这样的 API，且只能通过 mime-type 验证。
         * @for  Uploader
         */
        return Uploader.register({
            name: &#x27;dnd&#x27;,
            
            init: function( opts ) {
    
                if ( !opts.dnd ||
                        this.request(&#x27;predict-runtime-type&#x27;) !== &#x27;html5&#x27; ) {
                    return;
                }
    
                var me = this,
                    deferred = Base.Deferred(),
                    options = $.extend({}, {
                        disableGlobalDnd: opts.disableGlobalDnd,
                        container: opts.dnd,
                        accept: opts.accept
                    }),
                    dnd;
    
                this.dnd = dnd = new Dnd( options );
    
                dnd.once( &#x27;ready&#x27;, deferred.resolve );
                dnd.on( &#x27;drop&#x27;, function( files ) {
                    me.request( &#x27;add-file&#x27;, [ files ]);
                });
    
                // 检测文件是否全部允许添加。
                dnd.on( &#x27;accept&#x27;, function( items ) {
                    return me.owner.trigger( &#x27;dndAccept&#x27;, items );
                });
    
                dnd.init();
    
                return deferred.promise();
            },
    
            destroy: function() {
                this.dnd &amp;&amp; this.dnd.destroy();
            }
        });
    });
    
    /**
     * @fileOverview 错误信息
     */
    define(&#x27;lib/filepaste&#x27;,[
        &#x27;base&#x27;,
        &#x27;mediator&#x27;,
        &#x27;runtime/client&#x27;
    ], function( Base, Mediator, RuntimeClent ) {
    
        var $ = Base.$;
    
        function FilePaste( opts ) {
            opts = this.options = $.extend({}, opts );
            opts.container = $( opts.container || document.body );
            RuntimeClent.call( this, &#x27;FilePaste&#x27; );
        }
    
        Base.inherits( RuntimeClent, {
            constructor: FilePaste,
    
            init: function() {
                var me = this;
    
                me.connectRuntime( me.options, function() {
                    me.exec(&#x27;init&#x27;);
                    me.trigger(&#x27;ready&#x27;);
                });
            }
        });
    
        Mediator.installTo( FilePaste.prototype );
    
        return FilePaste;
    });
    /**
     * @fileOverview 组件基类。
     */
    define(&#x27;widgets/filepaste&#x27;,[
        &#x27;base&#x27;,
        &#x27;uploader&#x27;,
        &#x27;lib/filepaste&#x27;,
        &#x27;widgets/widget&#x27;
    ], function( Base, Uploader, FilePaste ) {
        var $ = Base.$;
    
        /**
         * @property {Selector} [paste=undefined]  指定监听paste事件的容器，如果不指定，不启用此功能。此功能为通过粘贴来添加截屏的图片。建议设置为&#x60;document.body&#x60;.
         * @namespace options
         * @for Uploader
         */
        return Uploader.register({
            name: &#x27;paste&#x27;,
            
            init: function( opts ) {
    
                if ( !opts.paste ||
                        this.request(&#x27;predict-runtime-type&#x27;) !== &#x27;html5&#x27; ) {
                    return;
                }
    
                var me = this,
                    deferred = Base.Deferred(),
                    options = $.extend({}, {
                        container: opts.paste,
                        accept: opts.accept
                    }),
                    paste;
    
                this.paste = paste = new FilePaste( options );
    
                paste.once( &#x27;ready&#x27;, deferred.resolve );
                paste.on( &#x27;paste&#x27;, function( files ) {
                    me.owner.request( &#x27;add-file&#x27;, [ files ]);
                });
                paste.init();
    
                return deferred.promise();
            },
    
            destroy: function() {
                this.paste &amp;&amp; this.paste.destroy();
            }
        });
    });
    /**
     * @fileOverview Blob
     */
    define(&#x27;lib/blob&#x27;,[
        &#x27;base&#x27;,
        &#x27;runtime/client&#x27;
    ], function( Base, RuntimeClient ) {
    
        function Blob( ruid, source ) {
            var me = this;
    
            me.source = source;
            me.ruid = ruid;
            this.size = source.size || 0;
    
            // 如果没有指定 mimetype, 但是知道文件后缀。
            if ( !source.type &amp;&amp; this.ext &amp;&amp;
                    ~&#x27;jpg,jpeg,png,gif,bmp&#x27;.indexOf( this.ext ) ) {
                this.type = &#x27;image/&#x27; + (this.ext === &#x27;jpg&#x27; ? &#x27;jpeg&#x27; : this.ext);
            } else {
                this.type = source.type || &#x27;application/octet-stream&#x27;;
            }
    
            RuntimeClient.call( me, &#x27;Blob&#x27; );
            this.uid = source.uid || this.uid;
    
            if ( ruid ) {
                me.connectRuntime( ruid );
            }
        }
    
        Base.inherits( RuntimeClient, {
            constructor: Blob,
    
            slice: function( start, end ) {
                return this.exec( &#x27;slice&#x27;, start, end );
            },
    
            getSource: function() {
                return this.source;
            }
        });
    
        return Blob;
    });
    /**
     * 为了统一化Flash的File和HTML5的File而存在。
     * 以至于要调用Flash里面的File，也可以像调用HTML5版本的File一下。
     * @fileOverview File
     */
    define(&#x27;lib/file&#x27;,[
        &#x27;base&#x27;,
        &#x27;lib/blob&#x27;
    ], function( Base, Blob ) {
    
        var uid = 1,
            rExt = /\.([^.]+)$/;
    
        function File( ruid, file ) {
            var ext;
    
            this.name = file.name || (&#x27;untitled&#x27; + uid++);
            ext = rExt.exec( file.name ) ? RegExp.$1.toLowerCase() : &#x27;&#x27;;
    
            // todo 支持其他类型文件的转换。
            // 如果有 mimetype, 但是文件名里面没有找出后缀规律
            if ( !ext &amp;&amp; file.type ) {
                ext = /\/(jpg|jpeg|png|gif|bmp)$/i.exec( file.type ) ?
                        RegExp.$1.toLowerCase() : &#x27;&#x27;;
                this.name += &#x27;.&#x27; + ext;
            }
    
            this.ext = ext;
            this.lastModifiedDate = file.lastModifiedDate ||
                    (new Date()).toLocaleString();
    
            Blob.apply( this, arguments );
        }
    
        return Base.inherits( Blob, File );
    });
    
    /**
     * @fileOverview 错误信息
     */
    define(&#x27;lib/filepicker&#x27;,[
        &#x27;base&#x27;,
        &#x27;runtime/client&#x27;,
        &#x27;lib/file&#x27;
    ], function( Base, RuntimeClent, File ) {
    
        var $ = Base.$;
    
        function FilePicker( opts ) {
            opts = this.options = $.extend({}, FilePicker.options, opts );
    
            opts.container = $( opts.id );
    
            if ( !opts.container.length ) {
                throw new Error(&#x27;按钮指定错误&#x27;);
            }
    
            opts.innerHTML = opts.innerHTML || opts.label ||
                    opts.container.html() || &#x27;&#x27;;
    
            opts.button = $( opts.button || document.createElement(&#x27;div&#x27;) );
            opts.button.html( opts.innerHTML );
            opts.container.html( opts.button );
    
            RuntimeClent.call( this, &#x27;FilePicker&#x27;, true );
        }
    
        FilePicker.options = {
            button: null,
            container: null,
            label: null,
            innerHTML: null,
            multiple: true,
            accept: null,
            name: &#x27;file&#x27;
        };
    
        Base.inherits( RuntimeClent, {
            constructor: FilePicker,
    
            init: function() {
                var me = this,
                    opts = me.options,
                    button = opts.button;
    
                button.addClass(&#x27;webuploader-pick&#x27;);
    
                me.on( &#x27;all&#x27;, function( type ) {
                    var files;
    
                    switch ( type ) {
                        case &#x27;mouseenter&#x27;:
                            button.addClass(&#x27;webuploader-pick-hover&#x27;);
                            break;
    
                        case &#x27;mouseleave&#x27;:
                            button.removeClass(&#x27;webuploader-pick-hover&#x27;);
                            break;
    
                        case &#x27;change&#x27;:
                            files = me.exec(&#x27;getFiles&#x27;);
                            me.trigger( &#x27;select&#x27;, $.map( files, function( file ) {
                                file = new File( me.getRuid(), file );
    
                                // 记录来源。
                                file._refer = opts.container;
                                return file;
                            }), opts.container );
                            break;
                    }
                });
    
                me.connectRuntime( opts, function() {
                    me.refresh();
                    me.exec( &#x27;init&#x27;, opts );
                    me.trigger(&#x27;ready&#x27;);
                });
    
                this._resizeHandler = Base.bindFn( this.refresh, this );
                $( window ).on( &#x27;resize&#x27;, this._resizeHandler );
            },
    
            refresh: function() {
                var shimContainer = this.getRuntime().getContainer(),
                    button = this.options.button,
                    width = button.outerWidth ?
                            button.outerWidth() : button.width(),
    
                    height = button.outerHeight ?
                            button.outerHeight() : button.height(),
    
                    pos = button.offset();
    
                width &amp;&amp; height &amp;&amp; shimContainer.css({
                    bottom: &#x27;auto&#x27;,
                    right: &#x27;auto&#x27;,
                    width: width + &#x27;px&#x27;,
                    height: height + &#x27;px&#x27;
                }).offset( pos );
            },
    
            enable: function() {
                var btn = this.options.button;
    
                btn.removeClass(&#x27;webuploader-pick-disable&#x27;);
                this.refresh();
            },
    
            disable: function() {
                var btn = this.options.button;
    
                this.getRuntime().getContainer().css({
                    top: &#x27;-99999px&#x27;
                });
    
                btn.addClass(&#x27;webuploader-pick-disable&#x27;);
            },
    
            destroy: function() {
                var btn = this.options.button;
                $( window ).off( &#x27;resize&#x27;, this._resizeHandler );
                btn.removeClass(&#x27;webuploader-pick-disable webuploader-pick-hover &#x27; +
                    &#x27;webuploader-pick&#x27;);
            }
        });
    
        return FilePicker;
    });
    
    /**
     * @fileOverview 文件选择相关
     */
    define(&#x27;widgets/filepicker&#x27;,[
        &#x27;base&#x27;,
        &#x27;uploader&#x27;,
        &#x27;lib/filepicker&#x27;,
        &#x27;widgets/widget&#x27;
    ], function( Base, Uploader, FilePicker ) {
        var $ = Base.$;
    
        $.extend( Uploader.options, {
    
            /**
             * @property {Selector | Object} [pick=undefined]
             * @namespace options
             * @for Uploader
             * @description 指定选择文件的按钮容器，不指定则不创建按钮。
             *
             * * &#x60;id&#x60; {Seletor} 指定选择文件的按钮容器，不指定则不创建按钮。
             * * &#x60;label&#x60; {String} 请采用 &#x60;innerHTML&#x60; 代替
             * * &#x60;innerHTML&#x60; {String} 指定按钮文字。不指定时优先从指定的容器中看是否自带文字。
             * * &#x60;multiple&#x60; {Boolean} 是否开起同时选择多个文件能力。
             */
            pick: null,
    
            /**
             * @property {Arroy} [accept=null]
             * @namespace options
             * @for Uploader
             * @description 指定接受哪些类型的文件。 由于目前还有ext转mimeType表，所以这里需要分开指定。
             *
             * * &#x60;title&#x60; {String} 文字描述
             * * &#x60;extensions&#x60; {String} 允许的文件后缀，不带点，多个用逗号分割。
             * * &#x60;mimeTypes&#x60; {String} 多个用逗号分割。
             *
             * 如：
             *
             * &#x60;&#x60;&#x60;
             * {
             *     title: &#x27;Images&#x27;,
             *     extensions: &#x27;gif,jpg,jpeg,bmp,png&#x27;,
             *     mimeTypes: &#x27;image/*&#x27;
             * }
             * &#x60;&#x60;&#x60;
             */
            accept: null/*{
                title: &#x27;Images&#x27;,
                extensions: &#x27;gif,jpg,jpeg,bmp,png&#x27;,
                mimeTypes: &#x27;image/*&#x27;
            }*/
        });
    
        return Uploader.register({
            name: &#x27;picker&#x27;,
    
            init: function( opts ) {
                this.pickers = [];
                return opts.pick &amp;&amp; this.addBtn( opts.pick );
            },
    
            refresh: function() {
                $.each( this.pickers, function() {
                    this.refresh();
                });
            },
    
            /**
             * @method addButton
             * @for Uploader
             * @grammar addButton( pick ) =&gt; Promise
             * @description
             * 添加文件选择按钮，如果一个按钮不够，需要调用此方法来添加。参数跟[options.pick](#WebUploader:Uploader:options)一致。
             * @example
             * uploader.addButton({
             *     id: &#x27;#btnContainer&#x27;,
             *     innerHTML: &#x27;选择文件&#x27;
             * });
             */
            addBtn: function( pick ) {
                var me = this,
                    opts = me.options,
                    accept = opts.accept,
                    promises = [];
    
                if ( !pick ) {
                    return;
                }
                
                $.isPlainObject( pick ) || (pick = {
                    id: pick
                });
    
                $( pick.id ).each(function() {
                    var options, picker, deferred;
    
                    deferred = Base.Deferred();
    
                    options = $.extend({}, pick, {
                        accept: $.isPlainObject( accept ) ? [ accept ] : accept,
                        swf: opts.swf,
                        runtimeOrder: opts.runtimeOrder,
                        id: this
                    });
    
                    picker = new FilePicker( options );
    
                    picker.once( &#x27;ready&#x27;, deferred.resolve );
                    picker.on( &#x27;select&#x27;, function( files ) {
                        me.owner.request( &#x27;add-file&#x27;, [ files ]);
                    });
                    picker.init();
    
                    me.pickers.push( picker );
    
                    promises.push( deferred.promise() );
                });
    
                return Base.when.apply( Base, promises );
            },
    
            disable: function() {
                $.each( this.pickers, function() {
                    this.disable();
                });
            },
    
            enable: function() {
                $.each( this.pickers, function() {
                    this.enable();
                });
            },
    
            destroy: function() {
                $.each( this.pickers, function() {
                    this.destroy();
                });
                this.pickers = null;
            }
        });
    });
    /**
     * @fileOverview 文件属性封装
     */
    define(&#x27;file&#x27;,[
        &#x27;base&#x27;,
        &#x27;mediator&#x27;
    ], function( Base, Mediator ) {
    
        var $ = Base.$,
            idPrefix = &#x27;WU_FILE_&#x27;,
            idSuffix = 0,
            rExt = /\.([^.]+)$/,
            statusMap = {};
    
        function gid() {
            return idPrefix + idSuffix++;
        }
    
        /**
         * 文件类
         * @class File
         * @constructor 构造函数
         * @grammar new File( source ) =&gt; File
         * @param {Lib.File} source [lib.File](#Lib.File)实例, 此source对象是带有Runtime信息的。
         */
        function WUFile( source ) {
    
            /**
             * 文件名，包括扩展名（后缀）
             * @property name
             * @type {string}
             */
            this.name = source.name || &#x27;Untitled&#x27;;
    
            /**
             * 文件体积（字节）
             * @property size
             * @type {uint}
             * @default 0
             */
            this.size = source.size || 0;
    
            /**
             * 文件MIMETYPE类型，与文件类型的对应关系请参考[http://t.cn/z8ZnFny](http://t.cn/z8ZnFny)
             * @property type
             * @type {string}
             * @default &#x27;application/octet-stream&#x27;
             */
            this.type = source.type || &#x27;application/octet-stream&#x27;;
    
            /**
             * 文件最后修改日期
             * @property lastModifiedDate
             * @type {int}
             * @default 当前时间戳
             */
            this.lastModifiedDate = source.lastModifiedDate || (new Date() * 1);
    
            /**
             * 文件ID，每个对象具有唯一ID，与文件名无关
             * @property id
             * @type {string}
             */
            this.id = gid();
    
            /**
             * 文件扩展名，通过文件名获取，例如test.png的扩展名为png
             * @property ext
             * @type {string}
             */
            this.ext = rExt.exec( this.name ) ? RegExp.$1 : &#x27;&#x27;;
    
    
            /**
             * 状态文字说明。在不同的status语境下有不同的用途。
             * @property statusText
             * @type {string}
             */
            this.statusText = &#x27;&#x27;;
    
            // 存储文件状态，防止通过属性直接修改
            statusMap[ this.id ] = WUFile.Status.INITED;
    
            this.source = source;
            this.loaded = 0;
    
            this.on( &#x27;error&#x27;, function( msg ) {
                this.setStatus( WUFile.Status.ERROR, msg );
            });
        }
    
        $.extend( WUFile.prototype, {
    
            /**
             * 设置状态，状态变化时会触发&#x60;change&#x60;事件。
             * @method setStatus
             * @grammar setStatus( status[, statusText] );
             * @param {File.Status|String} status [文件状态值](#WebUploader:File:File.Status)
             * @param {String} [statusText=&#x27;&#x27;] 状态说明，常在error时使用，用http, abort,server等来标记是由于什么原因导致文件错误。
             */
            setStatus: function( status, text ) {
    
                var prevStatus = statusMap[ this.id ];
    
                typeof text !== &#x27;undefined&#x27; &amp;&amp; (this.statusText = text);
    
                if ( status !== prevStatus ) {
                    statusMap[ this.id ] = status;
                    /**
                     * 文件状态变化
                     * @event statuschange
                     */
                    this.trigger( &#x27;statuschange&#x27;, status, prevStatus );
                }
    
            },
    
            /**
             * 获取文件状态
             * @return {File.Status}
             * @example
                     文件状态具体包括以下几种类型：
                     {
                         // 初始化
                        INITED:     0,
                        // 已入队列
                        QUEUED:     1,
                        // 正在上传
                        PROGRESS:     2,
                        // 上传出错
                        ERROR:         3,
                        // 上传成功
                        COMPLETE:     4,
                        // 上传取消
                        CANCELLED:     5
                    }
             */
            getStatus: function() {
                return statusMap[ this.id ];
            },
    
            /**
             * 获取文件原始信息。
             * @return {*}
             */
            getSource: function() {
                return this.source;
            },
    
            destroy: function() {
                this.off();
                delete statusMap[ this.id ];
            }
        });
    
        Mediator.installTo( WUFile.prototype );
    
        /**
         * 文件状态值，具体包括以下几种类型：
         * * &#x60;inited&#x60; 初始状态
         * * &#x60;queued&#x60; 已经进入队列, 等待上传
         * * &#x60;progress&#x60; 上传中
         * * &#x60;complete&#x60; 上传完成。
         * * &#x60;error&#x60; 上传出错，可重试
         * * &#x60;interrupt&#x60; 上传中断，可续传。
         * * &#x60;invalid&#x60; 文件不合格，不能重试上传。会自动从队列中移除。
         * * &#x60;cancelled&#x60; 文件被移除。
         * @property {Object} Status
         * @namespace File
         * @class File
         * @static
         */
        WUFile.Status = {
            INITED:     &#x27;inited&#x27;,    // 初始状态
            QUEUED:     &#x27;queued&#x27;,    // 已经进入队列, 等待上传
            PROGRESS:   &#x27;progress&#x27;,    // 上传中
            ERROR:      &#x27;error&#x27;,    // 上传出错，可重试
            COMPLETE:   &#x27;complete&#x27;,    // 上传完成。
            CANCELLED:  &#x27;cancelled&#x27;,    // 上传取消。
            INTERRUPT:  &#x27;interrupt&#x27;,    // 上传中断，可续传。
            INVALID:    &#x27;invalid&#x27;    // 文件不合格，不能重试上传。
        };
    
        return WUFile;
    });
    
    /**
     * @fileOverview 文件队列
     */
    define(&#x27;queue&#x27;,[
        &#x27;base&#x27;,
        &#x27;mediator&#x27;,
        &#x27;file&#x27;
    ], function( Base, Mediator, WUFile ) {
    
        var $ = Base.$,
            STATUS = WUFile.Status;
    
        /**
         * 文件队列, 用来存储各个状态中的文件。
         * @class Queue
         * @extends Mediator
         */
        function Queue() {
    
            /**
             * 统计文件数。
             * * &#x60;numOfQueue&#x60; 队列中的文件数。
             * * &#x60;numOfSuccess&#x60; 上传成功的文件数
             * * &#x60;numOfCancel&#x60; 被取消的文件数
             * * &#x60;numOfProgress&#x60; 正在上传中的文件数
             * * &#x60;numOfUploadFailed&#x60; 上传错误的文件数。
             * * &#x60;numOfInvalid&#x60; 无效的文件数。
             * * &#x60;numofDeleted&#x60; 被移除的文件数。
             * @property {Object} stats
             */
            this.stats = {
                numOfQueue: 0,
                numOfSuccess: 0,
                numOfCancel: 0,
                numOfProgress: 0,
                numOfUploadFailed: 0,
                numOfInvalid: 0,
                numofDeleted: 0,
                numofInterrupt: 0,
            };
    
            // 上传队列，仅包括等待上传的文件
            this._queue = [];
    
            // 存储所有文件
            this._map = {};
        }
    
        $.extend( Queue.prototype, {
    
            /**
             * 将新文件加入对队列尾部
             *
             * @method append
             * @param  {File} file   文件对象
             */
            append: function( file ) {
                this._queue.push( file );
                this._fileAdded( file );
                return this;
            },
    
            /**
             * 将新文件加入对队列头部
             *
             * @method prepend
             * @param  {File} file   文件对象
             */
            prepend: function( file ) {
                this._queue.unshift( file );
                this._fileAdded( file );
                return this;
            },
    
            /**
             * 获取文件对象
             *
             * @method getFile
             * @param  {String} fileId   文件ID
             * @return {File}
             */
            getFile: function( fileId ) {
                if ( typeof fileId !== &#x27;string&#x27; ) {
                    return fileId;
                }
                return this._map[ fileId ];
            },
    
            /**
             * 从队列中取出一个指定状态的文件。
             * @grammar fetch( status ) =&gt; File
             * @method fetch
             * @param {String} status [文件状态值](#WebUploader:File:File.Status)
             * @return {File} [File](#WebUploader:File)
             */
            fetch: function( status ) {
                var len = this._queue.length,
                    i, file;
    
                status = status || STATUS.QUEUED;
    
                for ( i = 0; i &lt; len; i++ ) {
                    file = this._queue[ i ];
    
                    if ( status === file.getStatus() ) {
                        return file;
                    }
                }
    
                return null;
            },
    
            /**
             * 对队列进行排序，能够控制文件上传顺序。
             * @grammar sort( fn ) =&gt; undefined
             * @method sort
             * @param {Function} fn 排序方法
             */
            sort: function( fn ) {
                if ( typeof fn === &#x27;function&#x27; ) {
                    this._queue.sort( fn );
                }
            },
    
            /**
             * 获取指定类型的文件列表, 列表中每一个成员为[File](#WebUploader:File)对象。
             * @grammar getFiles( [status1[, status2 ...]] ) =&gt; Array
             * @method getFiles
             * @param {String} [status] [文件状态值](#WebUploader:File:File.Status)
             */
            getFiles: function() {
                var sts = [].slice.call( arguments, 0 ),
                    ret = [],
                    i = 0,
                    len = this._queue.length,
                    file;
    
                for ( ; i &lt; len; i++ ) {
                    file = this._queue[ i ];
    
                    if ( sts.length &amp;&amp; !~$.inArray( file.getStatus(), sts ) ) {
                        continue;
                    }
    
                    ret.push( file );
                }
    
                return ret;
            },
    
            /**
             * 在队列中删除文件。
             * @grammar removeFile( file ) =&gt; Array
             * @method removeFile
             * @param {File} 文件对象。
             */
            removeFile: function( file ) {
                var me = this,
                    existing = this._map[ file.id ];
    
                if ( existing ) {
                    delete this._map[ file.id ];
                    file.destroy();
                    this.stats.numofDeleted++;
                }
            },
    
            _fileAdded: function( file ) {
                var me = this,
                    existing = this._map[ file.id ];
    
                if ( !existing ) {
                    this._map[ file.id ] = file;
    
                    file.on( &#x27;statuschange&#x27;, function( cur, pre ) {
                        me._onFileStatusChange( cur, pre );
                    });
                }
            },
    
            _onFileStatusChange: function( curStatus, preStatus ) {
                var stats = this.stats;
    
                switch ( preStatus ) {
                    case STATUS.PROGRESS:
                        stats.numOfProgress--;
                        break;
    
                    case STATUS.QUEUED:
                        stats.numOfQueue --;
                        break;
    
                    case STATUS.ERROR:
                        stats.numOfUploadFailed--;
                        break;
    
                    case STATUS.INVALID:
                        stats.numOfInvalid--;
                        break;
    
                    case STATUS.INTERRUPT:
                        stats.numofInterrupt--;
                        break;
                }
    
                switch ( curStatus ) {
                    case STATUS.QUEUED:
                        stats.numOfQueue++;
                        break;
    
                    case STATUS.PROGRESS:
                        stats.numOfProgress++;
                        break;
    
                    case STATUS.ERROR:
                        stats.numOfUploadFailed++;
                        break;
    
                    case STATUS.COMPLETE:
                        stats.numOfSuccess++;
                        break;
    
                    case STATUS.CANCELLED:
                        stats.numOfCancel++;
                        break;
    
    
                    case STATUS.INVALID:
                        stats.numOfInvalid++;
                        break;
    
                    case STATUS.INTERRUPT:
                        stats.numofInterrupt++;
                        break;
                }
            }
    
        });
    
        Mediator.installTo( Queue.prototype );
    
        return Queue;
    });
    /**
     * @fileOverview 队列
     */
    define(&#x27;widgets/queue&#x27;,[
        &#x27;base&#x27;,
        &#x27;uploader&#x27;,
        &#x27;queue&#x27;,
        &#x27;file&#x27;,
        &#x27;lib/file&#x27;,
        &#x27;runtime/client&#x27;,
        &#x27;widgets/widget&#x27;
    ], function( Base, Uploader, Queue, WUFile, File, RuntimeClient ) {
    
        var $ = Base.$,
            rExt = /\.\w+$/,
            Status = WUFile.Status;
    
        return Uploader.register({
            name: &#x27;queue&#x27;,
    
            init: function( opts ) {
                var me = this,
                    deferred, len, i, item, arr, accept, runtime;
    
                if ( $.isPlainObject( opts.accept ) ) {
                    opts.accept = [ opts.accept ];
                }
    
                // accept中的中生成匹配正则。
                if ( opts.accept ) {
                    arr = [];
    
                    for ( i = 0, len = opts.accept.length; i &lt; len; i++ ) {
                        item = opts.accept[ i ].extensions;
                        item &amp;&amp; arr.push( item );
                    }
    
                    if ( arr.length ) {
                        accept = &#x27;\\.&#x27; + arr.join(&#x27;,&#x27;)
                                .replace( /,/g, &#x27;$|\\.&#x27; )
                                .replace( /\*/g, &#x27;.*&#x27; ) + &#x27;$&#x27;;
                    }
    
                    me.accept = new RegExp( accept, &#x27;i&#x27; );
                }
    
                me.queue = new Queue();
                me.stats = me.queue.stats;
    
                // 如果当前不是html5运行时，那就算了。
                // 不执行后续操作
                if ( this.request(&#x27;predict-runtime-type&#x27;) !== &#x27;html5&#x27; ) {
                    return;
                }
    
                // 创建一个 html5 运行时的 placeholder
                // 以至于外部添加原生 File 对象的时候能正确包裹一下供 webuploader 使用。
                deferred = Base.Deferred();
                this.placeholder = runtime = new RuntimeClient(&#x27;Placeholder&#x27;);
                runtime.connectRuntime({
                    runtimeOrder: &#x27;html5&#x27;
                }, function() {
                    me._ruid = runtime.getRuid();
                    deferred.resolve();
                });
                return deferred.promise();
            },
    
    
            // 为了支持外部直接添加一个原生File对象。
            _wrapFile: function( file ) {
                if ( !(file instanceof WUFile) ) {
    
                    if ( !(file instanceof File) ) {
                        if ( !this._ruid ) {
                            throw new Error(&#x27;Can\&#x27;t add external files.&#x27;);
                        }
                        file = new File( this._ruid, file );
                    }
    
                    file = new WUFile( file );
                }
    
                return file;
            },
    
            // 判断文件是否可以被加入队列
            acceptFile: function( file ) {
                var invalid = !file || !file.size || this.accept &amp;&amp;
    
                        // 如果名字中有后缀，才做后缀白名单处理。
                        rExt.exec( file.name ) &amp;&amp; !this.accept.test( file.name );
    
                return !invalid;
            },
    
    
            /**
             * @event beforeFileQueued
             * @param {File} file File对象
             * @description 当文件被加入队列之前触发，此事件的handler返回值为&#x60;false&#x60;，则此文件不会被添加进入队列。
             * @for  Uploader
             */
    
            /**
             * @event fileQueued
             * @param {File} file File对象
             * @description 当文件被加入队列以后触发。
             * @for  Uploader
             */
    
            _addFile: function( file ) {
                var me = this;
    
                file = me._wrapFile( file );
    
                // 不过类型判断允许不允许，先派送 &#x60;beforeFileQueued&#x60;
                if ( !me.owner.trigger( &#x27;beforeFileQueued&#x27;, file ) ) {
                    return;
                }
    
                // 类型不匹配，则派送错误事件，并返回。
                if ( !me.acceptFile( file ) ) {
                    me.owner.trigger( &#x27;error&#x27;, &#x27;Q_TYPE_DENIED&#x27;, file );
                    return;
                }
    
                me.queue.append( file );
                me.owner.trigger( &#x27;fileQueued&#x27;, file );
                return file;
            },
    
            getFile: function( fileId ) {
                return this.queue.getFile( fileId );
            },
    
            /**
             * @event filesQueued
             * @param {File} files 数组，内容为原始File(lib/File）对象。
             * @description 当一批文件添加进队列以后触发。
             * @for  Uploader
             */
            
            /**
             * @property {Boolean} [auto=false]
             * @namespace options
             * @for Uploader
             * @description 设置为 true 后，不需要手动调用上传，有文件选择即开始上传。
             * 
             */
    
            /**
             * @method addFiles
             * @grammar addFiles( file ) =&gt; undefined
             * @grammar addFiles( [file1, file2 ...] ) =&gt; undefined
             * @param {Array of File or File} [files] Files 对象 数组
             * @description 添加文件到队列
             * @for  Uploader
             */
            addFile: function( files ) {
                var me = this;
    
                if ( !files.length ) {
                    files = [ files ];
                }
    
                files = $.map( files, function( file ) {
                    return me._addFile( file );
                });
    
                me.owner.trigger( &#x27;filesQueued&#x27;, files );
    
                if ( me.options.auto ) {
                    setTimeout(function() {
                        me.request(&#x27;start-upload&#x27;);
                    }, 20 );
                }
            },
    
            getStats: function() {
                return this.stats;
            },
    
            /**
             * @event fileDequeued
             * @param {File} file File对象
             * @description 当文件被移除队列后触发。
             * @for  Uploader
             */
    
             /**
             * @method removeFile
             * @grammar removeFile( file ) =&gt; undefined
             * @grammar removeFile( id ) =&gt; undefined
             * @grammar removeFile( file, true ) =&gt; undefined
             * @grammar removeFile( id, true ) =&gt; undefined
             * @param {File|id} file File对象或这File对象的id
             * @description 移除某一文件, 默认只会标记文件状态为已取消，如果第二个参数为 &#x60;true&#x60; 则会从 queue 中移除。
             * @for  Uploader
             * @example
             *
             * $li.on(&#x27;click&#x27;, &#x27;.remove-this&#x27;, function() {
             *     uploader.removeFile( file );
             * })
             */
            removeFile: function( file, remove ) {
                var me = this;
    
                file = file.id ? file : me.queue.getFile( file );
    
                this.request( &#x27;cancel-file&#x27;, file );
    
                if ( remove ) {
                    this.queue.removeFile( file );
                }
            },
    
            /**
             * @method getFiles
             * @grammar getFiles() =&gt; Array
             * @grammar getFiles( status1, status2, status... ) =&gt; Array
             * @description 返回指定状态的文件集合，不传参数将返回所有状态的文件。
             * @for  Uploader
             * @example
             * console.log( uploader.getFiles() );    // =&gt; all files
             * console.log( uploader.getFiles(&#x27;error&#x27;) )    // =&gt; all error files.
             */
            getFiles: function() {
                return this.queue.getFiles.apply( this.queue, arguments );
            },
    
            fetchFile: function() {
                return this.queue.fetch.apply( this.queue, arguments );
            },
    
            /**
             * @method retry
             * @grammar retry() =&gt; undefined
             * @grammar retry( file ) =&gt; undefined
             * @description 重试上传，重试指定文件，或者从出错的文件开始重新上传。
             * @for  Uploader
             * @example
             * function retry() {
             *     uploader.retry();
             * }
             */
            retry: function( file, noForceStart ) {
                var me = this,
                    files, i, len;
    
                if ( file ) {
                    file = file.id ? file : me.queue.getFile( file );
                    file.setStatus( Status.QUEUED );
                    noForceStart || me.request(&#x27;start-upload&#x27;);
                    return;
                }
    
                files = me.queue.getFiles( Status.ERROR );
                i = 0;
                len = files.length;
    
                for ( ; i &lt; len; i++ ) {
                    file = files[ i ];
                    file.setStatus( Status.QUEUED );
                }
    
                me.request(&#x27;start-upload&#x27;);
            },
    
            /**
             * @method sort
             * @grammar sort( fn ) =&gt; undefined
             * @description 排序队列中的文件，在上传之前调整可以控制上传顺序。
             * @for  Uploader
             */
            sortFiles: function() {
                return this.queue.sort.apply( this.queue, arguments );
            },
    
            /**
             * @event reset
             * @description 当 uploader 被重置的时候触发。
             * @for  Uploader
             */
    
            /**
             * @method reset
             * @grammar reset() =&gt; undefined
             * @description 重置uploader。目前只重置了队列。
             * @for  Uploader
             * @example
             * uploader.reset();
             */
            reset: function() {
                this.owner.trigger(&#x27;reset&#x27;);
                this.queue = new Queue();
                this.stats = this.queue.stats;
            },
    
            destroy: function() {
                this.reset();
                this.placeholder &amp;&amp; this.placeholder.destroy();
            }
        });
    
    });
    /**
     * @fileOverview 添加获取Runtime相关信息的方法。
     */
    define(&#x27;widgets/runtime&#x27;,[
        &#x27;uploader&#x27;,
        &#x27;runtime/runtime&#x27;,
        &#x27;widgets/widget&#x27;
    ], function( Uploader, Runtime ) {
    
        Uploader.support = function() {
            return Runtime.hasRuntime.apply( Runtime, arguments );
        };
    
        return Uploader.register({
            name: &#x27;runtime&#x27;,
    
            init: function() {
                if ( !this.predictRuntimeType() ) {
                    throw Error(&#x27;Runtime Error&#x27;);
                }
            },
    
            /**
             * 预测Uploader将采用哪个&#x60;Runtime&#x60;
             * @grammar predictRuntimeType() =&gt; String
             * @method predictRuntimeType
             * @for  Uploader
             */
            predictRuntimeType: function() {
                var orders = this.options.runtimeOrder || Runtime.orders,
                    type = this.type,
                    i, len;
    
                if ( !type ) {
                    orders = orders.split( /\s*,\s*/g );
    
                    for ( i = 0, len = orders.length; i &lt; len; i++ ) {
                        if ( Runtime.hasRuntime( orders[ i ] ) ) {
                            this.type = type = orders[ i ];
                            break;
                        }
                    }
                }
    
                return type;
            }
        });
    });
    /**
     * @fileOverview Transport
     */
    define(&#x27;lib/transport&#x27;,[
        &#x27;base&#x27;,
        &#x27;runtime/client&#x27;,
        &#x27;mediator&#x27;
    ], function( Base, RuntimeClient, Mediator ) {
    
        var $ = Base.$;
    
        function Transport( opts ) {
            var me = this;
    
            opts = me.options = $.extend( true, {}, Transport.options, opts || {} );
            RuntimeClient.call( this, &#x27;Transport&#x27; );
    
            this._blob = null;
            this._formData = opts.formData || {};
            this._headers = opts.headers || {};
    
            this.on( &#x27;progress&#x27;, this._timeout );
            this.on( &#x27;load error&#x27;, function() {
                me.trigger( &#x27;progress&#x27;, 1 );
                clearTimeout( me._timer );
            });
        }
    
        Transport.options = {
            server: &#x27;&#x27;,
            method: &#x27;POST&#x27;,
    
            // 跨域时，是否允许携带cookie, 只有html5 runtime才有效
            withCredentials: false,
            fileVal: &#x27;file&#x27;,
            timeout: 2 * 60 * 1000,    // 2分钟
            formData: {},
            headers: {},
            sendAsBinary: false
        };
    
        $.extend( Transport.prototype, {
    
            // 添加Blob, 只能添加一次，最后一次有效。
            appendBlob: function( key, blob, filename ) {
                var me = this,
                    opts = me.options;
    
                if ( me.getRuid() ) {
                    me.disconnectRuntime();
                }
    
                // 连接到blob归属的同一个runtime.
                me.connectRuntime( blob.ruid, function() {
                    me.exec(&#x27;init&#x27;);
                });
    
                me._blob = blob;
                opts.fileVal = key || opts.fileVal;
                opts.filename = filename || opts.filename;
            },
    
            // 添加其他字段
            append: function( key, value ) {
                if ( typeof key === &#x27;object&#x27; ) {
                    $.extend( this._formData, key );
                } else {
                    this._formData[ key ] = value;
                }
            },
    
            setRequestHeader: function( key, value ) {
                if ( typeof key === &#x27;object&#x27; ) {
                    $.extend( this._headers, key );
                } else {
                    this._headers[ key ] = value;
                }
            },
    
            send: function( method ) {
                this.exec( &#x27;send&#x27;, method );
                this._timeout();
            },
    
            abort: function() {
                clearTimeout( this._timer );
                return this.exec(&#x27;abort&#x27;);
            },
    
            destroy: function() {
                this.trigger(&#x27;destroy&#x27;);
                this.off();
                this.exec(&#x27;destroy&#x27;);
                this.disconnectRuntime();
            },
    
            getResponse: function() {
                return this.exec(&#x27;getResponse&#x27;);
            },
    
            getResponseAsJson: function() {
                return this.exec(&#x27;getResponseAsJson&#x27;);
            },
    
            getStatus: function() {
                return this.exec(&#x27;getStatus&#x27;);
            },
    
            _timeout: function() {
                var me = this,
                    duration = me.options.timeout;
    
                if ( !duration ) {
                    return;
                }
    
                clearTimeout( me._timer );
                me._timer = setTimeout(function() {
                    me.abort();
                    me.trigger( &#x27;error&#x27;, &#x27;timeout&#x27; );
                }, duration );
            }
    
        });
    
        // 让Transport具备事件功能。
        Mediator.installTo( Transport.prototype );
    
        return Transport;
    });
    /**
     * @fileOverview 负责文件上传相关。
     */
    define(&#x27;widgets/upload&#x27;,[
        &#x27;base&#x27;,
        &#x27;uploader&#x27;,
        &#x27;file&#x27;,
        &#x27;lib/transport&#x27;,
        &#x27;widgets/widget&#x27;
    ], function( Base, Uploader, WUFile, Transport ) {
    
        var $ = Base.$,
            isPromise = Base.isPromise,
            Status = WUFile.Status;
    
        // 添加默认配置项
        $.extend( Uploader.options, {
    
    
            /**
             * @property {Boolean} [prepareNextFile=false]
             * @namespace options
             * @for Uploader
             * @description 是否允许在文件传输时提前把下一个文件准备好。
             * 对于一个文件的准备工作比较耗时，比如图片压缩，md5序列化。
             * 如果能提前在当前文件传输期处理，可以节省总体耗时。
             */
            prepareNextFile: false,
    
            /**
             * @property {Boolean} [chunked=false]
             * @namespace options
             * @for Uploader
             * @description 是否要分片处理大文件上传。
             */
            chunked: false,
    
            /**
             * @property {Boolean} [chunkSize=5242880]
             * @namespace options
             * @for Uploader
             * @description 如果要分片，分多大一片？ 默认大小为5M.
             */
            chunkSize: 5 * 1024 * 1024,
    
            /**
             * @property {Boolean} [chunkRetry=2]
             * @namespace options
             * @for Uploader
             * @description 如果某个分片由于网络问题出错，允许自动重传多少次？
             */
            chunkRetry: 2,
    
            /**
             * @property {Boolean} [threads=3]
             * @namespace options
             * @for Uploader
             * @description 上传并发数。允许同时最大上传进程数。
             */
            threads: 3,
    
    
            /**
             * @property {Object} [formData={}]
             * @namespace options
             * @for Uploader
             * @description 文件上传请求的参数表，每次发送都会发送此对象中的参数。
             */
            formData: {}
    
            /**
             * @property {Object} [fileVal=&#x27;file&#x27;]
             * @namespace options
             * @for Uploader
             * @description 设置文件上传域的name。
             */
    
            /**
             * @property {Object} [method=&#x27;POST&#x27;]
             * @namespace options
             * @for Uploader
             * @description 文件上传方式，&#x60;POST&#x60;或者&#x60;GET&#x60;。
             */
    
            /**
             * @property {Object} [sendAsBinary=false]
             * @namespace options
             * @for Uploader
             * @description 是否已二进制的流的方式发送文件，这样整个上传内容&#x60;php://input&#x60;都为文件内容，
             * 其他参数在$_GET数组中。
             */
        });
    
        // 负责将文件切片。
        function CuteFile( file, chunkSize ) {
            var pending = [],
                blob = file.source,
                total = blob.size,
                chunks = chunkSize ? Math.ceil( total / chunkSize ) : 1,
                start = 0,
                index = 0,
                len, api;
    
            api = {
                file: file,
    
                has: function() {
                    return !!pending.length;
                },
    
                shift: function() {
                    return pending.shift();
                },
    
                unshift: function( block ) {
                    pending.unshift( block );
                }
            };
    
            while ( index &lt; chunks ) {
                len = Math.min( chunkSize, total - start );
    
                pending.push({
                    file: file,
                    start: start,
                    end: chunkSize ? (start + len) : total,
                    total: total,
                    chunks: chunks,
                    chunk: index++,
                    cuted: api
                });
                start += len;
            }
    
            file.blocks = pending.concat();
            file.remaning = pending.length;
    
            return api;
        }
    
        Uploader.register({
            name: &#x27;upload&#x27;,
    
            init: function() {
                var owner = this.owner,
                    me = this;
    
                this.runing = false;
                this.progress = false;
    
                owner
                    .on( &#x27;startUpload&#x27;, function() {
                        me.progress = true;
                    })
                    .on( &#x27;uploadFinished&#x27;, function() {
                        me.progress = false;
                    });
    
                // 记录当前正在传的数据，跟threads相关
                this.pool = [];
    
                // 缓存分好片的文件。
                this.stack = [];
    
                // 缓存即将上传的文件。
                this.pending = [];
    
                // 跟踪还有多少分片在上传中但是没有完成上传。
                this.remaning = 0;
                this.__tick = Base.bindFn( this._tick, this );
    
                owner.on( &#x27;uploadComplete&#x27;, function( file ) {
                    
                    // 把其他块取消了。
                    file.blocks &amp;&amp; $.each( file.blocks, function( _, v ) {
                        v.transport &amp;&amp; (v.transport.abort(), v.transport.destroy());
                        delete v.transport;
                    });
    
                    delete file.blocks;
                    delete file.remaning;
                });
            },
    
            reset: function() {
                this.request( &#x27;stop-upload&#x27;, true );
                this.runing = false;
                this.pool = [];
                this.stack = [];
                this.pending = [];
                this.remaning = 0;
                this._trigged = false;
                this._promise = null;
            },
    
            /**
             * @event startUpload
             * @description 当开始上传流程时触发。
             * @for  Uploader
             */
    
            /**
             * 开始上传。此方法可以从初始状态调用开始上传流程，也可以从暂停状态调用，继续上传流程。
             *
             * 可以指定开始某一个文件。
             * @grammar upload() =&gt; undefined
             * @grammar upload( file | fileId) =&gt; undefined
             * @method upload
             * @for  Uploader
             */
            startUpload: function(file) {
                var me = this;
    
                // 移出invalid的文件
                $.each( me.request( &#x27;get-files&#x27;, Status.INVALID ), function() {
                    me.request( &#x27;remove-file&#x27;, this );
                });
    
                // 如果指定了开始某个文件，则只开始指定文件。
                if ( file ) {
                    file = file.id ? file : me.request( &#x27;get-file&#x27;, file );
    
                    if (file.getStatus() === Status.INTERRUPT) {
                        $.each( me.pool, function( _, v ) {
                        
                            // 之前暂停过。
                            if (v.file !== file) {
                                return;
                            }
    
                            v.transport &amp;&amp; v.transport.send();
                        });
                        
                        file.setStatus( Status.QUEUED );
                    } else if (file.getStatus() === Status.PROGRESS) {
                        return;
                    } else {
                        file.setStatus( Status.QUEUED );
                    }
                } else {
                    $.each( me.request( &#x27;get-files&#x27;, [ Status.INITED ] ), function() {
                        this.setStatus( Status.QUEUED );
                    });
                }
    
                if ( me.runing ) {
                    return;
                }
    
                me.runing = true;
    
                // 如果有暂停的，则续传
                $.each( me.pool, function( _, v ) {
                    var file = v.file;
    
                    if ( file.getStatus() === Status.INTERRUPT ) {
                        file.setStatus( Status.PROGRESS );
                        me._trigged = false;
                        v.transport &amp;&amp; v.transport.send();
                    }
                });
    
                file || $.each( me.request( &#x27;get-files&#x27;,
                        Status.INTERRUPT ), function() {
                    this.setStatus( Status.PROGRESS );
                });
    
                me._trigged = false;
                Base.nextTick( me.__tick );
                me.owner.trigger(&#x27;startUpload&#x27;);
            },
    
            /**
             * @event stopUpload
             * @description 当开始上传流程暂停时触发。
             * @for  Uploader
             */
    
            /**
             * 暂停上传。第一个参数为是否中断上传当前正在上传的文件。
             *
             * 如果第一个参数是文件，则只暂停指定文件。
             * @grammar stop() =&gt; undefined
             * @grammar stop( true ) =&gt; undefined
             * @grammar stop( file ) =&gt; undefined
             * @method stop
             * @for  Uploader
             */
            stopUpload: function( file, interrupt ) {
                var me = this;
    
                if (file === true) {
                    interrupt = file;
                    file = null;
                }
    
                if ( me.runing === false ) {
                    return;
                }
    
                // 如果只是暂停某个文件。
                if ( file ) {
                    file = file.id ? file : me.request( &#x27;get-file&#x27;, file );
    
                    if ( file.getStatus() !== Status.PROGRESS &amp;&amp;
                            file.getStatus() !== Status.QUEUED ) {
                        return;
                    }
    
                    file.setStatus( Status.INTERRUPT );
                    $.each( me.pool, function( _, v ) {
                        
                        // 只 abort 指定的文件。
                        if (v.file !== file) {
                            return;
                        }
    
                        v.transport &amp;&amp; v.transport.abort();
                        me._putback(v);
                        me._popBlock(v);
                    });
    
                    return Base.nextTick( me.__tick );
                }
    
                me.runing = false;
    
                if (this._promise &amp;&amp; this._promise.file) {
                    this._promise.file.setStatus( Status.INTERRUPT );
                }
    
                interrupt &amp;&amp; $.each( me.pool, function( _, v ) {
                    v.transport &amp;&amp; v.transport.abort();
                    v.file.setStatus( Status.INTERRUPT );
                });
    
                me.owner.trigger(&#x27;stopUpload&#x27;);
            },
    
            /**
             * @method cancelFile
             * @grammar cancelFile( file ) =&gt; undefined
             * @grammar cancelFile( id ) =&gt; undefined
             * @param {File|id} file File对象或这File对象的id
             * @description 标记文件状态为已取消, 同时将中断文件传输。
             * @for  Uploader
             * @example
             *
             * $li.on(&#x27;click&#x27;, &#x27;.remove-this&#x27;, function() {
             *     uploader.cancelFile( file );
             * })
             */
            cancelFile: function( file ) {
                file = file.id ? file : this.request( &#x27;get-file&#x27;, file );
    
                // 如果正在上传。
                file.blocks &amp;&amp; $.each( file.blocks, function( _, v ) {
                    var _tr = v.transport;
    
                    if ( _tr ) {
                        _tr.abort();
                        _tr.destroy();
                        delete v.transport;
                    }
                });
    
                file.setStatus( Status.CANCELLED );
                this.owner.trigger( &#x27;fileDequeued&#x27;, file );
            },
    
            /**
             * 判断&#x60;Uplaode&#x60;r是否正在上传中。
             * @grammar isInProgress() =&gt; Boolean
             * @method isInProgress
             * @for  Uploader
             */
            isInProgress: function() {
                return !!this.progress;
            },
    
            _getStats: function() {
                return this.request(&#x27;get-stats&#x27;);
            },
    
            /**
             * 掉过一个文件上传，直接标记指定文件为已上传状态。
             * @grammar skipFile( file ) =&gt; undefined
             * @method skipFile
             * @for  Uploader
             */
            skipFile: function( file, status ) {
                file = file.id ? file : this.request( &#x27;get-file&#x27;, file );
    
                file.setStatus( status || Status.COMPLETE );
                file.skipped = true;
    
                // 如果正在上传。
                file.blocks &amp;&amp; $.each( file.blocks, function( _, v ) {
                    var _tr = v.transport;
    
                    if ( _tr ) {
                        _tr.abort();
                        _tr.destroy();
                        delete v.transport;
                    }
                });
    
                this.owner.trigger( &#x27;uploadSkip&#x27;, file );
            },
    
            /**
             * @event uploadFinished
             * @description 当所有文件上传结束时触发。
             * @for  Uploader
             */
            _tick: function() {
                var me = this,
                    opts = me.options,
                    fn, val;
    
                // 上一个promise还没有结束，则等待完成后再执行。
                if ( me._promise ) {
                    return me._promise.always( me.__tick );
                }
    
                // 还有位置，且还有文件要处理的话。
                if ( me.pool.length &lt; opts.threads &amp;&amp; (val = me._nextBlock()) ) {
                    me._trigged = false;
    
                    fn = function( val ) {
                        me._promise = null;
    
                        // 有可能是reject过来的，所以要检测val的类型。
                        val &amp;&amp; val.file &amp;&amp; me._startSend( val );
                        Base.nextTick( me.__tick );
                    };
    
                    me._promise = isPromise( val ) ? val.always( fn ) : fn( val );
    
                // 没有要上传的了，且没有正在传输的了。
                } else if ( !me.remaning &amp;&amp; !me._getStats().numOfQueue &amp;&amp;
                    !me._getStats().numofInterrupt ) {
                    me.runing = false;
    
                    me._trigged || Base.nextTick(function() {
                        me.owner.trigger(&#x27;uploadFinished&#x27;);
                    });
                    me._trigged = true;
                }
            },
    
            _putback: function(block) {
                var idx;
    
                block.cuted.unshift(block);
                idx = this.stack.indexOf(block.cuted);
    
                if (!~idx) {
                    this.stack.unshift(block.cuted);
                }
            },
    
            _getStack: function() {
                var i = 0,
                    act;
    
                while ( (act = this.stack[ i++ ]) ) {
                    if ( act.has() &amp;&amp; act.file.getStatus() === Status.PROGRESS ) {
                        return act;
                    } else if (!act.has() ||
                            act.file.getStatus() !== Status.PROGRESS &amp;&amp;
                            act.file.getStatus() !== Status.INTERRUPT ) {
    
                        // 把已经处理完了的，或者，状态为非 progress（上传中）、
                        // interupt（暂停中） 的移除。
                        this.stack.splice( --i, 1 );
                    }
                }
    
                return null;
            },
    
            _nextBlock: function() {
                var me = this,
                    opts = me.options,
                    act, next, done, preparing;
    
                // 如果当前文件还有没有需要传输的，则直接返回剩下的。
                if ( (act = this._getStack()) ) {
    
                    // 是否提前准备下一个文件
                    if ( opts.prepareNextFile &amp;&amp; !me.pending.length ) {
                        me._prepareNextFile();
                    }
    
                    return act.shift();
    
                // 否则，如果正在运行，则准备下一个文件，并等待完成后返回下个分片。
                } else if ( me.runing ) {
    
                    // 如果缓存中有，则直接在缓存中取，没有则去queue中取。
                    if ( !me.pending.length &amp;&amp; me._getStats().numOfQueue ) {
                        me._prepareNextFile();
                    }
    
                    next = me.pending.shift();
                    done = function( file ) {
                        if ( !file ) {
                            return null;
                        }
                            
                        act = CuteFile( file, opts.chunked ? opts.chunkSize : 0 );
                        me.stack.push(act);
                        return act.shift();
                    };
    
                    // 文件可能还在prepare中，也有可能已经完全准备好了。
                    if ( isPromise( next) ) {
                        preparing = next.file;
                        next = next[ next.pipe ? &#x27;pipe&#x27; : &#x27;then&#x27; ]( done );
                        next.file = preparing;
                        return next;
                    }
    
                    return done( next );
                }
            },
    
    
            /**
             * @event uploadStart
             * @param {File} file File对象
             * @description 某个文件开始上传前触发，一个文件只会触发一次。
             * @for  Uploader
             */
            _prepareNextFile: function() {
                var me = this,
                    file = me.request(&#x27;fetch-file&#x27;),
                    pending = me.pending,
                    promise;
    
                if ( file ) {
                    promise = me.request( &#x27;before-send-file&#x27;, file, function() {
    
                        // 有可能文件被skip掉了。文件被skip掉后，状态坑定不是Queued.
                        if ( file.getStatus() === Status.PROGRESS || 
                            file.getStatus() === Status.INTERRUPT ) {
                            return file;
                        }
    
                        return me._finishFile( file );
                    });
    
                    me.owner.trigger( &#x27;uploadStart&#x27;, file );
                    file.setStatus( Status.PROGRESS );
    
                    promise.file = file;
    
                    // 如果还在pending中，则替换成文件本身。
                    promise.done(function() {
                        var idx = $.inArray( promise, pending );
    
                        ~idx &amp;&amp; pending.splice( idx, 1, file );
                    });
    
                    // befeore-send-file的钩子就有错误发生。
                    promise.fail(function( reason ) {
                        file.setStatus( Status.ERROR, reason );
                        me.owner.trigger( &#x27;uploadError&#x27;, file, reason );
                        me.owner.trigger( &#x27;uploadComplete&#x27;, file );
                    });
    
                    pending.push( promise );
                }
            },
    
            // 让出位置了，可以让其他分片开始上传
            _popBlock: function( block ) {
                var idx = $.inArray( block, this.pool );
    
                this.pool.splice( idx, 1 );
                block.file.remaning--;
                this.remaning--;
            },
    
            // 开始上传，可以被掉过。如果promise被reject了，则表示跳过此分片。
            _startSend: function( block ) {
                var me = this,
                    file = block.file,
                    promise;
    
                // 有可能在 before-send-file 的 promise 期间改变了文件状态。
                // 如：暂停，取消
                // 我们不能中断 promise, 但是可以在 promise 完后，不做上传操作。
                if ( file.getStatus() !== Status.PROGRESS ) {
                    
                    // 如果是中断，则还需要放回去。
                    if (file.getStatus() === Status.INTERRUPT) {
                        me._putback(block);
                    }
    
                    return;
                }
    
                me.pool.push( block );
                me.remaning++;
    
                // 如果没有分片，则直接使用原始的。
                // 不会丢失content-type信息。
                block.blob = block.chunks === 1 ? file.source :
                        file.source.slice( block.start, block.end );
    
                // hook, 每个分片发送之前可能要做些异步的事情。
                promise = me.request( &#x27;before-send&#x27;, block, function() {
    
                    // 有可能文件已经上传出错了，所以不需要再传输了。
                    if ( file.getStatus() === Status.PROGRESS ) {
                        me._doSend( block );
                    } else {
                        me._popBlock( block );
                        Base.nextTick( me.__tick );
                    }
                });
    
                // 如果为fail了，则跳过此分片。
                promise.fail(function() {
                    if ( file.remaning === 1 ) {
                        me._finishFile( file ).always(function() {
                            block.percentage = 1;
                            me._popBlock( block );
                            me.owner.trigger( &#x27;uploadComplete&#x27;, file );
                            Base.nextTick( me.__tick );
                        });
                    } else {
                        block.percentage = 1;
                        me._popBlock( block );
                        Base.nextTick( me.__tick );
                    }
                });
            },
    
    
            /**
             * @event uploadBeforeSend
             * @param {Object} object
             * @param {Object} data 默认的上传参数，可以扩展此对象来控制上传参数。
             * @param {Object} headers 可以扩展此对象来控制上传头部。
             * @description 当某个文件的分块在发送前触发，主要用来询问是否要添加附带参数，大文件在开起分片上传的前提下此事件可能会触发多次。
             * @for  Uploader
             */
    
            /**
             * @event uploadAccept
             * @param {Object} object
             * @param {Object} ret 服务端的返回数据，json格式，如果服务端不是json格式，从ret._raw中取数据，自行解析。
             * @description 当某个文件上传到服务端响应后，会派送此事件来询问服务端响应是否有效。如果此事件handler返回值为&#x60;false&#x60;, 则此文件将派送&#x60;server&#x60;类型的&#x60;uploadError&#x60;事件。
             * @for  Uploader
             */
    
            /**
             * @event uploadProgress
             * @param {File} file File对象
             * @param {Number} percentage 上传进度
             * @description 上传过程中触发，携带上传进度。
             * @for  Uploader
             */
    
    
            /**
             * @event uploadError
             * @param {File} file File对象
             * @param {String} reason 出错的code
             * @description 当文件上传出错时触发。
             * @for  Uploader
             */
    
            /**
             * @event uploadSuccess
             * @param {File} file File对象
             * @param {Object} response 服务端返回的数据
             * @description 当文件上传成功时触发。
             * @for  Uploader
             */
    
            /**
             * @event uploadComplete
             * @param {File} [file] File对象
             * @description 不管成功或者失败，文件上传完成时触发。
             * @for  Uploader
             */
    
            // 做上传操作。
            _doSend: function( block ) {
                var me = this,
                    owner = me.owner,
                    opts = me.options,
                    file = block.file,
                    tr = new Transport( opts ),
                    data = $.extend({}, opts.formData ),
                    headers = $.extend({}, opts.headers ),
                    requestAccept, ret;
    
                block.transport = tr;
    
                tr.on( &#x27;destroy&#x27;, function() {
                    delete block.transport;
                    me._popBlock( block );
                    Base.nextTick( me.__tick );
                });
    
                // 广播上传进度。以文件为单位。
                tr.on( &#x27;progress&#x27;, function( percentage ) {
                    var totalPercent = 0,
                        uploaded = 0;
    
                    // 可能没有abort掉，progress还是执行进来了。
                    // if ( !file.blocks ) {
                    //     return;
                    // }
    
                    totalPercent = block.percentage = percentage;
    
                    if ( block.chunks &gt; 1 ) {    // 计算文件的整体速度。
                        $.each( file.blocks, function( _, v ) {
                            uploaded += (v.percentage || 0) * (v.end - v.start);
                        });
    
                        totalPercent = uploaded / file.size;
                    }
    
                    owner.trigger( &#x27;uploadProgress&#x27;, file, totalPercent || 0 );
                });
    
                // 用来询问，是否返回的结果是有错误的。
                requestAccept = function( reject ) {
                    var fn;
    
                    ret = tr.getResponseAsJson() || {};
                    ret._raw = tr.getResponse();
                    fn = function( value ) {
                        reject = value;
                    };
    
                    // 服务端响应了，不代表成功了，询问是否响应正确。
                    if ( !owner.trigger( &#x27;uploadAccept&#x27;, block, ret, fn ) ) {
                        reject = reject || &#x27;server&#x27;;
                    }
    
                    return reject;
                };
    
                // 尝试重试，然后广播文件上传出错。
                tr.on( &#x27;error&#x27;, function( type, flag ) {
                    block.retried = block.retried || 0;
    
                    // 自动重试
                    if ( block.chunks &gt; 1 &amp;&amp; ~&#x27;http,abort&#x27;.indexOf( type ) &amp;&amp;
                            block.retried &lt; opts.chunkRetry ) {
    
                        block.retried++;
                        tr.send();
    
                    } else {
    
                        // http status 500 ~ 600
                        if ( !flag &amp;&amp; type === &#x27;server&#x27; ) {
                            type = requestAccept( type );
                        }
    
                        file.setStatus( Status.ERROR, type );
                        owner.trigger( &#x27;uploadError&#x27;, file, type );
                        owner.trigger( &#x27;uploadComplete&#x27;, file );
                    }
                });
    
                // 上传成功
                tr.on( &#x27;load&#x27;, function() {
                    var reason;
    
                    // 如果非预期，转向上传出错。
                    if ( (reason = requestAccept()) ) {
                        tr.trigger( &#x27;error&#x27;, reason, true );
                        return;
                    }
    
                    // 全部上传完成。
                    if ( file.remaning === 1 ) {
                        me._finishFile( file, ret );
                    } else {
                        tr.destroy();
                    }
                });
    
                // 配置默认的上传字段。
                data = $.extend( data, {
                    id: file.id,
                    name: file.name,
                    type: file.type,
                    lastModifiedDate: file.lastModifiedDate,
                    size: file.size
                });
    
                block.chunks &gt; 1 &amp;&amp; $.extend( data, {
                    chunks: block.chunks,
                    chunk: block.chunk
                });
    
                // 在发送之间可以添加字段什么的。。。
                // 如果默认的字段不够使用，可以通过监听此事件来扩展
                owner.trigger( &#x27;uploadBeforeSend&#x27;, block, data, headers );
    
                // 开始发送。
                tr.appendBlob( opts.fileVal, block.blob, file.name );
                tr.append( data );
                tr.setRequestHeader( headers );
                tr.send();
            },
    
            // 完成上传。
            _finishFile: function( file, ret, hds ) {
                var owner = this.owner;
    
                return owner
                        .request( &#x27;after-send-file&#x27;, arguments, function() {
                            file.setStatus( Status.COMPLETE );
                            owner.trigger( &#x27;uploadSuccess&#x27;, file, ret, hds );
                        })
                        .fail(function( reason ) {
    
                            // 如果外部已经标记为invalid什么的，不再改状态。
                            if ( file.getStatus() === Status.PROGRESS ) {
                                file.setStatus( Status.ERROR, reason );
                            }
    
                            owner.trigger( &#x27;uploadError&#x27;, file, reason );
                        })
                        .always(function() {
                            owner.trigger( &#x27;uploadComplete&#x27;, file );
                        });
            }
    
        });
    });
    /**
     * @fileOverview 各种验证，包括文件总大小是否超出、单文件是否超出和文件是否重复。
     */
    
    define(&#x27;widgets/validator&#x27;,[
        &#x27;base&#x27;,
        &#x27;uploader&#x27;,
        &#x27;file&#x27;,
        &#x27;widgets/widget&#x27;
    ], function( Base, Uploader, WUFile ) {
    
        var $ = Base.$,
            validators = {},
            api;
    
        /**
         * @event error
         * @param {String} type 错误类型。
         * @description 当validate不通过时，会以派送错误事件的形式通知调用者。通过&#x60;upload.on(&#x27;error&#x27;, handler)&#x60;可以捕获到此类错误，目前有以下错误会在特定的情况下派送错来。
         *
         * * &#x60;Q_EXCEED_NUM_LIMIT&#x60; 在设置了&#x60;fileNumLimit&#x60;且尝试给&#x60;uploader&#x60;添加的文件数量超出这个值时派送。
         * * &#x60;Q_EXCEED_SIZE_LIMIT&#x60; 在设置了&#x60;Q_EXCEED_SIZE_LIMIT&#x60;且尝试给&#x60;uploader&#x60;添加的文件总大小超出这个值时派送。
         * * &#x60;Q_TYPE_DENIED&#x60; 当文件类型不满足时触发。。
         * @for  Uploader
         */
    
        // 暴露给外面的api
        api = {
    
            // 添加验证器
            addValidator: function( type, cb ) {
                validators[ type ] = cb;
            },
    
            // 移除验证器
            removeValidator: function( type ) {
                delete validators[ type ];
            }
        };
    
        // 在Uploader初始化的时候启动Validators的初始化
        Uploader.register({
            name: &#x27;validator&#x27;,
    
            init: function() {
                var me = this;
                Base.nextTick(function() {
                    $.each( validators, function() {
                        this.call( me.owner );
                    });
                });
            }
        });
    
        /**
         * @property {int} [fileNumLimit=undefined]
         * @namespace options
         * @for Uploader
         * @description 验证文件总数量, 超出则不允许加入队列。
         */
        api.addValidator( &#x27;fileNumLimit&#x27;, function() {
            var uploader = this,
                opts = uploader.options,
                count = 0,
                max = parseInt( opts.fileNumLimit, 10 ),
                flag = true;
    
            if ( !max ) {
                return;
            }
    
            uploader.on( &#x27;beforeFileQueued&#x27;, function( file ) {
    
                if ( count &gt;= max &amp;&amp; flag ) {
                    flag = false;
                    this.trigger( &#x27;error&#x27;, &#x27;Q_EXCEED_NUM_LIMIT&#x27;, max, file );
                    setTimeout(function() {
                        flag = true;
                    }, 1 );
                }
    
                return count &gt;= max ? false : true;
            });
    
            uploader.on( &#x27;fileQueued&#x27;, function() {
                count++;
            });
    
            uploader.on( &#x27;fileDequeued&#x27;, function() {
                count--;
            });
    
            uploader.on( &#x27;reset&#x27;, function() {
                count = 0;
            });
        });
    
    
        /**
         * @property {int} [fileSizeLimit=undefined]
         * @namespace options
         * @for Uploader
         * @description 验证文件总大小是否超出限制, 超出则不允许加入队列。
         */
        api.addValidator( &#x27;fileSizeLimit&#x27;, function() {
            var uploader = this,
                opts = uploader.options,
                count = 0,
                max = parseInt( opts.fileSizeLimit, 10 ),
                flag = true;
    
            if ( !max ) {
                return;
            }
    
            uploader.on( &#x27;beforeFileQueued&#x27;, function( file ) {
                var invalid = count + file.size &gt; max;
    
                if ( invalid &amp;&amp; flag ) {
                    flag = false;
                    this.trigger( &#x27;error&#x27;, &#x27;Q_EXCEED_SIZE_LIMIT&#x27;, max, file );
                    setTimeout(function() {
                        flag = true;
                    }, 1 );
                }
    
                return invalid ? false : true;
            });
    
            uploader.on( &#x27;fileQueued&#x27;, function( file ) {
                count += file.size;
            });
    
            uploader.on( &#x27;fileDequeued&#x27;, function( file ) {
                count -= file.size;
            });
    
            uploader.on( &#x27;reset&#x27;, function() {
                count = 0;
            });
        });
    
        /**
         * @property {int} [fileSingleSizeLimit=undefined]
         * @namespace options
         * @for Uploader
         * @description 验证单个文件大小是否超出限制, 超出则不允许加入队列。
         */
        api.addValidator( &#x27;fileSingleSizeLimit&#x27;, function() {
            var uploader = this,
                opts = uploader.options,
                max = opts.fileSingleSizeLimit;
    
            if ( !max ) {
                return;
            }
    
            uploader.on( &#x27;beforeFileQueued&#x27;, function( file ) {
    
                if ( file.size &gt; max ) {
                    file.setStatus( WUFile.Status.INVALID, &#x27;exceed_size&#x27; );
                    this.trigger( &#x27;error&#x27;, &#x27;F_EXCEED_SIZE&#x27;, max, file );
                    return false;
                }
    
            });
    
        });
    
        /**
         * @property {Boolean} [duplicate=undefined]
         * @namespace options
         * @for Uploader
         * @description 去重， 根据文件名字、文件大小和最后修改时间来生成hash Key.
         */
        api.addValidator( &#x27;duplicate&#x27;, function() {
            var uploader = this,
                opts = uploader.options,
                mapping = {};
    
            if ( opts.duplicate ) {
                return;
            }
    
            function hashString( str ) {
                var hash = 0,
                    i = 0,
                    len = str.length,
                    _char;
    
                for ( ; i &lt; len; i++ ) {
                    _char = str.charCodeAt( i );
                    hash = _char + (hash &lt;&lt; 6) + (hash &lt;&lt; 16) - hash;
                }
    
                return hash;
            }
    
            uploader.on( &#x27;beforeFileQueued&#x27;, function( file ) {
                var hash = file.__hash || (file.__hash = hashString( file.name +
                        file.size + file.lastModifiedDate ));
    
                // 已经重复了
                if ( mapping[ hash ] ) {
                    this.trigger( &#x27;error&#x27;, &#x27;F_DUPLICATE&#x27;, file );
                    return false;
                }
            });
    
            uploader.on( &#x27;fileQueued&#x27;, function( file ) {
                var hash = file.__hash;
    
                hash &amp;&amp; (mapping[ hash ] = true);
            });
    
            uploader.on( &#x27;fileDequeued&#x27;, function( file ) {
                var hash = file.__hash;
    
                hash &amp;&amp; (delete mapping[ hash ]);
            });
    
            uploader.on( &#x27;reset&#x27;, function() {
                mapping = {};
            });
        });
    
        return api;
    });
    
    /**
     * @fileOverview Runtime管理器，负责Runtime的选择, 连接
     */
    define(&#x27;runtime/compbase&#x27;,[],function() {
    
        function CompBase( owner, runtime ) {
    
            this.owner = owner;
            this.options = owner.options;
    
            this.getRuntime = function() {
                return runtime;
            };
    
            this.getRuid = function() {
                return runtime.uid;
            };
    
            this.trigger = function() {
                return owner.trigger.apply( owner, arguments );
            };
        }
    
        return CompBase;
    });
    /**
     * @fileOverview Html5Runtime
     */
    define(&#x27;runtime/html5/runtime&#x27;,[
        &#x27;base&#x27;,
        &#x27;runtime/runtime&#x27;,
        &#x27;runtime/compbase&#x27;
    ], function( Base, Runtime, CompBase ) {
    
        var type = &#x27;html5&#x27;,
            components = {};
    
        function Html5Runtime() {
            var pool = {},
                me = this,
                destroy = this.destroy;
    
            Runtime.apply( me, arguments );
            me.type = type;
    
    
            // 这个方法的调用者，实际上是RuntimeClient
            me.exec = function( comp, fn/*, args...*/) {
                var client = this,
                    uid = client.uid,
                    args = Base.slice( arguments, 2 ),
                    instance;
    
                if ( components[ comp ] ) {
                    instance = pool[ uid ] = pool[ uid ] ||
                            new components[ comp ]( client, me );
    
                    if ( instance[ fn ] ) {
                        return instance[ fn ].apply( instance, args );
                    }
                }
            };
    
            me.destroy = function() {
                // @todo 删除池子中的所有实例
                return destroy &amp;&amp; destroy.apply( this, arguments );
            };
        }
    
        Base.inherits( Runtime, {
            constructor: Html5Runtime,
    
            // 不需要连接其他程序，直接执行callback
            init: function() {
                var me = this;
                setTimeout(function() {
                    me.trigger(&#x27;ready&#x27;);
                }, 1 );
            }
    
        });
    
        // 注册Components
        Html5Runtime.register = function( name, component ) {
            var klass = components[ name ] = Base.inherits( CompBase, component );
            return klass;
        };
    
        // 注册html5运行时。
        // 只有在支持的前提下注册。
        if ( window.Blob &amp;&amp; window.FileReader &amp;&amp; window.DataView ) {
            Runtime.addRuntime( type, Html5Runtime );
        }
    
        return Html5Runtime;
    });
    /**
     * @fileOverview Blob Html实现
     */
    define(&#x27;runtime/html5/blob&#x27;,[
        &#x27;runtime/html5/runtime&#x27;,
        &#x27;lib/blob&#x27;
    ], function( Html5Runtime, Blob ) {
    
        return Html5Runtime.register( &#x27;Blob&#x27;, {
            slice: function( start, end ) {
                var blob = this.owner.source,
                    slice = blob.slice || blob.webkitSlice || blob.mozSlice;
    
                blob = slice.call( blob, start, end );
    
                return new Blob( this.getRuid(), blob );
            }
        });
    });
    /**
     * @fileOverview FilePaste
     */
    define(&#x27;runtime/html5/dnd&#x27;,[
        &#x27;base&#x27;,
        &#x27;runtime/html5/runtime&#x27;,
        &#x27;lib/file&#x27;
    ], function( Base, Html5Runtime, File ) {
    
        var $ = Base.$,
            prefix = &#x27;webuploader-dnd-&#x27;;
    
        return Html5Runtime.register( &#x27;DragAndDrop&#x27;, {
            init: function() {
                var elem = this.elem = this.options.container;
    
                this.dragEnterHandler = Base.bindFn( this._dragEnterHandler, this );
                this.dragOverHandler = Base.bindFn( this._dragOverHandler, this );
                this.dragLeaveHandler = Base.bindFn( this._dragLeaveHandler, this );
                this.dropHandler = Base.bindFn( this._dropHandler, this );
                this.dndOver = false;
    
                elem.on( &#x27;dragenter&#x27;, this.dragEnterHandler );
                elem.on( &#x27;dragover&#x27;, this.dragOverHandler );
                elem.on( &#x27;dragleave&#x27;, this.dragLeaveHandler );
                elem.on( &#x27;drop&#x27;, this.dropHandler );
    
                if ( this.options.disableGlobalDnd ) {
                    $( document ).on( &#x27;dragover&#x27;, this.dragOverHandler );
                    $( document ).on( &#x27;drop&#x27;, this.dropHandler );
                }
            },
    
            _dragEnterHandler: function( e ) {
                var me = this,
                    denied = me._denied || false,
                    items;
    
                e = e.originalEvent || e;
    
                if ( !me.dndOver ) {
                    me.dndOver = true;
    
                    // 注意只有 chrome 支持。
                    items = e.dataTransfer.items;
    
                    if ( items &amp;&amp; items.length ) {
                        me._denied = denied = !me.trigger( &#x27;accept&#x27;, items );
                    }
    
                    me.elem.addClass( prefix + &#x27;over&#x27; );
                    me.elem[ denied ? &#x27;addClass&#x27; :
                            &#x27;removeClass&#x27; ]( prefix + &#x27;denied&#x27; );
                }
    
                e.dataTransfer.dropEffect = denied ? &#x27;none&#x27; : &#x27;copy&#x27;;
    
                return false;
            },
    
            _dragOverHandler: function( e ) {
                // 只处理框内的。
                var parentElem = this.elem.parent().get( 0 );
                if ( parentElem &amp;&amp; !$.contains( parentElem, e.currentTarget ) ) {
                    return false;
                }
    
                clearTimeout( this._leaveTimer );
                this._dragEnterHandler.call( this, e );
    
                return false;
            },
    
            _dragLeaveHandler: function() {
                var me = this,
                    handler;
    
                handler = function() {
                    me.dndOver = false;
                    me.elem.removeClass( prefix + &#x27;over &#x27; + prefix + &#x27;denied&#x27; );
                };
    
                clearTimeout( me._leaveTimer );
                me._leaveTimer = setTimeout( handler, 100 );
                return false;
            },
    
            _dropHandler: function( e ) {
                var me = this,
                    ruid = me.getRuid(),
                    parentElem = me.elem.parent().get( 0 ),
                    dataTransfer, data;
    
                // 只处理框内的。
                if ( parentElem &amp;&amp; !$.contains( parentElem, e.currentTarget ) ) {
                    return false;
                }
    
                e = e.originalEvent || e;
                dataTransfer = e.dataTransfer;
    
                // 如果是页面内拖拽，还不能处理，不阻止事件。
                // 此处 ie11 下会报参数错误，
                try {
                    data = dataTransfer.getData(&#x27;text/html&#x27;);
                } catch( err ) {
                }
    
                if ( data ) {
                    return;
                }
    
                me._getTansferFiles( dataTransfer, function( results ) {
                    me.trigger( &#x27;drop&#x27;, $.map( results, function( file ) {
                        return new File( ruid, file );
                    }) );
                });
    
                me.dndOver = false;
                me.elem.removeClass( prefix + &#x27;over&#x27; );
                return false;
            },
    
            // 如果传入 callback 则去查看文件夹，否则只管当前文件夹。
            _getTansferFiles: function( dataTransfer, callback ) {
                var results  = [],
                    promises = [],
                    items, files, file, item, i, len, canAccessFolder;
    
                items = dataTransfer.items;
                files = dataTransfer.files;
    
                canAccessFolder = !!(items &amp;&amp; items[ 0 ].webkitGetAsEntry);
    
                for ( i = 0, len = files.length; i &lt; len; i++ ) {
                    file = files[ i ];
                    item = items &amp;&amp; items[ i ];
    
                    if ( canAccessFolder &amp;&amp; item.webkitGetAsEntry().isDirectory ) {
    
                        promises.push( this._traverseDirectoryTree(
                                item.webkitGetAsEntry(), results ) );
                    } else {
                        results.push( file );
                    }
                }
    
                Base.when.apply( Base, promises ).done(function() {
    
                    if ( !results.length ) {
                        return;
                    }
    
                    callback( results );
                });
            },
    
            _traverseDirectoryTree: function( entry, results ) {
                var deferred = Base.Deferred(),
                    me = this;
    
                if ( entry.isFile ) {
                    entry.file(function( file ) {
                        results.push( file );
                        deferred.resolve();
                    });
                } else if ( entry.isDirectory ) {
                    entry.createReader().readEntries(function( entries ) {
                        var len = entries.length,
                            promises = [],
                            arr = [],    // 为了保证顺序。
                            i;
    
                        for ( i = 0; i &lt; len; i++ ) {
                            promises.push( me._traverseDirectoryTree(
                                    entries[ i ], arr ) );
                        }
    
                        Base.when.apply( Base, promises ).then(function() {
                            results.push.apply( results, arr );
                            deferred.resolve();
                        }, deferred.reject );
                    });
                }
    
                return deferred.promise();
            },
    
            destroy: function() {
                var elem = this.elem;
    
                // 还没 init 就调用 destroy
                if (!elem) {
                    return;
                }
                
                elem.off( &#x27;dragenter&#x27;, this.dragEnterHandler );
                elem.off( &#x27;dragover&#x27;, this.dragOverHandler );
                elem.off( &#x27;dragleave&#x27;, this.dragLeaveHandler );
                elem.off( &#x27;drop&#x27;, this.dropHandler );
    
                if ( this.options.disableGlobalDnd ) {
                    $( document ).off( &#x27;dragover&#x27;, this.dragOverHandler );
                    $( document ).off( &#x27;drop&#x27;, this.dropHandler );
                }
            }
        });
    });
    
    /**
     * @fileOverview FilePaste
     */
    define(&#x27;runtime/html5/filepaste&#x27;,[
        &#x27;base&#x27;,
        &#x27;runtime/html5/runtime&#x27;,
        &#x27;lib/file&#x27;
    ], function( Base, Html5Runtime, File ) {
    
        return Html5Runtime.register( &#x27;FilePaste&#x27;, {
            init: function() {
                var opts = this.options,
                    elem = this.elem = opts.container,
                    accept = &#x27;.*&#x27;,
                    arr, i, len, item;
    
                // accetp的mimeTypes中生成匹配正则。
                if ( opts.accept ) {
                    arr = [];
    
                    for ( i = 0, len = opts.accept.length; i &lt; len; i++ ) {
                        item = opts.accept[ i ].mimeTypes;
                        item &amp;&amp; arr.push( item );
                    }
    
                    if ( arr.length ) {
                        accept = arr.join(&#x27;,&#x27;);
                        accept = accept.replace( /,/g, &#x27;|&#x27; ).replace( /\*/g, &#x27;.*&#x27; );
                    }
                }
                this.accept = accept = new RegExp( accept, &#x27;i&#x27; );
                this.hander = Base.bindFn( this._pasteHander, this );
                elem.on( &#x27;paste&#x27;, this.hander );
            },
    
            _pasteHander: function( e ) {
                var allowed = [],
                    ruid = this.getRuid(),
                    items, item, blob, i, len;
    
                e = e.originalEvent || e;
                items = e.clipboardData.items;
    
                for ( i = 0, len = items.length; i &lt; len; i++ ) {
                    item = items[ i ];
    
                    if ( item.kind !== &#x27;file&#x27; || !(blob = item.getAsFile()) ) {
                        continue;
                    }
    
                    allowed.push( new File( ruid, blob ) );
                }
    
                if ( allowed.length ) {
                    // 不阻止非文件粘贴（文字粘贴）的事件冒泡
                    e.preventDefault();
                    e.stopPropagation();
                    this.trigger( &#x27;paste&#x27;, allowed );
                }
            },
    
            destroy: function() {
                this.elem.off( &#x27;paste&#x27;, this.hander );
            }
        });
    });
    
    /**
     * @fileOverview FilePicker
     */
    define(&#x27;runtime/html5/filepicker&#x27;,[
        &#x27;base&#x27;,
        &#x27;runtime/html5/runtime&#x27;
    ], function( Base, Html5Runtime ) {
    
        var $ = Base.$;
    
        return Html5Runtime.register( &#x27;FilePicker&#x27;, {
            init: function() {
                var container = this.getRuntime().getContainer(),
                    me = this,
                    owner = me.owner,
                    opts = me.options,
                    label = this.label = $( document.createElement(&#x27;label&#x27;) ),
                    input =  this.input = $( document.createElement(&#x27;input&#x27;) ),
                    arr, i, len, mouseHandler;
    
                input.attr( &#x27;type&#x27;, &#x27;file&#x27; );
                input.attr( &#x27;name&#x27;, opts.name );
                input.addClass(&#x27;webuploader-element-invisible&#x27;);
    
                label.on( &#x27;click&#x27;, function() {
                    input.trigger(&#x27;click&#x27;);
                });
    
                label.css({
                    opacity: 0,
                    width: &#x27;100%&#x27;,
                    height: &#x27;100%&#x27;,
                    display: &#x27;block&#x27;,
                    cursor: &#x27;pointer&#x27;,
                    background: &#x27;#ffffff&#x27;
                });
    
                if ( opts.multiple ) {
                    input.attr( &#x27;multiple&#x27;, &#x27;multiple&#x27; );
                }
    
                // @todo Firefox不支持单独指定后缀
                if ( opts.accept &amp;&amp; opts.accept.length &gt; 0 ) {
                    arr = [];
    
                    for ( i = 0, len = opts.accept.length; i &lt; len; i++ ) {
                        arr.push( opts.accept[ i ].mimeTypes );
                    }
    
                    input.attr( &#x27;accept&#x27;, arr.join(&#x27;,&#x27;) );
                }
    
                container.append( input );
                container.append( label );
    
                mouseHandler = function( e ) {
                    owner.trigger( e.type );
                };
    
                input.on( &#x27;change&#x27;, function( e ) {
                    var fn = arguments.callee,
                        clone;
    
                    me.files = e.target.files;
    
                    // reset input
                    clone = this.cloneNode( true );
                    clone.value = null;
                    this.parentNode.replaceChild( clone, this );
    
                    input.off();
                    input = $( clone ).on( &#x27;change&#x27;, fn )
                            .on( &#x27;mouseenter mouseleave&#x27;, mouseHandler );
    
                    owner.trigger(&#x27;change&#x27;);
                });
    
                label.on( &#x27;mouseenter mouseleave&#x27;, mouseHandler );
    
            },
    
    
            getFiles: function() {
                return this.files;
            },
    
            destroy: function() {
                this.input.off();
                this.label.off();
            }
        });
    });
    /**
     * @fileOverview Transport
     * @todo 支持chunked传输，优势：
     * 可以将大文件分成小块，挨个传输，可以提高大文件成功率，当失败的时候，也只需要重传那小部分，
     * 而不需要重头再传一次。另外断点续传也需要用chunked方式。
     */
    define(&#x27;runtime/html5/transport&#x27;,[
        &#x27;base&#x27;,
        &#x27;runtime/html5/runtime&#x27;
    ], function( Base, Html5Runtime ) {
    
        var noop = Base.noop,
            $ = Base.$;
    
        return Html5Runtime.register( &#x27;Transport&#x27;, {
            init: function() {
                this._status = 0;
                this._response = null;
            },
    
            send: function() {
                var owner = this.owner,
                    opts = this.options,
                    xhr = this._initAjax(),
                    blob = owner._blob,
                    server = opts.server,
                    formData, binary, fr;
    
                if ( opts.sendAsBinary ) {
                    server += (/\?/.test( server ) ? &#x27;&amp;&#x27; : &#x27;?&#x27;) +
                            $.param( owner._formData );
    
                    binary = blob.getSource();
                } else {
                    formData = new FormData();
                    $.each( owner._formData, function( k, v ) {
                        formData.append( k, v );
                    });
    
                    formData.append( opts.fileVal, blob.getSource(),
                            opts.filename || owner._formData.name || &#x27;&#x27; );
                }
    
                if ( opts.withCredentials &amp;&amp; &#x27;withCredentials&#x27; in xhr ) {
                    xhr.open( opts.method, server, true );
                    xhr.withCredentials = true;
                } else {
                    xhr.open( opts.method, server );
                }
    
                this._setRequestHeader( xhr, opts.headers );
    
                if ( binary ) {
                    // 强制设置成 content-type 为文件流。
                    xhr.overrideMimeType &amp;&amp;
                            xhr.overrideMimeType(&#x27;application/octet-stream&#x27;);
    
                    // android直接发送blob会导致服务端接收到的是空文件。
                    // bug详情。
                    // https://code.google.com/p/android/issues/detail?id=39882
                    // 所以先用fileReader读取出来再通过arraybuffer的方式发送。
                    if ( Base.os.android ) {
                        fr = new FileReader();
    
                        fr.onload = function() {
                            xhr.send( this.result );
                            fr = fr.onload = null;
                        };
    
                        fr.readAsArrayBuffer( binary );
                    } else {
                        xhr.send( binary );
                    }
                } else {
                    xhr.send( formData );
                }
            },
    
            getResponse: function() {
                return this._response;
            },
    
            getResponseAsJson: function() {
                return this._parseJson( this._response );
            },
    
            getStatus: function() {
                return this._status;
            },
    
            abort: function() {
                var xhr = this._xhr;
    
                if ( xhr ) {
                    xhr.upload.onprogress = noop;
                    xhr.onreadystatechange = noop;
                    xhr.abort();
    
                    this._xhr = xhr = null;
                }
            },
    
            destroy: function() {
                this.abort();
            },
    
            _initAjax: function() {
                var me = this,
                    xhr = new XMLHttpRequest(),
                    opts = this.options;
    
                if ( opts.withCredentials &amp;&amp; !(&#x27;withCredentials&#x27; in xhr) &amp;&amp;
                        typeof XDomainRequest !== &#x27;undefined&#x27; ) {
                    xhr = new XDomainRequest();
                }
    
                xhr.upload.onprogress = function( e ) {
                    var percentage = 0;
    
                    if ( e.lengthComputable ) {
                        percentage = e.loaded / e.total;
                    }
    
                    return me.trigger( &#x27;progress&#x27;, percentage );
                };
    
                xhr.onreadystatechange = function() {
    
                    if ( xhr.readyState !== 4 ) {
                        return;
                    }
    
                    xhr.upload.onprogress = noop;
                    xhr.onreadystatechange = noop;
                    me._xhr = null;
                    me._status = xhr.status;
    
                    if ( xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 ) {
                        me._response = xhr.responseText;
                        return me.trigger(&#x27;load&#x27;);
                    } else if ( xhr.status &gt;= 500 &amp;&amp; xhr.status &lt; 600 ) {
                        me._response = xhr.responseText;
                        return me.trigger( &#x27;error&#x27;, &#x27;server&#x27; );
                    }
    
    
                    return me.trigger( &#x27;error&#x27;, me._status ? &#x27;http&#x27; : &#x27;abort&#x27; );
                };
    
                me._xhr = xhr;
                return xhr;
            },
    
            _setRequestHeader: function( xhr, headers ) {
                $.each( headers, function( key, val ) {
                    xhr.setRequestHeader( key, val );
                });
            },
    
            _parseJson: function( str ) {
                var json;
    
                try {
                    json = JSON.parse( str );
                } catch ( ex ) {
                    json = {};
                }
    
                return json;
            }
        });
    });
    /**
     * @fileOverview FlashRuntime
     */
    define(&#x27;runtime/flash/runtime&#x27;,[
        &#x27;base&#x27;,
        &#x27;runtime/runtime&#x27;,
        &#x27;runtime/compbase&#x27;
    ], function( Base, Runtime, CompBase ) {
    
        var $ = Base.$,
            type = &#x27;flash&#x27;,
            components = {};
    
    
        function getFlashVersion() {
            var version;
    
            try {
                version = navigator.plugins[ &#x27;Shockwave Flash&#x27; ];
                version = version.description;
            } catch ( ex ) {
                try {
                    version = new ActiveXObject(&#x27;ShockwaveFlash.ShockwaveFlash&#x27;)
                            .GetVariable(&#x27;$version&#x27;);
                } catch ( ex2 ) {
                    version = &#x27;0.0&#x27;;
                }
            }
            version = version.match( /\d+/g );
            return parseFloat( version[ 0 ] + &#x27;.&#x27; + version[ 1 ], 10 );
        }
    
        function FlashRuntime() {
            var pool = {},
                clients = {},
                destroy = this.destroy,
                me = this,
                jsreciver = Base.guid(&#x27;webuploader_&#x27;);
    
            Runtime.apply( me, arguments );
            me.type = type;
    
    
            // 这个方法的调用者，实际上是RuntimeClient
            me.exec = function( comp, fn/*, args...*/ ) {
                var client = this,
                    uid = client.uid,
                    args = Base.slice( arguments, 2 ),
                    instance;
    
                clients[ uid ] = client;
    
                if ( components[ comp ] ) {
                    if ( !pool[ uid ] ) {
                        pool[ uid ] = new components[ comp ]( client, me );
                    }
    
                    instance = pool[ uid ];
    
                    if ( instance[ fn ] ) {
                        return instance[ fn ].apply( instance, args );
                    }
                }
    
                return me.flashExec.apply( client, arguments );
            };
    
            function handler( evt, obj ) {
                var type = evt.type || evt,
                    parts, uid;
    
                parts = type.split(&#x27;::&#x27;);
                uid = parts[ 0 ];
                type = parts[ 1 ];
    
                // console.log.apply( console, arguments );
    
                if ( type === &#x27;Ready&#x27; &amp;&amp; uid === me.uid ) {
                    me.trigger(&#x27;ready&#x27;);
                } else if ( clients[ uid ] ) {
                    clients[ uid ].trigger( type.toLowerCase(), evt, obj );
                }
    
                // Base.log( evt, obj );
            }
    
            // flash的接受器。
            window[ jsreciver ] = function() {
                var args = arguments;
    
                // 为了能捕获得到。
                setTimeout(function() {
                    handler.apply( null, args );
                }, 1 );
            };
    
            this.jsreciver = jsreciver;
    
            this.destroy = function() {
                // @todo 删除池子中的所有实例
                return destroy &amp;&amp; destroy.apply( this, arguments );
            };
    
            this.flashExec = function( comp, fn ) {
                var flash = me.getFlash(),
                    args = Base.slice( arguments, 2 );
    
                return flash.exec( this.uid, comp, fn, args );
            };
    
            // @todo
        }
    
        Base.inherits( Runtime, {
            constructor: FlashRuntime,
    
            init: function() {
                var container = this.getContainer(),
                    opts = this.options,
                    html;
    
                // if not the minimal height, shims are not initialized
                // in older browsers (e.g FF3.6, IE6,7,8, Safari 4.0,5.0, etc)
                container.css({
                    position: &#x27;absolute&#x27;,
                    top: &#x27;-8px&#x27;,
                    left: &#x27;-8px&#x27;,
                    width: &#x27;9px&#x27;,
                    height: &#x27;9px&#x27;,
                    overflow: &#x27;hidden&#x27;
                });
    
                // insert flash object
                html = &#x27;&lt;object id=&quot;&#x27; + this.uid + &#x27;&quot; type=&quot;application/&#x27; +
                        &#x27;x-shockwave-flash&quot; data=&quot;&#x27; +  opts.swf + &#x27;&quot; &#x27;;
    
                if ( Base.browser.ie ) {
                    html += &#x27;classid=&quot;clsid:d27cdb6e-ae6d-11cf-96b8-444553540000&quot; &#x27;;
                }
    
                html += &#x27;width=&quot;100%&quot; height=&quot;100%&quot; style=&quot;outline:0&quot;&gt;&#x27;  +
                    &#x27;&lt;param name=&quot;movie&quot; value=&quot;&#x27; + opts.swf + &#x27;&quot; /&gt;&#x27; +
                    &#x27;&lt;param name=&quot;flashvars&quot; value=&quot;uid=&#x27; + this.uid +
                    &#x27;&amp;jsreciver=&#x27; + this.jsreciver + &#x27;&quot; /&gt;&#x27; +
                    &#x27;&lt;param name=&quot;wmode&quot; value=&quot;transparent&quot; /&gt;&#x27; +
                    &#x27;&lt;param name=&quot;allowscriptaccess&quot; value=&quot;always&quot; /&gt;&#x27; +
                &#x27;&lt;/object&gt;&#x27;;
    
                container.html( html );
            },
    
            getFlash: function() {
                if ( this._flash ) {
                    return this._flash;
                }
    
                this._flash = $( &#x27;#&#x27; + this.uid ).get( 0 );
                return this._flash;
            }
    
        });
    
        FlashRuntime.register = function( name, component ) {
            component = components[ name ] = Base.inherits( CompBase, $.extend({
    
                // @todo fix this later
                flashExec: function() {
                    var owner = this.owner,
                        runtime = this.getRuntime();
    
                    return runtime.flashExec.apply( owner, arguments );
                }
            }, component ) );
    
            return component;
        };
    
        if ( getFlashVersion() &gt;= 11.4 ) {
            Runtime.addRuntime( type, FlashRuntime );
        }
    
        return FlashRuntime;
    });
    /**
     * @fileOverview FilePicker
     */
    define(&#x27;runtime/flash/filepicker&#x27;,[
        &#x27;base&#x27;,
        &#x27;runtime/flash/runtime&#x27;
    ], function( Base, FlashRuntime ) {
        var $ = Base.$;
    
        return FlashRuntime.register( &#x27;FilePicker&#x27;, {
            init: function( opts ) {
                var copy = $.extend({}, opts ),
                    len, i;
    
                // 修复Flash再没有设置title的情况下无法弹出flash文件选择框的bug.
                len = copy.accept &amp;&amp; copy.accept.length;
                for (  i = 0; i &lt; len; i++ ) {
                    if ( !copy.accept[ i ].title ) {
                        copy.accept[ i ].title = &#x27;Files&#x27;;
                    }
                }
    
                delete copy.button;
                delete copy.id;
                delete copy.container;
    
                this.flashExec( &#x27;FilePicker&#x27;, &#x27;init&#x27;, copy );
            },
    
            destroy: function() {
                this.flashExec( &#x27;FilePicker&#x27;, &#x27;destroy&#x27; );
            }
        });
    });
    /**
     * @fileOverview  Transport flash实现
     */
    define(&#x27;runtime/flash/transport&#x27;,[
        &#x27;base&#x27;,
        &#x27;runtime/flash/runtime&#x27;,
        &#x27;runtime/client&#x27;
    ], function( Base, FlashRuntime, RuntimeClient ) {
        var $ = Base.$;
    
        return FlashRuntime.register( &#x27;Transport&#x27;, {
            init: function() {
                this._status = 0;
                this._response = null;
                this._responseJson = null;
            },
    
            send: function() {
                var owner = this.owner,
                    opts = this.options,
                    xhr = this._initAjax(),
                    blob = owner._blob,
                    server = opts.server,
                    binary;
    
                xhr.connectRuntime( blob.ruid );
    
                if ( opts.sendAsBinary ) {
                    server += (/\?/.test( server ) ? &#x27;&amp;&#x27; : &#x27;?&#x27;) +
                            $.param( owner._formData );
    
                    binary = blob.uid;
                } else {
                    $.each( owner._formData, function( k, v ) {
                        xhr.exec( &#x27;append&#x27;, k, v );
                    });
    
                    xhr.exec( &#x27;appendBlob&#x27;, opts.fileVal, blob.uid,
                            opts.filename || owner._formData.name || &#x27;&#x27; );
                }
    
                this._setRequestHeader( xhr, opts.headers );
                xhr.exec( &#x27;send&#x27;, {
                    method: opts.method,
                    url: server,
                    forceURLStream: opts.forceURLStream,
                    mimeType: &#x27;application/octet-stream&#x27;
                }, binary );
            },
    
            getStatus: function() {
                return this._status;
            },
    
            getResponse: function() {
                return this._response || &#x27;&#x27;;
            },
    
            getResponseAsJson: function() {
                return this._responseJson;
            },
    
            abort: function() {
                var xhr = this._xhr;
    
                if ( xhr ) {
                    xhr.exec(&#x27;abort&#x27;);
                    xhr.destroy();
                    this._xhr = xhr = null;
                }
            },
    
            destroy: function() {
                this.abort();
            },
    
            _initAjax: function() {
                var me = this,
                    xhr = new RuntimeClient(&#x27;XMLHttpRequest&#x27;);
    
                xhr.on( &#x27;uploadprogress progress&#x27;, function( e ) {
                    var percent = e.loaded / e.total;
                    percent = Math.min( 1, Math.max( 0, percent ) );
                    return me.trigger( &#x27;progress&#x27;, percent );
                });
    
                xhr.on( &#x27;load&#x27;, function() {
                    var status = xhr.exec(&#x27;getStatus&#x27;),
                        readBody = false,
                        err = &#x27;&#x27;,
                        p;
    
                    xhr.off();
                    me._xhr = null;
    
                    if ( status &gt;= 200 &amp;&amp; status &lt; 300 ) {
                        readBody = true;
                    } else if ( status &gt;= 500 &amp;&amp; status &lt; 600 ) {
                        readBody = true;
                        err = &#x27;server&#x27;;
                    } else {
                        err = &#x27;http&#x27;;
                    }
    
                    if ( readBody ) {
                        me._response = xhr.exec(&#x27;getResponse&#x27;);
                        me._response = decodeURIComponent( me._response );
    
                        // flash 处理可能存在 bug, 没辙只能靠 js 了
                        // try {
                        //     me._responseJson = xhr.exec(&#x27;getResponseAsJson&#x27;);
                        // } catch ( error ) {
                            
                        p = window.JSON &amp;&amp; window.JSON.parse || function( s ) {
                            try {
                                return new Function(&#x27;return &#x27; + s).call();
                            } catch ( err ) {
                                return {};
                            }
                        };
                        me._responseJson  = me._response ? p(me._response) : {};
                            
                        // }
                    }
                    
                    xhr.destroy();
                    xhr = null;
    
                    return err ? me.trigger( &#x27;error&#x27;, err ) : me.trigger(&#x27;load&#x27;);
                });
    
                xhr.on( &#x27;error&#x27;, function() {
                    xhr.off();
                    me._xhr = null;
                    me.trigger( &#x27;error&#x27;, &#x27;http&#x27; );
                });
    
                me._xhr = xhr;
                return xhr;
            },
    
            _setRequestHeader: function( xhr, headers ) {
                $.each( headers, function( key, val ) {
                    xhr.exec( &#x27;setRequestHeader&#x27;, key, val );
                });
            }
        });
    });
    /**
     * @fileOverview 没有图像处理的版本。
     */
    define(&#x27;preset/withoutimage&#x27;,[
        &#x27;base&#x27;,
    
        // widgets
        &#x27;widgets/filednd&#x27;,
        &#x27;widgets/filepaste&#x27;,
        &#x27;widgets/filepicker&#x27;,
        &#x27;widgets/queue&#x27;,
        &#x27;widgets/runtime&#x27;,
        &#x27;widgets/upload&#x27;,
        &#x27;widgets/validator&#x27;,
    
        // runtimes
        // html5
        &#x27;runtime/html5/blob&#x27;,
        &#x27;runtime/html5/dnd&#x27;,
        &#x27;runtime/html5/filepaste&#x27;,
        &#x27;runtime/html5/filepicker&#x27;,
        &#x27;runtime/html5/transport&#x27;,
    
        // flash
        &#x27;runtime/flash/filepicker&#x27;,
        &#x27;runtime/flash/transport&#x27;
    ], function( Base ) {
        return Base;
    });
    define(&#x27;webuploader&#x27;,[
        &#x27;preset/withoutimage&#x27;
    ], function( preset ) {
        return preset;
    });
    return require(&#x27;webuploader&#x27;);
});

    </pre>
</div>

                </div>
            </div>
        </div>
    </div>
<a id="gotoTop" class='well well-small' href='#'>
    Top
</a>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.min.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/config.js"></script>
<script src="../assets/js/doc.js"></script>
</body>
</html>
