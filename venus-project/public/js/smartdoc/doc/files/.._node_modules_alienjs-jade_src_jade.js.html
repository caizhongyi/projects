<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>..\node_modules\alienjs-jade\src\jade.js - SmartDoc</title>
  
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.min.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-smart">
 <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container-fluid">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
               <a class="navbar-brand mainlogo" href="https://github.com/zhh77/smartdoc">
             
            <img alt="SmartDoc" src="../assets/css/logo.png" title="SmartDoc">
            
                SmartDoc
          </a>
            </div>
            <div id="navbar" class="navbar-collapse collapse">
                 <ul class="nav navbar-nav">
                    
                    <li><a href="https://github.com/zhh77/smartdoc">Home</a>
                    </li>
                    
                    <li><a href="/">Document</a>
                    </li>
                    
                    <li><a href="https://github.com/zhh77/smartdoc">About</a>
                    </li>
                    
                </ul>
               <div class="navbar-form navbar-right filterAPi" autocomplete="off">
                <input type="text" id='txtSearchAPI' class="form-control search-query" placeholder="Search for API" />
                 <ul id="filterList" class="filterItems dropdown-menu" role="menu"></ul>
                </div>
            </div>
        </div>
    </nav>
    <div id="sidebar">
    <h3>Modules/Classes</h3>
        <div id="api-tabview-filter">
            <input id='txtSearch' type="search" class="form-control" placeholder="Type to filter Modules/Classes">
        </div>
        <dl id="sidebar_list">
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/273.html">273</a>
                </dt>
                <dd>
                    <ul>
                   
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/alienjs.html">alienjs</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/window.require.html">window.require</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/Countdown.html">Countdown</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/Date.html">Date</a>
                </dt>
                <dd>
                    <ul>
                   
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/jquery.html">jquery</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/jquery.transitionEnd.html">jquery.transitionEnd</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.support.transition.html">jquery.support.transition</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.animationEnd.html">jquery.animationEnd</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/jquery-ui.html">jquery-ui</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/jquery.ajaxPanel.html">jquery.ajaxPanel</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.dialog.html">jquery.dialog</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/Array.html">Array</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.browserLowVersion.html">jquery.browserLowVersion</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.confirm.html">jquery.confirm</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/jquery.alert.html">jquery.alert</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/ng.html">ng</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/EventEmitter Manages event registering and emitting..html">EventEmitter Manages event registering and emitting.</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/ngMock.html">ngMock</a>
                </dt>
                <dd>
                    <ul>
                   
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/ngMockE2E.html">ngMockE2E</a>
                </dt>
                <dd>
                    <ul>
                   
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/ui.html">ui</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/AjaxPanel.html">AjaxPanel</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/Date.Dialog.html">Date.Dialog</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/WebUploader.html">WebUploader</a>
                </dt>
                <dd>
                    <ul>
                   
                       <li>
                            
                           <a href="../classes/Base.html">Base</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/Mediator.html">Mediator</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/options.Uploader.html">options.Uploader</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/File.File.html">File.File</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/File.Queue.html">File.Queue</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                       <li>
                            
                           <a href="../classes/Uploader.html">Uploader</a>
                           <ul>
                                
                           </ul>
                       </li>
                    
                    </ul>
                </dd>
             
                <dt>
                    <span class="glyphicon glyphicon-minus"></span>
                    <a href="../modules/window.html">window</a>
                </dt>
                <dd>
                    <ul>
                   
                    </ul>
                </dd>
             
        </dl>
</div>
   
    <div class="stdoc-content">
        <!--     <form id="options-form" class="form-inline pull-right">
        Show:
        <label for="api-show-inherited" class="checkbox">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected" class="checkbox">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private" class="checkbox">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated" class="checkbox">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </form>

 -->
        <div class="apidocs">
            <div id="docs-main">
                <div class="content">
                    <div class="page-header">
    <h1>..\node_modules\alienjs-jade\src\jade.js <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums" id='src_code'>


(function() {

// CommonJS jadeRequire()

function jadeRequire(p){
    var path = jadeRequire.resolve(p)
      , mod = jadeRequire.modules[path];
    if (!mod) throw new Error(&#x27;failed to jadeRequire &quot;&#x27; + p + &#x27;&quot;&#x27;);
    if (!mod.exports) {
      mod.exports = {};
      mod.call(mod.exports, mod, mod.exports, jadeRequire.relative(path));
    }
    return mod.exports;
  }

jadeRequire.modules = {};

jadeRequire.resolve = function (path){
    var orig = path
      , reg = path + &#x27;.js&#x27;
      , index = path + &#x27;/index.js&#x27;;
    return jadeRequire.modules[reg] &amp;&amp; reg
      || jadeRequire.modules[index] &amp;&amp; index
      || orig;
  };

jadeRequire.register = function (path, fn){
    jadeRequire.modules[path] = fn;
  };

jadeRequire.relative = function (parent) {
    return function(p){
      if (&#x27;.&#x27; != p.charAt(0)) return jadeRequire(p);
      
      var path = parent.split(&#x27;/&#x27;)
        , segs = p.split(&#x27;/&#x27;);
      path.pop();
      
      for (var i = 0; i &lt; segs.length; i++) {
        var seg = segs[i];
        if (&#x27;..&#x27; == seg) path.pop();
        else if (&#x27;.&#x27; != seg) path.push(seg);
      }

      return jadeRequire(path.join(&#x27;/&#x27;));
    };
  };


jadeRequire.register(&quot;compiler.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - Compiler
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var nodes = jadeRequire(&#x27;./nodes&#x27;)
  , filters = jadeRequire(&#x27;./filters&#x27;)
  , doctypes = jadeRequire(&#x27;./doctypes&#x27;)
  , selfClosing = jadeRequire(&#x27;./self-closing&#x27;)
  , runtime = jadeRequire(&#x27;./runtime&#x27;)
  , utils = jadeRequire(&#x27;./utils&#x27;);


 if (!Object.keys) {
   Object.keys = function(obj){
     var arr = [];
     for (var key in obj) {
       if (obj.hasOwnProperty(key)) {
         arr.push(key);
       }
     }
     return arr;
   }
 }

 if (!String.prototype.trimLeft) {
   String.prototype.trimLeft = function(){
     return this.replace(/^\s+/, &#x27;&#x27;);
   }
 }



/**
 * Initialize &#x60;Compiler&#x60; with the given &#x60;node&#x60;.
 *
 * @param {Node} node
 * @param {Object} options
 * @api public
 */

var Compiler = module.exports = function Compiler(node, options) {
  this.options = options = options || {};
  this.node = node;
  this.hasCompiledDoctype = false;
  this.hasCompiledTag = false;
  this.pp = options.pretty || false;
  this.debug = false !== options.compileDebug;
  this.indents = 0;
  this.parentIndents = 0;
  if (options.doctype) this.setDoctype(options.doctype);
};

/**
 * Compiler prototype.
 */

Compiler.prototype = {

  /**
   * Compile parse tree to JavaScript.
   *
   * @api public
   */

  compile: function(){
    this.buf = [&#x27;var interp;&#x27;];
    if (this.pp) this.buf.push(&quot;var __indent = [];&quot;);
    this.lastBufferedIdx = -1;
    this.visit(this.node);
    return this.buf.join(&#x27;\n&#x27;);
  },

  /**
   * Sets the default doctype &#x60;name&#x60;. Sets terse mode to &#x60;true&#x60; when
   * html 5 is used, causing self-closing tags to end with &quot;&gt;&quot; vs &quot;/&gt;&quot;,
   * and boolean attributes are not mirrored.
   *
   * @param {string} name
   * @api public
   */

  setDoctype: function(name){
    var doctype = doctypes[(name || &#x27;default&#x27;).toLowerCase()];
    doctype = doctype || &#x27;&lt;!DOCTYPE &#x27; + name + &#x27;&gt;&#x27;;
    this.doctype = doctype;
    this.terse = &#x27;5&#x27; == name || &#x27;html&#x27; == name;
    this.xml = 0 == this.doctype.indexOf(&#x27;&lt;?xml&#x27;);
  },

  /**
   * Buffer the given &#x60;str&#x60; optionally escaped.
   *
   * @param {String} str
   * @param {Boolean} esc
   * @api public
   */

  buffer: function(str, esc){
    if (esc) str = utils.escape(str);

    if (this.lastBufferedIdx == this.buf.length) {
      this.lastBuffered += str;
      this.buf[this.lastBufferedIdx - 1] = &quot;buf.push(&#x27;&quot; + this.lastBuffered + &quot;&#x27;);&quot;
    } else {
      this.buf.push(&quot;buf.push(&#x27;&quot; + str + &quot;&#x27;);&quot;);
      this.lastBuffered = str;
      this.lastBufferedIdx = this.buf.length;
    }
  },

  /**
   * Buffer an indent based on the current &#x60;indent&#x60;
   * property and an additional &#x60;offset&#x60;.
   *
   * @param {Number} offset
   * @param {Boolean} newline
   * @api public
   */
  
  prettyIndent: function(offset, newline){
    offset = offset || 0;
    newline = newline ? &#x27;\\n&#x27; : &#x27;&#x27;;
    this.buffer(newline + Array(this.indents + offset).join(&#x27;  &#x27;));
    if (this.parentIndents)
      this.buf.push(&quot;buf.push.apply(buf, __indent);&quot;);
  },

  /**
   * Visit &#x60;node&#x60;.
   *
   * @param {Node} node
   * @api public
   */

  visit: function(node){
    var debug = this.debug;

    if (debug) {
      this.buf.push(&#x27;__jade.unshift({ lineno: &#x27; + node.line
        + &#x27;, filename: &#x27; + (node.filename
          ? JSON.stringify(node.filename)
          : &#x27;__jade[0].filename&#x27;)
        + &#x27; });&#x27;);
    }

    // Massive hack to fix our context
    // stack for - else[ if] etc
    if (false === node.debug &amp;&amp; this.debug) {
      this.buf.pop();
      this.buf.pop();
    }

    this.visitNode(node);

    if (debug) this.buf.push(&#x27;__jade.shift();&#x27;);
  },

  /**
   * Visit &#x60;node&#x60;.
   *
   * @param {Node} node
   * @api public
   */

  visitNode: function(node){
    var name = node.constructor.name
      || node.constructor.toString().match(/function ([^(\s]+)()/)[1];
    return this[&#x27;visit&#x27; + name](node);
  },

  /**
   * Visit case &#x60;node&#x60;.
   *
   * @param {Literal} node
   * @api public
   */

  visitCase: function(node){
    var _ = this.withinCase;
    this.withinCase = true;
    this.buf.push(&#x27;switch (&#x27; + node.expr + &#x27;){&#x27;);
    this.visit(node.block);
    this.buf.push(&#x27;}&#x27;);
    this.withinCase = _;
  },

  /**
   * Visit when &#x60;node&#x60;.
   *
   * @param {Literal} node
   * @api public
   */

  visitWhen: function(node){
    if (&#x27;default&#x27; == node.expr) {
      this.buf.push(&#x27;default:&#x27;);
    } else {
      this.buf.push(&#x27;case &#x27; + node.expr + &#x27;:&#x27;);
    }
    this.visit(node.block);
    this.buf.push(&#x27;  break;&#x27;);
  },

  /**
   * Visit literal &#x60;node&#x60;.
   *
   * @param {Literal} node
   * @api public
   */

  visitLiteral: function(node){
    var str = node.str.replace(/\n/g, &#x27;\\\\n&#x27;);
    this.buffer(str);
  },

  /**
   * Visit all nodes in &#x60;block&#x60;.
   *
   * @param {Block} block
   * @api public
   */

  visitBlock: function(block){
    var len = block.nodes.length
      , escape = this.escape
      , pp = this.pp
    
    // Block keyword has a special meaning in mixins
    if (this.parentIndents &amp;&amp; block.mode) {
      if (pp) this.buf.push(&quot;__indent.push(&#x27;&quot; + Array(this.indents + 1).join(&#x27;  &#x27;) + &quot;&#x27;);&quot;)
      this.buf.push(&#x27;block &amp;&amp; block();&#x27;);
      if (pp) this.buf.push(&quot;__indent.pop();&quot;)
      return;
    }
    
    // Pretty print multi-line text
    if (pp &amp;&amp; len &gt; 1 &amp;&amp; !escape &amp;&amp; block.nodes[0].isText &amp;&amp; block.nodes[1].isText)
      this.prettyIndent(1, true);
    
    for (var i = 0; i &lt; len; ++i) {
      // Pretty print text
      if (pp &amp;&amp; i &gt; 0 &amp;&amp; !escape &amp;&amp; block.nodes[i].isText &amp;&amp; block.nodes[i-1].isText)
        this.prettyIndent(1, false);
      
      this.visit(block.nodes[i]);
      // Multiple text nodes are separated by newlines
      if (block.nodes[i+1] &amp;&amp; block.nodes[i].isText &amp;&amp; block.nodes[i+1].isText)
        this.buffer(&#x27;\\n&#x27;);
    }
  },

  /**
   * Visit &#x60;doctype&#x60;. Sets terse mode to &#x60;true&#x60; when html 5
   * is used, causing self-closing tags to end with &quot;&gt;&quot; vs &quot;/&gt;&quot;,
   * and boolean attributes are not mirrored.
   *
   * @param {Doctype} doctype
   * @api public
   */

  visitDoctype: function(doctype){
    if (doctype &amp;&amp; (doctype.val || !this.doctype)) {
      this.setDoctype(doctype.val || &#x27;default&#x27;);
    }

    if (this.doctype) this.buffer(this.doctype);
    this.hasCompiledDoctype = true;
  },

  /**
   * Visit &#x60;mixin&#x60;, generating a function that
   * may be called within the template.
   *
   * @param {Mixin} mixin
   * @api public
   */

  visitMixin: function(mixin){
    var name = mixin.name.replace(/-/g, &#x27;_&#x27;) + &#x27;_mixin&#x27;
      , args = mixin.args || &#x27;&#x27;
      , block = mixin.block
      , attrs = mixin.attrs
      , pp = this.pp;

    if (mixin.call) {
      if (pp) this.buf.push(&quot;__indent.push(&#x27;&quot; + Array(this.indents + 1).join(&#x27;  &#x27;) + &quot;&#x27;);&quot;)
      if (block || attrs.length) {
        
        this.buf.push(name + &#x27;.call({&#x27;);
        
        if (block) {
          this.buf.push(&#x27;block: function(){&#x27;);
          
          // Render block with no indents, dynamically added when rendered
          this.parentIndents++;
          var _indents = this.indents;
          this.indents = 0;
          this.visit(mixin.block);
          this.indents = _indents;
          this.parentIndents--;
          
          if (attrs.length) {
            this.buf.push(&#x27;},&#x27;);
          } else {
            this.buf.push(&#x27;}&#x27;);
          }
        }
        
        if (attrs.length) {
          var val = this.attrs(attrs);
          if (val.inherits) {
            this.buf.push(&#x27;attributes: merge({&#x27; + val.buf
                + &#x27;}, attributes), escaped: merge(&#x27; + val.escaped + &#x27;, escaped, true)&#x27;);
          } else {
            this.buf.push(&#x27;attributes: {&#x27; + val.buf + &#x27;}, escaped: &#x27; + val.escaped);
          }
        }
        
        if (args) {
          this.buf.push(&#x27;}, &#x27; + args + &#x27;);&#x27;);
        } else {
          this.buf.push(&#x27;});&#x27;);
        }
        
      } else {
        this.buf.push(name + &#x27;(&#x27; + args + &#x27;);&#x27;);
      }
      if (pp) this.buf.push(&quot;__indent.pop();&quot;)
    } else {
      this.buf.push(&#x27;var &#x27; + name + &#x27; = function(&#x27; + args + &#x27;){&#x27;);
      this.buf.push(&#x27;var block = this.block, attributes = this.attributes || {}, escaped = this.escaped || {};&#x27;);
      this.parentIndents++;
      this.visit(block);
      this.parentIndents--;
      this.buf.push(&#x27;};&#x27;);
    }
  },

  /**
   * Visit &#x60;tag&#x60; buffering tag markup, generating
   * attributes, visiting the &#x60;tag&#x60;&#x27;s code and block.
   *
   * @param {Tag} tag
   * @api public
   */

  visitTag: function(tag){
    this.indents++;
    var name = tag.name
      , pp = this.pp;

    if (tag.buffer) name = &quot;&#x27; + (&quot; + name + &quot;) + &#x27;&quot;;

    if (!this.hasCompiledTag) {
      if (!this.hasCompiledDoctype &amp;&amp; &#x27;html&#x27; == name) {
        this.visitDoctype();
      }
      this.hasCompiledTag = true;
    }

    // pretty print
    if (pp &amp;&amp; !tag.isInline())
      this.prettyIndent(0, true);

    if ((~selfClosing.indexOf(name) || tag.selfClosing) &amp;&amp; !this.xml) {
      this.buffer(&#x27;&lt;&#x27; + name);
      this.visitAttributes(tag.attrs);
      this.terse
        ? this.buffer(&#x27;&gt;&#x27;)
        : this.buffer(&#x27;/&gt;&#x27;);
    } else {
      // Optimize attributes buffering
      if (tag.attrs.length) {
        this.buffer(&#x27;&lt;&#x27; + name);
        if (tag.attrs.length) this.visitAttributes(tag.attrs);
        this.buffer(&#x27;&gt;&#x27;);
      } else {
        this.buffer(&#x27;&lt;&#x27; + name + &#x27;&gt;&#x27;);
      }
      if (tag.code) this.visitCode(tag.code);
      this.escape = &#x27;pre&#x27; == tag.name;
      this.visit(tag.block);

      // pretty print
      if (pp &amp;&amp; !tag.isInline() &amp;&amp; &#x27;pre&#x27; != tag.name &amp;&amp; !tag.canInline())
        this.prettyIndent(0, true);

      this.buffer(&#x27;&lt;/&#x27; + name + &#x27;&gt;&#x27;);
    }
    this.indents--;
  },

  /**
   * Visit &#x60;filter&#x60;, throwing when the filter does not exist.
   *
   * @param {Filter} filter
   * @api public
   */

  visitFilter: function(filter){
    var fn = filters[filter.name];

    // unknown filter
    if (!fn) {
      if (filter.isASTFilter) {
        throw new Error(&#x27;unknown ast filter &quot;&#x27; + filter.name + &#x27;:&quot;&#x27;);
      } else {
        throw new Error(&#x27;unknown filter &quot;:&#x27; + filter.name + &#x27;&quot;&#x27;);
      }
    }

    if (filter.isASTFilter) {
      this.buf.push(fn(filter.block, this, filter.attrs));
    } else {
      var text = filter.block.nodes.map(function(node){ return node.val }).join(&#x27;\n&#x27;);
      filter.attrs = filter.attrs || {};
      filter.attrs.filename = this.options.filename;
      this.buffer(utils.text(fn(text, filter.attrs)));
    }
  },

  /**
   * Visit &#x60;text&#x60; node.
   *
   * @param {Text} text
   * @api public
   */

  visitText: function(text){
    text = utils.text(text.val.replace(/\\/g, &#x27;\\\\&#x27;));
    if (this.escape) text = escape(text);
    this.buffer(text);
  },

  /**
   * Visit a &#x60;comment&#x60;, only buffering when the buffer flag is set.
   *
   * @param {Comment} comment
   * @api public
   */

  visitComment: function(comment){
    if (!comment.buffer) return;
    if (this.pp) this.prettyIndent(1, true);
    this.buffer(&#x27;&lt;!--&#x27; + utils.escape(comment.val) + &#x27;--&gt;&#x27;);
  },

  /**
   * Visit a &#x60;BlockComment&#x60;.
   *
   * @param {Comment} comment
   * @api public
   */

  visitBlockComment: function(comment){
    if (!comment.buffer) return;
    if (0 == comment.val.trim().indexOf(&#x27;if&#x27;)) {
      this.buffer(&#x27;&lt;!--[&#x27; + comment.val.trim() + &#x27;]&gt;&#x27;);
      this.visit(comment.block);
      this.buffer(&#x27;&lt;![endif]--&gt;&#x27;);
    } else {
      this.buffer(&#x27;&lt;!--&#x27; + comment.val);
      this.visit(comment.block);
      this.buffer(&#x27;--&gt;&#x27;);
    }
  },

  /**
   * Visit &#x60;code&#x60;, respecting buffer / escape flags.
   * If the code is followed by a block, wrap it in
   * a self-calling function.
   *
   * @param {Code} code
   * @api public
   */

  visitCode: function(code){
    // Wrap code blocks with {}.
    // we only wrap unbuffered code blocks ATM
    // since they are usually flow control

    // Buffer code
    if (code.buffer) {
      var val = code.val.trimLeft();
      this.buf.push(&#x27;var __val__ = &#x27; + val);
      val = &#x27;null == __val__ ? &quot;&quot; : __val__&#x27;;
      if (code.escape) val = &#x27;escape(&#x27; + val + &#x27;)&#x27;;
      this.buf.push(&quot;buf.push(&quot; + val + &quot;);&quot;);
    } else {
      this.buf.push(code.val);
    }

    // Block support
    if (code.block) {
      if (!code.buffer) this.buf.push(&#x27;{&#x27;);
      this.visit(code.block);
      if (!code.buffer) this.buf.push(&#x27;}&#x27;);
    }
  },

  /**
   * Visit &#x60;each&#x60; block.
   *
   * @param {Each} each
   * @api public
   */

  visitEach: function(each){
    this.buf.push(&#x27;&#x27;
      + &#x27;// iterate &#x27; + each.obj + &#x27;\n&#x27;
      + &#x27;;(function(){\n&#x27;
      + &#x27;  if (\&#x27;number\&#x27; == typeof &#x27; + each.obj + &#x27;.length) {\n&#x27;
      + &#x27;    for (var &#x27; + each.key + &#x27; = 0, $$l = &#x27; + each.obj + &#x27;.length; &#x27; + each.key + &#x27; &lt; $$l; &#x27; + each.key + &#x27;++) {\n&#x27;
      + &#x27;      var &#x27; + each.val + &#x27; = &#x27; + each.obj + &#x27;[&#x27; + each.key + &#x27;];\n&#x27;);

    this.visit(each.block);

    this.buf.push(&#x27;&#x27;
      + &#x27;    }\n&#x27;
      + &#x27;  } else {\n&#x27;
      + &#x27;    for (var &#x27; + each.key + &#x27; in &#x27; + each.obj + &#x27;) {\n&#x27;
       + &#x27;      if (&#x27; + each.obj + &#x27;.hasOwnProperty(&#x27; + each.key + &#x27;)){&#x27;
      + &#x27;      var &#x27; + each.val + &#x27; = &#x27; + each.obj + &#x27;[&#x27; + each.key + &#x27;];\n&#x27;);

    this.visit(each.block);

     this.buf.push(&#x27;      }\n&#x27;);

    this.buf.push(&#x27;   }\n  }\n}).call(this);\n&#x27;);
  },

  /**
   * Visit &#x60;attrs&#x60;.
   *
   * @param {Array} attrs
   * @api public
   */

  visitAttributes: function(attrs){
    var val = this.attrs(attrs);
    if (val.inherits) {
      this.buf.push(&quot;buf.push(attrs(merge({ &quot; + val.buf +
          &quot; }, attributes), merge(&quot; + val.escaped + &quot;, escaped, true)));&quot;);
    } else if (val.constant) {
      eval(&#x27;var buf={&#x27; + val.buf + &#x27;};&#x27;);
      this.buffer(runtime.attrs(buf, JSON.parse(val.escaped)), true);
    } else {
      this.buf.push(&quot;buf.push(attrs({ &quot; + val.buf + &quot; }, &quot; + val.escaped + &quot;));&quot;);
    }
  },

  /**
   * Compile attributes.
   */

  attrs: function(attrs){
    var buf = []
      , classes = []
      , escaped = {}
      , constant = attrs.every(function(attr){ return isConstant(attr.val) })
      , inherits = false;

    if (this.terse) buf.push(&#x27;terse: true&#x27;);

    attrs.forEach(function(attr){
      if (attr.name == &#x27;attributes&#x27;) return inherits = true;
      escaped[attr.name] = attr.escaped;
      if (attr.name == &#x27;class&#x27;) {
        classes.push(&#x27;(&#x27; + attr.val + &#x27;)&#x27;);
      } else {
        var pair = &quot;&#x27;&quot; + attr.name + &quot;&#x27;:(&quot; + attr.val + &#x27;)&#x27;;
        buf.push(pair);
      }
    });

    if (classes.length) {
      classes = classes.join(&quot; + &#x27; &#x27; + &quot;);
      buf.push(&quot;class: &quot; + classes);
    }

    return {
      buf: buf.join(&#x27;, &#x27;).replace(&#x27;class:&#x27;, &#x27;&quot;class&quot;:&#x27;),
      escaped: JSON.stringify(escaped),
      inherits: inherits,
      constant: constant
    };
  }
};

/**
 * Check if expression can be evaluated to a constant
 *
 * @param {String} expression
 * @return {Boolean}
 * @api private
 */

function isConstant(val){
  // Check strings/literals
  if (/^ *(&quot;([^&quot;\\]*(\\.[^&quot;\\]*)*)&quot;|&#x27;([^&#x27;\\]*(\\.[^&#x27;\\]*)*)&#x27;|true|false|null|undefined) *$/i.test(val))
    return true;
  
  // Check numbers
  if (!isNaN(Number(val)))
    return true;
  
  // Check arrays
  var matches;
  if (matches = /^ *\[(.*)\] *$/.exec(val))
    return matches[1].split(&#x27;,&#x27;).every(isConstant);
  
  return false;
}

/**
 * Escape the given string of &#x60;html&#x60;.
 *
 * @param {String} html
 * @return {String}
 * @api private
 */

function escape(html){
  return String(html)
    .replace(/&amp;(?!\w+;)/g, &#x27;&amp;amp;&#x27;)
    .replace(/&lt;/g, &#x27;&amp;lt;&#x27;)
    .replace(/&gt;/g, &#x27;&amp;gt;&#x27;)
    .replace(/&quot;/g, &#x27;&amp;quot;&#x27;);
}
}); // module: compiler.js

jadeRequire.register(&quot;doctypes.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - doctypes
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

module.exports = {
    &#x27;5&#x27;: &#x27;&lt;!DOCTYPE html&gt;&#x27;
  , &#x27;default&#x27;: &#x27;&lt;!DOCTYPE html&gt;&#x27;
  , &#x27;xml&#x27;: &#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&#x27;
  , &#x27;transitional&#x27;: &#x27;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&#x27;
  , &#x27;strict&#x27;: &#x27;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;&#x27;
  , &#x27;frameset&#x27;: &#x27;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;&#x27;
  , &#x27;1.1&#x27;: &#x27;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;&#x27;
  , &#x27;basic&#x27;: &#x27;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML Basic 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd&quot;&gt;&#x27;
  , &#x27;mobile&#x27;: &#x27;&lt;!DOCTYPE html PUBLIC &quot;-//WAPFORUM//DTD XHTML Mobile 1.2//EN&quot; &quot;http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd&quot;&gt;&#x27;
};
}); // module: doctypes.js

jadeRequire.register(&quot;filters.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - filters
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

module.exports = {
  
  /**
   * Wrap text with CDATA block.
   */
  
  cdata: function(str){
    return &#x27;&lt;![CDATA[\\n&#x27; + str + &#x27;\\n]]&gt;&#x27;;
  },
  
  /**
   * Transform sass to css, wrapped in style tags.
   */
  
  sass: function(str){
    str = str.replace(/\\n/g, &#x27;\n&#x27;);
    var sass = jadeRequire(&#x27;sass&#x27;).render(str).replace(/\n/g, &#x27;\\n&#x27;);
    return &#x27;&lt;style type=&quot;text/css&quot;&gt;&#x27; + sass + &#x27;&lt;/style&gt;&#x27;; 
  },
  
  /**
   * Transform stylus to css, wrapped in style tags.
   */
  
  stylus: function(str, options){
    var ret;
    str = str.replace(/\\n/g, &#x27;\n&#x27;);
    var stylus = jadeRequire(&#x27;stylus&#x27;);
    stylus(str, options).render(function(err, css){
      if (err) throw err;
      ret = css.replace(/\n/g, &#x27;\\n&#x27;);
    });
    return &#x27;&lt;style type=&quot;text/css&quot;&gt;&#x27; + ret + &#x27;&lt;/style&gt;&#x27;; 
  },
  
  /**
   * Transform less to css, wrapped in style tags.
   */
  
  less: function(str){
    var ret;
    str = str.replace(/\\n/g, &#x27;\n&#x27;);
    jadeRequire(&#x27;less&#x27;).render(str, function(err, css){
      if (err) throw err;
      ret = &#x27;&lt;style type=&quot;text/css&quot;&gt;&#x27; + css.replace(/\n/g, &#x27;\\n&#x27;) + &#x27;&lt;/style&gt;&#x27;;  
    });
    return ret;
  },
  
  /**
   * Transform markdown to html.
   */
  
  markdown: function(str){
    var md;

    // support markdown / discount
    try {
      md = jadeRequire(&#x27;markdown&#x27;);
    } catch (err){
      try {
        md = jadeRequire(&#x27;discount&#x27;);
      } catch (err) {
        try {
          md = jadeRequire(&#x27;markdown-js&#x27;);
        } catch (err) {
          try {
            md = jadeRequire(&#x27;marked&#x27;);
          } catch (err) {
            throw new
              Error(&#x27;Cannot find markdown library, install markdown, discount, or marked.&#x27;);
          }
        }
      }
    }

    str = str.replace(/\\n/g, &#x27;\n&#x27;);
    return md.parse(str).replace(/\n/g, &#x27;\\n&#x27;).replace(/&#x27;/g,&#x27;&amp;#39;&#x27;);
  },
  
  /**
   * Transform coffeescript to javascript.
   */

  coffeescript: function(str){
    str = str.replace(/\\n/g, &#x27;\n&#x27;);
    var js = jadeRequire(&#x27;coffee-script&#x27;).compile(str).replace(/\\/g, &#x27;\\\\&#x27;).replace(/\n/g, &#x27;\\n&#x27;);
    return &#x27;&lt;script type=&quot;text/javascript&quot;&gt;\\n&#x27; + js + &#x27;&lt;/script&gt;&#x27;;
  }
};

}); // module: filters.js

jadeRequire.register(&quot;inline-tags.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - inline tags
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

module.exports = [
    &#x27;a&#x27;
  , &#x27;abbr&#x27;
  , &#x27;acronym&#x27;
  , &#x27;b&#x27;
  , &#x27;br&#x27;
  , &#x27;code&#x27;
  , &#x27;em&#x27;
  , &#x27;font&#x27;
  , &#x27;i&#x27;
  , &#x27;img&#x27;
  , &#x27;ins&#x27;
  , &#x27;kbd&#x27;
  , &#x27;map&#x27;
  , &#x27;samp&#x27;
  , &#x27;small&#x27;
  , &#x27;span&#x27;
  , &#x27;strong&#x27;
  , &#x27;sub&#x27;
  , &#x27;sup&#x27;
];
}); // module: inline-tags.js

jadeRequire.register(&quot;jade.js&quot;, function(module, exports, jadeRequire){
/*!
 * Jade
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Parser = jadeRequire(&#x27;./parser&#x27;)
  , Lexer = jadeRequire(&#x27;./lexer&#x27;)
  , Compiler = jadeRequire(&#x27;./compiler&#x27;)
  , runtime = jadeRequire(&#x27;./runtime&#x27;)

/**
 * Library version.
 */

exports.version = &#x27;0.26.1&#x27;;

/**
 * Expose self closing tags.
 */

exports.selfClosing = jadeRequire(&#x27;./self-closing&#x27;);

/**
 * Default supported doctypes.
 */

exports.doctypes = jadeRequire(&#x27;./doctypes&#x27;);

/**
 * Text filters.
 */

exports.filters = jadeRequire(&#x27;./filters&#x27;);

/**
 * Utilities.
 */

exports.utils = jadeRequire(&#x27;./utils&#x27;);

/**
 * Expose &#x60;Compiler&#x60;.
 */

exports.Compiler = Compiler;

/**
 * Expose &#x60;Parser&#x60;.
 */

exports.Parser = Parser;

/**
 * Expose &#x60;Lexer&#x60;.
 */

exports.Lexer = Lexer;

/**
 * Nodes.
 */

exports.nodes = jadeRequire(&#x27;./nodes&#x27;);

/**
 * Jade runtime helpers.
 */

exports.runtime = runtime;

/**
 * Template function cache.
 */

exports.cache = {};

/**
 * Parse the given &#x60;str&#x60; of jade and return a function body.
 *
 * @param {String} str
 * @param {Object} options
 * @return {String}
 * @api private
 */

function parse(str, options){
  try {
    // Parse
    var parser = new Parser(str, options.filename, options);

    // Compile
    var compiler = new (options.compiler || Compiler)(parser.parse(), options)
      , js = compiler.compile();

    // Debug compiler
    if (options.debug) {
      console.error(&#x27;\nCompiled Function:\n\n\033[90m%s\033[0m&#x27;, js.replace(/^/gm, &#x27;  &#x27;));
    }

    return &#x27;&#x27;
      + &#x27;var buf = [];\n&#x27;
      + (options.self
        ? &#x27;var self = locals || {};\n&#x27; + js
        : &#x27;with (locals || {}) {\n&#x27; + js + &#x27;\n}\n&#x27;)
      + &#x27;return buf.join(&quot;&quot;);&#x27;;
  } catch (err) {
    parser = parser.context();
    runtime.rethrow(err, parser.filename, parser.lexer.lineno);
  }
}

/**
 * Compile a &#x60;Function&#x60; representation of the given jade &#x60;str&#x60;.
 *
 * Options:
 *
 *   - &#x60;compileDebug&#x60; when &#x60;false&#x60; debugging code is stripped from the compiled template
 *   - &#x60;client&#x60; when &#x60;true&#x60; the helper functions &#x60;escape()&#x60; etc will reference &#x60;jade.escape()&#x60;
 *      for use with the Jade client-side runtime.js
 *
 * @param {String} str
 * @param {Options} options
 * @return {Function}
 * @api public
 */

exports.compile = function(str, options){
  var options = options || {}
    , client = options.client
    , filename = options.filename
      ? JSON.stringify(options.filename)
      : &#x27;undefined&#x27;
    , fn;

  if (options.compileDebug !== false) {
    fn = [
        &#x27;var __jade = [{ lineno: 1, filename: &#x27; + filename + &#x27; }];&#x27;
      , &#x27;try {&#x27;
      , parse(String(str), options)
      , &#x27;} catch (err) {&#x27;
      , &#x27;  rethrow(err, __jade[0].filename, __jade[0].lineno);&#x27;
      , &#x27;}&#x27;
    ].join(&#x27;\n&#x27;);
  } else {
    fn = parse(String(str), options);
  }

  if (client) {
    fn = &#x27;attrs = attrs || jade.attrs; escape = escape || jade.escape; rethrow = rethrow || jade.rethrow; merge = merge || jade.merge;\n&#x27; + fn;
  }

  fn = new Function(&#x27;locals, attrs, escape, rethrow, merge&#x27;, fn);

  if (client) return fn;

  return function(locals){
    return fn(locals, runtime.attrs, runtime.escape, runtime.rethrow, runtime.merge);
  };
};

/**
 * Render the given &#x60;str&#x60; of jade and invoke
 * the callback &#x60;fn(err, str)&#x60;.
 *
 * Options:
 *
 *   - &#x60;cache&#x60; enable template caching
 *   - &#x60;filename&#x60; filename jadeRequired for &#x60;include&#x60; / &#x60;extends&#x60; and caching
 *
 * @param {String} str
 * @param {Object|Function} options or fn
 * @param {Function} fn
 * @api public
 */

exports.render = function(str, options, fn){
  // swap args
  if (&#x27;function&#x27; == typeof options) {
    fn = options, options = {};
  }

  // cache jadeRequires .filename
  if (options.cache &amp;&amp; !options.filename) {
    return fn(new Error(&#x27;the &quot;filename&quot; option is jadeRequired for caching&#x27;));
  }

  try {
    var path = options.filename;
    var tmpl = options.cache
      ? exports.cache[path] || (exports.cache[path] = exports.compile(str, options))
      : exports.compile(str, options);
    fn(null, tmpl(options));
  } catch (err) {
    fn(err);
  }
};

/**
 * Render a Jade file at the given &#x60;path&#x60; and callback &#x60;fn(err, str)&#x60;.
 *
 * @param {String} path
 * @param {Object|Function} options or callback
 * @param {Function} fn
 * @api public
 */

exports.renderFile = function(path, options, fn){
  var key = path + &#x27;:string&#x27;;

  if (&#x27;function&#x27; == typeof options) {
    fn = options, options = {};
  }

  try {
    options.filename = path;
    var str = options.cache
      ? exports.cache[key] || (exports.cache[key] = fs.readFileSync(path, &#x27;utf8&#x27;))
      : fs.readFileSync(path, &#x27;utf8&#x27;);
    exports.render(str, options, fn);
  } catch (err) {
    fn(err);
  }
};

/**
 * Express support.
 */

exports.__express = exports.renderFile;

}); // module: jade.js

jadeRequire.register(&quot;lexer.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - Lexer
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

/**
 * Initialize &#x60;Lexer&#x60; with the given &#x60;str&#x60;.
 *
 * Options:
 *
 *   - &#x60;colons&#x60; allow colons for attr delimiters
 *
 * @param {String} str
 * @param {Object} options
 * @api private
 */

var Lexer = module.exports = function Lexer(str, options) {
  options = options || {};
  this.input = str.replace(/\r\n|\r/g, &#x27;\n&#x27;);
  this.colons = options.colons;
  this.deferredTokens = [];
  this.lastIndents = 0;
  this.lineno = 1;
  this.stash = [];
  this.indentStack = [];
  this.indentRe = null;
  this.pipeless = false;
};

/**
 * Lexer prototype.
 */

Lexer.prototype = {
  
  /**
   * Construct a token with the given &#x60;type&#x60; and &#x60;val&#x60;.
   *
   * @param {String} type
   * @param {String} val
   * @return {Object}
   * @api private
   */
  
  tok: function(type, val){
    return {
        type: type
      , line: this.lineno
      , val: val
    }
  },
  
  /**
   * Consume the given &#x60;len&#x60; of input.
   *
   * @param {Number} len
   * @api private
   */
  
  consume: function(len){
    this.input = this.input.substr(len);
  },
  
  /**
   * Scan for &#x60;type&#x60; with the given &#x60;regexp&#x60;.
   *
   * @param {String} type
   * @param {RegExp} regexp
   * @return {Object}
   * @api private
   */
  
  scan: function(regexp, type){
    var captures;
    if (captures = regexp.exec(this.input)) {
      this.consume(captures[0].length);
      return this.tok(type, captures[1]);
    }
  },
  
  /**
   * Defer the given &#x60;tok&#x60;.
   *
   * @param {Object} tok
   * @api private
   */
  
  defer: function(tok){
    this.deferredTokens.push(tok);
  },
  
  /**
   * Lookahead &#x60;n&#x60; tokens.
   *
   * @param {Number} n
   * @return {Object}
   * @api private
   */
  
  lookahead: function(n){
    var fetch = n - this.stash.length;
    while (fetch-- &gt; 0) this.stash.push(this.next());
    return this.stash[--n];
  },
  
  /**
   * Return the indexOf &#x60;start&#x60; / &#x60;end&#x60; delimiters.
   *
   * @param {String} start
   * @param {String} end
   * @return {Number}
   * @api private
   */
  
  indexOfDelimiters: function(start, end){
    var str = this.input
      , nstart = 0
      , nend = 0
      , pos = 0;
    for (var i = 0, len = str.length; i &lt; len; ++i) {
      if (start == str.charAt(i)) {
        ++nstart;
      } else if (end == str.charAt(i)) {
        if (++nend == nstart) {
          pos = i;
          break;
        }
      }
    }
    return pos;
  },
  
  /**
   * Stashed token.
   */
  
  stashed: function() {
    return this.stash.length
      &amp;&amp; this.stash.shift();
  },
  
  /**
   * Deferred token.
   */
  
  deferred: function() {
    return this.deferredTokens.length 
      &amp;&amp; this.deferredTokens.shift();
  },
  
  /**
   * end-of-source.
   */
  
  eos: function() {
    if (this.input.length) return;
    if (this.indentStack.length) {
      this.indentStack.shift();
      return this.tok(&#x27;outdent&#x27;);
    } else {
      return this.tok(&#x27;eos&#x27;);
    }
  },

  /**
   * Blank line.
   */
  
  blank: function() {
    var captures;
    if (captures = /^\n *\n/.exec(this.input)) {
      this.consume(captures[0].length - 1);
      if (this.pipeless) return this.tok(&#x27;text&#x27;, &#x27;&#x27;);
      return this.next();
    }
  },

  /**
   * Comment.
   */
  
  comment: function() {
    var captures;
    if (captures = /^ *\/\/(-)?([^\n]*)/.exec(this.input)) {
      this.consume(captures[0].length);
      var tok = this.tok(&#x27;comment&#x27;, captures[2]);
      tok.buffer = &#x27;-&#x27; != captures[1];
      return tok;
    }
  },

  /**
   * Interpolated tag.
   */

  interpolation: function() {
    var captures;
    if (captures = /^#\{(.*?)\}/.exec(this.input)) {
      this.consume(captures[0].length);
      return this.tok(&#x27;interpolation&#x27;, captures[1]);
    }
  },

  /**
   * Tag.
   */
  
  tag: function() {
    var captures;
    if (captures = /^(\w[-:\w]*)(\/?)/.exec(this.input)) {
      this.consume(captures[0].length);
      var tok, name = captures[1];
      if (&#x27;:&#x27; == name[name.length - 1]) {
        name = name.slice(0, -1);
        tok = this.tok(&#x27;tag&#x27;, name);
        this.defer(this.tok(&#x27;:&#x27;));
        while (&#x27; &#x27; == this.input[0]) this.input = this.input.substr(1);
      } else {
        tok = this.tok(&#x27;tag&#x27;, name);
      }
      tok.selfClosing = !! captures[2];
      return tok;
    }
  },
  
  /**
   * Filter.
   */
  
  filter: function() {
    return this.scan(/^:(\w+)/, &#x27;filter&#x27;);
  },
  
  /**
   * Doctype.
   */
  
  doctype: function() {
    return this.scan(/^(?:!!!|doctype) *([^\n]+)?/, &#x27;doctype&#x27;);
  },

  /**
   * Id.
   */
  
  id: function() {
    return this.scan(/^#([\w-]+)/, &#x27;id&#x27;);
  },
  
  /**
   * Class.
   */
  
  className: function() {
    return this.scan(/^\.([\w-]+)/, &#x27;class&#x27;);
  },
  
  /**
   * Text.
   */
  
  text: function() {
    return this.scan(/^(?:\| ?| ?)?([^\n]+)/, &#x27;text&#x27;);
  },

  /**
   * Extends.
   */
  
  &quot;extends&quot;: function() {
    return this.scan(/^extends? +([^\n]+)/, &#x27;extends&#x27;);
  },

  /**
   * Block prepend.
   */
  
  prepend: function() {
    var captures;
    if (captures = /^prepend +([^\n]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      var mode = &#x27;prepend&#x27;
        , name = captures[1]
        , tok = this.tok(&#x27;block&#x27;, name);
      tok.mode = mode;
      return tok;
    }
  },
  
  /**
   * Block append.
   */
  
  append: function() {
    var captures;
    if (captures = /^append +([^\n]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      var mode = &#x27;append&#x27;
        , name = captures[1]
        , tok = this.tok(&#x27;block&#x27;, name);
      tok.mode = mode;
      return tok;
    }
  },

  /**
   * Block.
   */
  
  block: function() {
    var captures;
    if (captures = /^block\b *(?:(prepend|append) +)?([^\n]*)/.exec(this.input)) {
      this.consume(captures[0].length);
      var mode = captures[1] || &#x27;replace&#x27;
        , name = captures[2]
        , tok = this.tok(&#x27;block&#x27;, name);

      tok.mode = mode;
      return tok;
    }
  },

  /**
   * Yield.
   */
  
  yield: function() {
    return this.scan(/^yield */, &#x27;yield&#x27;);
  },

  /**
   * Include.
   */
  
  include: function() {
    return this.scan(/^include +([^\n]+)/, &#x27;include&#x27;);
  },

  /**
   * Case.
   */
  
  &quot;case&quot;: function() {
    return this.scan(/^case +([^\n]+)/, &#x27;case&#x27;);
  },

  /**
   * When.
   */
  
  when: function() {
    return this.scan(/^when +([^:\n]+)/, &#x27;when&#x27;);
  },

  /**
   * Default.
   */
  
  &quot;default&quot;: function() {
    return this.scan(/^default */, &#x27;default&#x27;);
  },

  /**
   * Assignment.
   */
  
  assignment: function() {
    var captures;
    if (captures = /^(\w+) += *([^;\n]+)( *;? *)/.exec(this.input)) {
      this.consume(captures[0].length);
      var name = captures[1]
        , val = captures[2];
      return this.tok(&#x27;code&#x27;, &#x27;var &#x27; + name + &#x27; = (&#x27; + val + &#x27;);&#x27;);
    }
  },

  /**
   * Call mixin.
   */
  
  call: function(){
    var captures;
    if (captures = /^\+([-\w]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      var tok = this.tok(&#x27;call&#x27;, captures[1]);
      
      // Check for args (not attributes)
      if (captures = /^ *\((.*?)\)/.exec(this.input)) {
        if (!/^ *[-\w]+ *=/.test(captures[1])) {
          this.consume(captures[0].length);
          tok.args = captures[1];
        }
      }
      
      return tok;
    }
  },

  /**
   * Mixin.
   */

  mixin: function(){
    var captures;
    if (captures = /^mixin +([-\w]+)(?: *\((.*)\))?/.exec(this.input)) {
      this.consume(captures[0].length);
      var tok = this.tok(&#x27;mixin&#x27;, captures[1]);
      tok.args = captures[2];
      return tok;
    }
  },

  /**
   * Conditional.
   */
  
  conditional: function() {
    var captures;
    if (captures = /^(if|unless|else if|else)\b([^\n]*)/.exec(this.input)) {
      this.consume(captures[0].length);
      var type = captures[1]
        , js = captures[2];

      switch (type) {
        case &#x27;if&#x27;: js = &#x27;if (&#x27; + js + &#x27;)&#x27;; break;
        case &#x27;unless&#x27;: js = &#x27;if (!(&#x27; + js + &#x27;))&#x27;; break;
        case &#x27;else if&#x27;: js = &#x27;else if (&#x27; + js + &#x27;)&#x27;; break;
        case &#x27;else&#x27;: js = &#x27;else&#x27;; break;
      }

      return this.tok(&#x27;code&#x27;, js);
    }
  },

  /**
   * While.
   */
  
  &quot;while&quot;: function() {
    var captures;
    if (captures = /^while +([^\n]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      return this.tok(&#x27;code&#x27;, &#x27;while (&#x27; + captures[1] + &#x27;)&#x27;);
    }
  },

  /**
   * Each.
   */
  
  each: function() {
    var captures;
    if (captures = /^(?:- *)?(?:each|for) +(\w+)(?: *, *(\w+))? * in *([^\n]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      var tok = this.tok(&#x27;each&#x27;, captures[1]);
      tok.key = captures[2] || &#x27;$index&#x27;;
      tok.code = captures[3];
      return tok;
    }
  },
  
  /**
   * Code.
   */
  
  code: function() {
    var captures;
    if (captures = /^(!?=|-)([^\n]+)/.exec(this.input)) {
      this.consume(captures[0].length);
      var flags = captures[1];
      captures[1] = captures[2];
      var tok = this.tok(&#x27;code&#x27;, captures[1]);
      tok.escape = flags[0] === &#x27;=&#x27;;
      tok.buffer = flags[0] === &#x27;=&#x27; || flags[1] === &#x27;=&#x27;;
      return tok;
    }
  },
  
  /**
   * Attributes.
   */
  
  attrs: function() {
    if (&#x27;(&#x27; == this.input.charAt(0)) {
      var index = this.indexOfDelimiters(&#x27;(&#x27;, &#x27;)&#x27;)
        , str = this.input.substr(1, index-1)
        , tok = this.tok(&#x27;attrs&#x27;)
        , len = str.length
        , colons = this.colons
        , states = [&#x27;key&#x27;]
        , escapedAttr
        , key = &#x27;&#x27;
        , val = &#x27;&#x27;
        , quote
        , c
        , p;

      function state(){
        return states[states.length - 1];
      }

      function interpolate(attr) {
        return attr.replace(/#\{([^}]+)\}/g, function(_, expr){
          return quote + &quot; + (&quot; + expr + &quot;) + &quot; + quote;
        });
      }

      this.consume(index + 1);
      tok.attrs = {};
      tok.escaped = {};

      function parse(c) {
        var real = c;
        // TODO: remove when people fix &quot;:&quot;
        if (colons &amp;&amp; &#x27;:&#x27; == c) c = &#x27;=&#x27;;
        switch (c) {
          case &#x27;,&#x27;:
          case &#x27;\n&#x27;:
            switch (state()) {
              case &#x27;expr&#x27;:
              case &#x27;array&#x27;:
              case &#x27;string&#x27;:
              case &#x27;object&#x27;:
                val += c;
                break;
              default:
                states.push(&#x27;key&#x27;);
                val = val.trim();
                key = key.trim();
                if (&#x27;&#x27; == key) return;
                key = key.replace(/^[&#x27;&quot;]|[&#x27;&quot;]$/g, &#x27;&#x27;).replace(&#x27;!&#x27;, &#x27;&#x27;);
                tok.escaped[key] = escapedAttr;
                tok.attrs[key] = &#x27;&#x27; == val
                  ? true
                  : interpolate(val);
                key = val = &#x27;&#x27;;
            }
            break;
          case &#x27;=&#x27;:
            switch (state()) {
              case &#x27;key char&#x27;:
                key += real;
                break;
              case &#x27;val&#x27;:
              case &#x27;expr&#x27;:
              case &#x27;array&#x27;:
              case &#x27;string&#x27;:
              case &#x27;object&#x27;:
                val += real;
                break;
              default:
                escapedAttr = &#x27;!&#x27; != p;
                states.push(&#x27;val&#x27;);
            }
            break;
          case &#x27;(&#x27;:
            if (&#x27;val&#x27; == state()
              || &#x27;expr&#x27; == state()) states.push(&#x27;expr&#x27;);
            val += c;
            break;
          case &#x27;)&#x27;:
            if (&#x27;expr&#x27; == state()
              || &#x27;val&#x27; == state()) states.pop();
            val += c;
            break;
          case &#x27;{&#x27;:
            if (&#x27;val&#x27; == state()) states.push(&#x27;object&#x27;);
            val += c;
            break;
          case &#x27;}&#x27;:
            if (&#x27;object&#x27; == state()) states.pop();
            val += c;
            break;
          case &#x27;[&#x27;:
            if (&#x27;val&#x27; == state()) states.push(&#x27;array&#x27;);
            val += c;
            break;
          case &#x27;]&#x27;:
            if (&#x27;array&#x27; == state()) states.pop();
            val += c;
            break;
          case &#x27;&quot;&#x27;:
          case &quot;&#x27;&quot;:
            switch (state()) {
              case &#x27;key&#x27;:
                states.push(&#x27;key char&#x27;);
                break;
              case &#x27;key char&#x27;:
                states.pop();
                break;
              case &#x27;string&#x27;:
                if (c == quote) states.pop();
                val += c;
                break;
              default:
                states.push(&#x27;string&#x27;);
                val += c;
                quote = c;
            }
            break;
          case &#x27;&#x27;:
            break;
          default:
            switch (state()) {
              case &#x27;key&#x27;:
              case &#x27;key char&#x27;:
                key += c;
                break;
              default:
                val += c;
            }
        }
        p = c;
      }

      for (var i = 0; i &lt; len; ++i) {
        parse(str.charAt(i));
      }

      parse(&#x27;,&#x27;);

      if (&#x27;/&#x27; == this.input.charAt(0)) {
        this.consume(1);
        tok.selfClosing = true;
      }

      return tok;
    }
  },
  
  /**
   * Indent | Outdent | Newline.
   */
  
  indent: function() {
    var captures, re;

    // established regexp
    if (this.indentRe) {
      captures = this.indentRe.exec(this.input);
    // determine regexp
    } else {
      // tabs
      re = /^\n(\t*) */;
      captures = re.exec(this.input);

      // spaces
      if (captures &amp;&amp; !captures[1].length) {
        re = /^\n( *)/;
        captures = re.exec(this.input);
      }

      // established
      if (captures &amp;&amp; captures[1].length) this.indentRe = re;
    }

    if (captures) {
      var tok
        , indents = captures[1].length;

      ++this.lineno;
      this.consume(indents + 1);

      if (&#x27; &#x27; == this.input[0] || &#x27;\t&#x27; == this.input[0]) {
        throw new Error(&#x27;Invalid indentation, you can use tabs or spaces but not both&#x27;);
      }

      // blank line
      if (&#x27;\n&#x27; == this.input[0]) return this.tok(&#x27;newline&#x27;);

      // outdent
      if (this.indentStack.length &amp;&amp; indents &lt; this.indentStack[0]) {
        while (this.indentStack.length &amp;&amp; this.indentStack[0] &gt; indents) {
          this.stash.push(this.tok(&#x27;outdent&#x27;));
          this.indentStack.shift();
        }
        tok = this.stash.pop();
      // indent
      } else if (indents &amp;&amp; indents != this.indentStack[0]) {
        this.indentStack.unshift(indents);
        tok = this.tok(&#x27;indent&#x27;, indents);
      // newline
      } else {
        tok = this.tok(&#x27;newline&#x27;);
      }

      return tok;
    }
  },

  /**
   * Pipe-less text consumed only when 
   * pipeless is true;
   */

  pipelessText: function() {
    if (this.pipeless) {
      if (&#x27;\n&#x27; == this.input[0]) return;
      var i = this.input.indexOf(&#x27;\n&#x27;);
      if (-1 == i) i = this.input.length;
      var str = this.input.substr(0, i);
      this.consume(str.length);
      return this.tok(&#x27;text&#x27;, str);
    }
  },

  /**
   * &#x27;:&#x27;
   */

  colon: function() {
    return this.scan(/^: */, &#x27;:&#x27;);
  },

  /**
   * Return the next token object, or those
   * previously stashed by lookahead.
   *
   * @return {Object}
   * @api private
   */
  
  advance: function(){
    return this.stashed()
      || this.next();
  },
  
  /**
   * Return the next token object.
   *
   * @return {Object}
   * @api private
   */
  
  next: function() {
    return this.deferred()
      || this.blank()
      || this.eos()
      || this.pipelessText()
      || this.yield()
      || this.doctype()
      || this.interpolation()
      || this[&quot;case&quot;]()
      || this.when()
      || this[&quot;default&quot;]()
      || this[&quot;extends&quot;]()
      || this.append()
      || this.prepend()
      || this.block()
      || this.include()
      || this.mixin()
      || this.call()
      || this.conditional()
      || this.each()
      || this[&quot;while&quot;]()
      || this.assignment()
      || this.tag()
      || this.filter()
      || this.code()
      || this.id()
      || this.className()
      || this.attrs()
      || this.indent()
      || this.comment()
      || this.colon()
      || this.text();
  }
};

}); // module: lexer.js

jadeRequire.register(&quot;nodes/attrs.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - nodes - Attrs
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = jadeRequire(&#x27;./node&#x27;),
    Block = jadeRequire(&#x27;./block&#x27;);

/**
 * Initialize a &#x60;Attrs&#x60; node.
 *
 * @api public
 */

var Attrs = module.exports = function Attrs() {
  this.attrs = [];
};

/**
 * Inherit from &#x60;Node&#x60;.
 */

Attrs.prototype = new Node;
Attrs.prototype.constructor = Attrs;


/**
 * Set attribute &#x60;name&#x60; to &#x60;val&#x60;, keep in mind these become
 * part of a raw js object literal, so to quote a value you must
 * &#x27;&quot;quote me&quot;&#x27;, otherwise or example &#x27;user.name&#x27; is literal JavaScript.
 *
 * @param {String} name
 * @param {String} val
 * @param {Boolean} escaped
 * @return {Tag} for chaining
 * @api public
 */

Attrs.prototype.setAttribute = function(name, val, escaped){
  this.attrs.push({ name: name, val: val, escaped: escaped });
  return this;
};

/**
 * Remove attribute &#x60;name&#x60; when present.
 *
 * @param {String} name
 * @api public
 */

Attrs.prototype.removeAttribute = function(name){
  for (var i = 0, len = this.attrs.length; i &lt; len; ++i) {
    if (this.attrs[i] &amp;&amp; this.attrs[i].name == name) {
      delete this.attrs[i];
    }
  }
};

/**
 * Get attribute value by &#x60;name&#x60;.
 *
 * @param {String} name
 * @return {String}
 * @api public
 */

Attrs.prototype.getAttribute = function(name){
  for (var i = 0, len = this.attrs.length; i &lt; len; ++i) {
    if (this.attrs[i] &amp;&amp; this.attrs[i].name == name) {
      return this.attrs[i].val;
    }
  }
};

}); // module: nodes/attrs.js

jadeRequire.register(&quot;nodes/block-comment.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - nodes - BlockComment
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = jadeRequire(&#x27;./node&#x27;);

/**
 * Initialize a &#x60;BlockComment&#x60; with the given &#x60;block&#x60;.
 *
 * @param {String} val
 * @param {Block} block
 * @param {Boolean} buffer
 * @api public
 */

var BlockComment = module.exports = function BlockComment(val, block, buffer) {
  this.block = block;
  this.val = val;
  this.buffer = buffer;
};

/**
 * Inherit from &#x60;Node&#x60;.
 */

BlockComment.prototype = new Node;
BlockComment.prototype.constructor = BlockComment;

}); // module: nodes/block-comment.js

jadeRequire.register(&quot;nodes/block.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - nodes - Block
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = jadeRequire(&#x27;./node&#x27;);

/**
 * Initialize a new &#x60;Block&#x60; with an optional &#x60;node&#x60;.
 *
 * @param {Node} node
 * @api public
 */

var Block = module.exports = function Block(node){
  this.nodes = [];
  if (node) this.push(node);
};

/**
 * Inherit from &#x60;Node&#x60;.
 */

Block.prototype = new Node;
Block.prototype.constructor = Block;


/**
 * Block flag.
 */

Block.prototype.isBlock = true;

/**
 * Replace the nodes in &#x60;other&#x60; with the nodes
 * in &#x60;this&#x60; block.
 *
 * @param {Block} other
 * @api private
 */

Block.prototype.replace = function(other){
  other.nodes = this.nodes;
};

/**
 * Pust the given &#x60;node&#x60;.
 *
 * @param {Node} node
 * @return {Number}
 * @api public
 */

Block.prototype.push = function(node){
  return this.nodes.push(node);
};

/**
 * Check if this block is empty.
 *
 * @return {Boolean}
 * @api public
 */

Block.prototype.isEmpty = function(){
  return 0 == this.nodes.length;
};

/**
 * Unshift the given &#x60;node&#x60;.
 *
 * @param {Node} node
 * @return {Number}
 * @api public
 */

Block.prototype.unshift = function(node){
  return this.nodes.unshift(node);
};

/**
 * Return the &quot;last&quot; block, or the first &#x60;yield&#x60; node.
 *
 * @return {Block}
 * @api private
 */

Block.prototype.includeBlock = function(){
  var ret = this
    , node;

  for (var i = 0, len = this.nodes.length; i &lt; len; ++i) {
    node = this.nodes[i];
    if (node.yield) return node;
    else if (node.textOnly) continue;
    else if (node.includeBlock) ret = node.includeBlock();
    else if (node.block &amp;&amp; !node.block.isEmpty()) ret = node.block.includeBlock();
  }

  return ret;
};

/**
 * Return a clone of this block.
 *
 * @return {Block}
 * @api private
 */

Block.prototype.clone = function(){
  var clone = new Block;
  for (var i = 0, len = this.nodes.length; i &lt; len; ++i) {
    clone.push(this.nodes[i].clone());
  }
  return clone;
};


}); // module: nodes/block.js

jadeRequire.register(&quot;nodes/case.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - nodes - Case
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = jadeRequire(&#x27;./node&#x27;);

/**
 * Initialize a new &#x60;Case&#x60; with &#x60;expr&#x60;.
 *
 * @param {String} expr
 * @api public
 */

var Case = exports = module.exports = function Case(expr, block){
  this.expr = expr;
  this.block = block;
};

/**
 * Inherit from &#x60;Node&#x60;.
 */

Case.prototype = new Node;
Case.prototype.constructor = Case;


var When = exports.When = function When(expr, block){
  this.expr = expr;
  this.block = block;
  this.debug = false;
};

/**
 * Inherit from &#x60;Node&#x60;.
 */

When.prototype = new Node;
When.prototype.constructor = When;



}); // module: nodes/case.js

jadeRequire.register(&quot;nodes/code.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - nodes - Code
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = jadeRequire(&#x27;./node&#x27;);

/**
 * Initialize a &#x60;Code&#x60; node with the given code &#x60;val&#x60;.
 * Code may also be optionally buffered and escaped.
 *
 * @param {String} val
 * @param {Boolean} buffer
 * @param {Boolean} escape
 * @api public
 */

var Code = module.exports = function Code(val, buffer, escape) {
  this.val = val;
  this.buffer = buffer;
  this.escape = escape;
  if (val.match(/^ *else/)) this.debug = false;
};

/**
 * Inherit from &#x60;Node&#x60;.
 */

Code.prototype = new Node;
Code.prototype.constructor = Code;

}); // module: nodes/code.js

jadeRequire.register(&quot;nodes/comment.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - nodes - Comment
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = jadeRequire(&#x27;./node&#x27;);

/**
 * Initialize a &#x60;Comment&#x60; with the given &#x60;val&#x60;, optionally &#x60;buffer&#x60;,
 * otherwise the comment may render in the output.
 *
 * @param {String} val
 * @param {Boolean} buffer
 * @api public
 */

var Comment = module.exports = function Comment(val, buffer) {
  this.val = val;
  this.buffer = buffer;
};

/**
 * Inherit from &#x60;Node&#x60;.
 */

Comment.prototype = new Node;
Comment.prototype.constructor = Comment;

}); // module: nodes/comment.js

jadeRequire.register(&quot;nodes/doctype.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - nodes - Doctype
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = jadeRequire(&#x27;./node&#x27;);

/**
 * Initialize a &#x60;Doctype&#x60; with the given &#x60;val&#x60;. 
 *
 * @param {String} val
 * @api public
 */

var Doctype = module.exports = function Doctype(val) {
  this.val = val;
};

/**
 * Inherit from &#x60;Node&#x60;.
 */

Doctype.prototype = new Node;
Doctype.prototype.constructor = Doctype;

}); // module: nodes/doctype.js

jadeRequire.register(&quot;nodes/each.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - nodes - Each
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = jadeRequire(&#x27;./node&#x27;);

/**
 * Initialize an &#x60;Each&#x60; node, representing iteration
 *
 * @param {String} obj
 * @param {String} val
 * @param {String} key
 * @param {Block} block
 * @api public
 */

var Each = module.exports = function Each(obj, val, key, block) {
  this.obj = obj;
  this.val = val;
  this.key = key;
  this.block = block;
};

/**
 * Inherit from &#x60;Node&#x60;.
 */

Each.prototype = new Node;
Each.prototype.constructor = Each;

}); // module: nodes/each.js

jadeRequire.register(&quot;nodes/filter.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - nodes - Filter
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = jadeRequire(&#x27;./node&#x27;)
  , Block = jadeRequire(&#x27;./block&#x27;);

/**
 * Initialize a &#x60;Filter&#x60; node with the given 
 * filter &#x60;name&#x60; and &#x60;block&#x60;.
 *
 * @param {String} name
 * @param {Block|Node} block
 * @api public
 */

var Filter = module.exports = function Filter(name, block, attrs) {
  this.name = name;
  this.block = block;
  this.attrs = attrs;
  this.isASTFilter = !block.nodes.every(function(node){ return node.isText });
};

/**
 * Inherit from &#x60;Node&#x60;.
 */

Filter.prototype = new Node;
Filter.prototype.constructor = Filter;

}); // module: nodes/filter.js

jadeRequire.register(&quot;nodes/index.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - nodes
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

exports.Node = jadeRequire(&#x27;./node&#x27;);
exports.Tag = jadeRequire(&#x27;./tag&#x27;);
exports.Code = jadeRequire(&#x27;./code&#x27;);
exports.Each = jadeRequire(&#x27;./each&#x27;);
exports.Case = jadeRequire(&#x27;./case&#x27;);
exports.Text = jadeRequire(&#x27;./text&#x27;);
exports.Block = jadeRequire(&#x27;./block&#x27;);
exports.Mixin = jadeRequire(&#x27;./mixin&#x27;);
exports.Filter = jadeRequire(&#x27;./filter&#x27;);
exports.Comment = jadeRequire(&#x27;./comment&#x27;);
exports.Literal = jadeRequire(&#x27;./literal&#x27;);
exports.BlockComment = jadeRequire(&#x27;./block-comment&#x27;);
exports.Doctype = jadeRequire(&#x27;./doctype&#x27;);

}); // module: nodes/index.js

jadeRequire.register(&quot;nodes/literal.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - nodes - Literal
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = jadeRequire(&#x27;./node&#x27;);

/**
 * Initialize a &#x60;Literal&#x60; node with the given &#x60;str.
 *
 * @param {String} str
 * @api public
 */

var Literal = module.exports = function Literal(str) {
  this.str = str
    .replace(/\\/g, &quot;\\\\&quot;)
    .replace(/\n|\r\n/g, &quot;\\n&quot;)
    .replace(/&#x27;/g, &quot;\\&#x27;&quot;);
};

/**
 * Inherit from &#x60;Node&#x60;.
 */

Literal.prototype = new Node;
Literal.prototype.constructor = Literal;


}); // module: nodes/literal.js

jadeRequire.register(&quot;nodes/mixin.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - nodes - Mixin
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Attrs = jadeRequire(&#x27;./attrs&#x27;);

/**
 * Initialize a new &#x60;Mixin&#x60; with &#x60;name&#x60; and &#x60;block&#x60;.
 *
 * @param {String} name
 * @param {String} args
 * @param {Block} block
 * @api public
 */

var Mixin = module.exports = function Mixin(name, args, block, call){
  this.name = name;
  this.args = args;
  this.block = block;
  this.attrs = [];
  this.call = call;
};

/**
 * Inherit from &#x60;Attrs&#x60;.
 */

Mixin.prototype = new Attrs;
Mixin.prototype.constructor = Mixin;



}); // module: nodes/mixin.js

jadeRequire.register(&quot;nodes/node.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - nodes - Node
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

/**
 * Initialize a &#x60;Node&#x60;.
 *
 * @api public
 */

var Node = module.exports = function Node(){};

/**
 * Clone this node (return itself)
 *
 * @return {Node}
 * @api private
 */

Node.prototype.clone = function(){
  return this;
};

}); // module: nodes/node.js

jadeRequire.register(&quot;nodes/tag.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - nodes - Tag
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Attrs = jadeRequire(&#x27;./attrs&#x27;),
    Block = jadeRequire(&#x27;./block&#x27;),
    inlineTags = jadeRequire(&#x27;../inline-tags&#x27;);

/**
 * Initialize a &#x60;Tag&#x60; node with the given tag &#x60;name&#x60; and optional &#x60;block&#x60;.
 *
 * @param {String} name
 * @param {Block} block
 * @api public
 */

var Tag = module.exports = function Tag(name, block) {
  this.name = name;
  this.attrs = [];
  this.block = block || new Block;
};

/**
 * Inherit from &#x60;Attrs&#x60;.
 */

Tag.prototype = new Attrs;
Tag.prototype.constructor = Tag;


/**
 * Clone this tag.
 *
 * @return {Tag}
 * @api private
 */

Tag.prototype.clone = function(){
  var clone = new Tag(this.name, this.block.clone());
  clone.line = this.line;
  clone.attrs = this.attrs;
  clone.textOnly = this.textOnly;
  return clone;
};

/**
 * Check if this tag is an inline tag.
 *
 * @return {Boolean}
 * @api private
 */

Tag.prototype.isInline = function(){
  return ~inlineTags.indexOf(this.name);
};

/**
 * Check if this tag&#x27;s contents can be inlined.  Used for pretty printing.
 *
 * @return {Boolean}
 * @api private
 */

Tag.prototype.canInline = function(){
  var nodes = this.block.nodes;

  function isInline(node){
    // Recurse if the node is a block
    if (node.isBlock) return node.nodes.every(isInline);
    return node.isText || (node.isInline &amp;&amp; node.isInline());
  }
  
  // Empty tag
  if (!nodes.length) return true;
  
  // Text-only or inline-only tag
  if (1 == nodes.length) return isInline(nodes[0]);
  
  // Multi-line inline-only tag
  if (this.block.nodes.every(isInline)) {
    for (var i = 1, len = nodes.length; i &lt; len; ++i) {
      if (nodes[i-1].isText &amp;&amp; nodes[i].isText)
        return false;
    }
    return true;
  }
  
  // Mixed tag
  return false;
};
}); // module: nodes/tag.js

jadeRequire.register(&quot;nodes/text.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - nodes - Text
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Node = jadeRequire(&#x27;./node&#x27;);

/**
 * Initialize a &#x60;Text&#x60; node with optional &#x60;line&#x60;.
 *
 * @param {String} line
 * @api public
 */

var Text = module.exports = function Text(line) {
  this.val = &#x27;&#x27;;
  if (&#x27;string&#x27; == typeof line) this.val = line;
};

/**
 * Inherit from &#x60;Node&#x60;.
 */

Text.prototype = new Node;
Text.prototype.constructor = Text;


/**
 * Flag as text.
 */

Text.prototype.isText = true;
}); // module: nodes/text.js

jadeRequire.register(&quot;parser.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - Parser
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var Lexer = jadeRequire(&#x27;./lexer&#x27;)
  , nodes = jadeRequire(&#x27;./nodes&#x27;);

/**
 * Initialize &#x60;Parser&#x60; with the given input &#x60;str&#x60; and &#x60;filename&#x60;.
 *
 * @param {String} str
 * @param {String} filename
 * @param {Object} options
 * @api public
 */

var Parser = exports = module.exports = function Parser(str, filename, options){
  this.input = str;
  this.lexer = new Lexer(str, options);
  this.filename = filename;
  this.blocks = {};
  this.mixins = {};
  this.options = options;
  this.contexts = [this];
};

/**
 * Tags that may not contain tags.
 */

var textOnly = exports.textOnly = [&#x27;script&#x27;, &#x27;style&#x27;];

/**
 * Parser prototype.
 */

Parser.prototype = {

  /**
   * Push &#x60;parser&#x60; onto the context stack,
   * or pop and return a &#x60;Parser&#x60;.
   */

  context: function(parser){
    if (parser) {
      this.contexts.push(parser);
    } else {
      return this.contexts.pop();
    }
  },

  /**
   * Return the next token object.
   *
   * @return {Object}
   * @api private
   */

  advance: function(){
    return this.lexer.advance();
  },

  /**
   * Skip &#x60;n&#x60; tokens.
   *
   * @param {Number} n
   * @api private
   */

  skip: function(n){
    while (n--) this.advance();
  },
  
  /**
   * Single token lookahead.
   *
   * @return {Object}
   * @api private
   */
  
  peek: function() {
    return this.lookahead(1);
  },
  
  /**
   * Return lexer lineno.
   *
   * @return {Number}
   * @api private
   */
  
  line: function() {
    return this.lexer.lineno;
  },
  
  /**
   * &#x60;n&#x60; token lookahead.
   *
   * @param {Number} n
   * @return {Object}
   * @api private
   */
  
  lookahead: function(n){
    return this.lexer.lookahead(n);
  },
  
  /**
   * Parse input returning a string of js for evaluation.
   *
   * @return {String}
   * @api public
   */
  
  parse: function(){
    var block = new nodes.Block, parser;
    block.line = this.line();

    while (&#x27;eos&#x27; != this.peek().type) {
      if (&#x27;newline&#x27; == this.peek().type) {
        this.advance();
      } else {
        block.push(this.parseExpr());
      }
    }

    if (parser = this.extending) {
      this.context(parser);
      var ast = parser.parse();
      this.context();
      // hoist mixins
      for (var name in this.mixins)
        ast.unshift(this.mixins[name]);
      return ast;
    }

    return block;
  },
  
  /**
   * Expect the given type, or throw an exception.
   *
   * @param {String} type
   * @api private
   */
  
  expect: function(type){
    if (this.peek().type === type) {
      return this.advance();
    } else {
      throw new Error(&#x27;expected &quot;&#x27; + type + &#x27;&quot;, but got &quot;&#x27; + this.peek().type + &#x27;&quot;&#x27;);
    }
  },
  
  /**
   * Accept the given &#x60;type&#x60;.
   *
   * @param {String} type
   * @api private
   */
  
  accept: function(type){
    if (this.peek().type === type) {
      return this.advance();
    }
  },
  
  /**
   *   tag
   * | doctype
   * | mixin
   * | include
   * | filter
   * | comment
   * | text
   * | each
   * | code
   * | yield
   * | id
   * | class
   * | interpolation
   */
  
  parseExpr: function(){
    switch (this.peek().type) {
      case &#x27;tag&#x27;:
        return this.parseTag();
      case &#x27;mixin&#x27;:
        return this.parseMixin();
      case &#x27;block&#x27;:
        return this.parseBlock();
      case &#x27;case&#x27;:
        return this.parseCase();
      case &#x27;when&#x27;:
        return this.parseWhen();
      case &#x27;default&#x27;:
        return this.parseDefault();
      case &#x27;extends&#x27;:
        return this.parseExtends();
      case &#x27;include&#x27;:
        return this.parseInclude();
      case &#x27;doctype&#x27;:
        return this.parseDoctype();
      case &#x27;filter&#x27;:
        return this.parseFilter();
      case &#x27;comment&#x27;:
        return this.parseComment();
      case &#x27;text&#x27;:
        return this.parseText();
      case &#x27;each&#x27;:
        return this.parseEach();
      case &#x27;code&#x27;:
        return this.parseCode();
      case &#x27;call&#x27;:
        return this.parseCall();
      case &#x27;interpolation&#x27;:
        return this.parseInterpolation();
      case &#x27;yield&#x27;:
        this.advance();
        var block = new nodes.Block;
        block.yield = true;
        return block;
      case &#x27;id&#x27;:
      case &#x27;class&#x27;:
        var tok = this.advance();
        this.lexer.defer(this.lexer.tok(&#x27;tag&#x27;, &#x27;div&#x27;));
        this.lexer.defer(tok);
        return this.parseExpr();
      default:
        throw new Error(&#x27;unexpected token &quot;&#x27; + this.peek().type + &#x27;&quot;&#x27;);
    }
  },
  
  /**
   * Text
   */
  
  parseText: function(){
    var tok = this.expect(&#x27;text&#x27;)
      , node = new nodes.Text(tok.val);
    node.line = this.line();
    return node;
  },

  /**
   *   &#x27;:&#x27; expr
   * | block
   */

  parseBlockExpansion: function(){
    if (&#x27;:&#x27; == this.peek().type) {
      this.advance();
      return new nodes.Block(this.parseExpr());
    } else {
      return this.block();
    }
  },

  /**
   * case
   */

  parseCase: function(){
    var val = this.expect(&#x27;case&#x27;).val
      , node = new nodes.Case(val);
    node.line = this.line();
    node.block = this.block();
    return node;
  },

  /**
   * when
   */

  parseWhen: function(){
    var val = this.expect(&#x27;when&#x27;).val
    return new nodes.Case.When(val, this.parseBlockExpansion());
  },
  
  /**
   * default
   */

  parseDefault: function(){
    this.expect(&#x27;default&#x27;);
    return new nodes.Case.When(&#x27;default&#x27;, this.parseBlockExpansion());
  },

  /**
   * code
   */
  
  parseCode: function(){
    var tok = this.expect(&#x27;code&#x27;)
      , node = new nodes.Code(tok.val, tok.buffer, tok.escape)
      , block
      , i = 1;
    node.line = this.line();
    while (this.lookahead(i) &amp;&amp; &#x27;newline&#x27; == this.lookahead(i).type) ++i;
    block = &#x27;indent&#x27; == this.lookahead(i).type;
    if (block) {
      this.skip(i-1);
      node.block = this.block();
    }
    return node;
  },
  
  /**
   * comment
   */
  
  parseComment: function(){
    var tok = this.expect(&#x27;comment&#x27;)
      , node;

    if (&#x27;indent&#x27; == this.peek().type) {
      node = new nodes.BlockComment(tok.val, this.block(), tok.buffer);
    } else {
      node = new nodes.Comment(tok.val, tok.buffer);
    }

    node.line = this.line();
    return node;
  },
  
  /**
   * doctype
   */
  
  parseDoctype: function(){
    var tok = this.expect(&#x27;doctype&#x27;)
      , node = new nodes.Doctype(tok.val);
    node.line = this.line();
    return node;
  },
  
  /**
   * filter attrs? text-block
   */
  
  parseFilter: function(){
    var block
      , tok = this.expect(&#x27;filter&#x27;)
      , attrs = this.accept(&#x27;attrs&#x27;);

    this.lexer.pipeless = true;
    block = this.parseTextBlock();
    this.lexer.pipeless = false;

    var node = new nodes.Filter(tok.val, block, attrs &amp;&amp; attrs.attrs);
    node.line = this.line();
    return node;
  },
  
  /**
   * tag &#x27;:&#x27; attrs? block
   */
  
  parseASTFilter: function(){
    var block
      , tok = this.expect(&#x27;tag&#x27;)
      , attrs = this.accept(&#x27;attrs&#x27;);

    this.expect(&#x27;:&#x27;);
    block = this.block();

    var node = new nodes.Filter(tok.val, block, attrs &amp;&amp; attrs.attrs);
    node.line = this.line();
    return node;
  },
  
  /**
   * each block
   */
  
  parseEach: function(){
    var tok = this.expect(&#x27;each&#x27;)
      , node = new nodes.Each(tok.code, tok.val, tok.key);
    node.line = this.line();
    node.block = this.block();
    return node;
  },

  /**
   * &#x27;extends&#x27; name
   */

  parseExtends: function(){
    var path = jadeRequire(&#x27;path&#x27;)
      , fs = jadeRequire(&#x27;fs&#x27;)
      , dirname = path.dirname
      , basename = path.basename
      , join = path.join;

    if (!this.filename)
      throw new Error(&#x27;the &quot;filename&quot; option is jadeRequired to extend templates&#x27;);

    var path = this.expect(&#x27;extends&#x27;).val.trim()
      , dir = dirname(this.filename);

    var path = join(dir, path + &#x27;.jade&#x27;)
      , str = fs.readFileSync(path, &#x27;utf8&#x27;)
      , parser = new Parser(str, path, this.options);

    parser.blocks = this.blocks;
    parser.contexts = this.contexts;
    this.extending = parser;

    // TODO: null node
    return new nodes.Literal(&#x27;&#x27;);
  },

  /**
   * &#x27;block&#x27; name block
   */

  parseBlock: function(){
    var block = this.expect(&#x27;block&#x27;)
      , mode = block.mode
      , name = block.val.trim();

    block = &#x27;indent&#x27; == this.peek().type
      ? this.block()
      : new nodes.Block(new nodes.Literal(&#x27;&#x27;));

    var prev = this.blocks[name];

    if (prev) {
      switch (prev.mode) {
        case &#x27;append&#x27;:
          block.nodes = block.nodes.concat(prev.nodes);
          prev = block;
          break;
        case &#x27;prepend&#x27;:
          block.nodes = prev.nodes.concat(block.nodes);
          prev = block;
          break;
      }
    }

    block.mode = mode;
    return this.blocks[name] = prev || block;
  },

  /**
   * include block?
   */

  parseInclude: function(){
    var path = jadeRequire(&#x27;path&#x27;)
      , fs = jadeRequire(&#x27;fs&#x27;)
      , dirname = path.dirname
      , basename = path.basename
      , join = path.join;

    var path = this.expect(&#x27;include&#x27;).val.trim()
      , dir = dirname(this.filename);

    if (!this.filename)
      throw new Error(&#x27;the &quot;filename&quot; option is jadeRequired to use includes&#x27;);

    // no extension
    if (!~basename(path).indexOf(&#x27;.&#x27;)) {
      path += &#x27;.jade&#x27;;
    }

    // non-jade
    if (&#x27;.jade&#x27; != path.substr(-5)) {
      var path = join(dir, path)
        , str = fs.readFileSync(path, &#x27;utf8&#x27;);
      return new nodes.Literal(str);
    }

    var path = join(dir, path)
      , str = fs.readFileSync(path, &#x27;utf8&#x27;)
     , parser = new Parser(str, path, this.options);
    parser.blocks = this.blocks;
    parser.mixins = this.mixins;

    this.context(parser);
    var ast = parser.parse();
    this.context();
    ast.filename = path;

    if (&#x27;indent&#x27; == this.peek().type) {
      ast.includeBlock().push(this.block());
    }

    return ast;
  },

  /**
   * call ident block
   */

  parseCall: function(){
    var tok = this.expect(&#x27;call&#x27;)
      , name = tok.val
      , args = tok.args
      , mixin = new nodes.Mixin(name, args, new nodes.Block, true);

    this.tag(mixin);
    if (mixin.block.isEmpty()) mixin.block = null;
    return mixin;
  },

  /**
   * mixin block
   */

  parseMixin: function(){
    var tok = this.expect(&#x27;mixin&#x27;)
      , name = tok.val
      , args = tok.args
      , mixin;

    // definition
    if (&#x27;indent&#x27; == this.peek().type) {
      mixin = new nodes.Mixin(name, args, this.block(), false);
      this.mixins[name] = mixin;
      return mixin;
    // call
    } else {
      return new nodes.Mixin(name, args, null, true);
    }
  },

  /**
   * indent (text | newline)* outdent
   */

  parseTextBlock: function(){
    var block = new nodes.Block;
    block.line = this.line();
    var spaces = this.expect(&#x27;indent&#x27;).val;
    if (null == this._spaces) this._spaces = spaces;
    var indent = Array(spaces - this._spaces + 1).join(&#x27; &#x27;);
    while (&#x27;outdent&#x27; != this.peek().type) {
      switch (this.peek().type) {
        case &#x27;newline&#x27;:
          this.advance();
          break;
        case &#x27;indent&#x27;:
          this.parseTextBlock().nodes.forEach(function(node){
            block.push(node);
          });
          break;
        default:
          var text = new nodes.Text(indent + this.advance().val);
          text.line = this.line();
          block.push(text);
      }
    }

    if (spaces == this._spaces) this._spaces = null;
    this.expect(&#x27;outdent&#x27;);
    return block;
  },

  /**
   * indent expr* outdent
   */
  
  block: function(){
    var block = new nodes.Block;
    block.line = this.line();
    this.expect(&#x27;indent&#x27;);
    while (&#x27;outdent&#x27; != this.peek().type) {
      if (&#x27;newline&#x27; == this.peek().type) {
        this.advance();
      } else {
        block.push(this.parseExpr());
      }
    }
    this.expect(&#x27;outdent&#x27;);
    return block;
  },

  /**
   * interpolation (attrs | class | id)* (text | code | &#x27;:&#x27;)? newline* block?
   */
  
  parseInterpolation: function(){
    var tok = this.advance();
    var tag = new nodes.Tag(tok.val);
    tag.buffer = true;
    return this.tag(tag);
  },

  /**
   * tag (attrs | class | id)* (text | code | &#x27;:&#x27;)? newline* block?
   */
  
  parseTag: function(){
    // ast-filter look-ahead
    var i = 2;
    if (&#x27;attrs&#x27; == this.lookahead(i).type) ++i;
    if (&#x27;:&#x27; == this.lookahead(i).type) {
      if (&#x27;indent&#x27; == this.lookahead(++i).type) {
        return this.parseASTFilter();
      }
    }

    var tok = this.advance()
      , tag = new nodes.Tag(tok.val);

    tag.selfClosing = tok.selfClosing;

    return this.tag(tag);
  },

  /**
   * Parse tag.
   */

  tag: function(tag){
    var dot;

    tag.line = this.line();

    // (attrs | class | id)*
    out:
      while (true) {
        switch (this.peek().type) {
          case &#x27;id&#x27;:
          case &#x27;class&#x27;:
            var tok = this.advance();
            tag.setAttribute(tok.type, &quot;&#x27;&quot; + tok.val + &quot;&#x27;&quot;);
            continue;
          case &#x27;attrs&#x27;:
            var tok = this.advance()
              , obj = tok.attrs
              , escaped = tok.escaped
              , names = Object.keys(obj);

            if (tok.selfClosing) tag.selfClosing = true;

            for (var i = 0, len = names.length; i &lt; len; ++i) {
              var name = names[i]
                , val = obj[name];
              tag.setAttribute(name, val, escaped[name]);
            }
            continue;
          default:
            break out;
        }
      }

    // check immediate &#x27;.&#x27;
    if (&#x27;.&#x27; == this.peek().val) {
      dot = tag.textOnly = true;
      this.advance();
    }

    // (text | code | &#x27;:&#x27;)?
    switch (this.peek().type) {
      case &#x27;text&#x27;:
        tag.block.push(this.parseText());
        break;
      case &#x27;code&#x27;:
        tag.code = this.parseCode();
        break;
      case &#x27;:&#x27;:
        this.advance();
        tag.block = new nodes.Block;
        tag.block.push(this.parseExpr());
        break;
    }

    // newline*
    while (&#x27;newline&#x27; == this.peek().type) this.advance();

    tag.textOnly = tag.textOnly || ~textOnly.indexOf(tag.name);

    // script special-case
    if (&#x27;script&#x27; == tag.name) {
      var type = tag.getAttribute(&#x27;type&#x27;);
      if (!dot &amp;&amp; type &amp;&amp; &#x27;text/javascript&#x27; != type.replace(/^[&#x27;&quot;]|[&#x27;&quot;]$/g, &#x27;&#x27;)) {
        tag.textOnly = false;
      }
    }

    // block?
    if (&#x27;indent&#x27; == this.peek().type) {
      if (tag.textOnly) {
        this.lexer.pipeless = true;
        tag.block = this.parseTextBlock();
        this.lexer.pipeless = false;
      } else {
        var block = this.block();
        if (tag.block) {
          for (var i = 0, len = block.nodes.length; i &lt; len; ++i) {
            tag.block.push(block.nodes[i]);
          }
        } else {
          tag.block = block;
        }
      }
    }
    
    return tag;
  }
};

}); // module: parser.js

jadeRequire.register(&quot;runtime.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - runtime
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

/**
 * Lame Array.isArray() polyfill for now.
 */

if (!Array.isArray) {
  Array.isArray = function(arr){
    return &#x27;[object Array]&#x27; == Object.prototype.toString.call(arr);
  };
}

/**
 * Lame Object.keys() polyfill for now.
 */

if (!Object.keys) {
  Object.keys = function(obj){
    var arr = [];
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        arr.push(key);
      }
    }
    return arr;
  }
}

/**
 * Merge two attribute objects giving precedence
 * to values in object &#x60;b&#x60;. Classes are special-cased
 * allowing for arrays and merging/joining appropriately
 * resulting in a string.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api private
 */

exports.merge = function merge(a, b) {
  var ac = a[&#x27;class&#x27;];
  var bc = b[&#x27;class&#x27;];

  if (ac || bc) {
    ac = ac || [];
    bc = bc || [];
    if (!Array.isArray(ac)) ac = [ac];
    if (!Array.isArray(bc)) bc = [bc];
    ac = ac.filter(nulls);
    bc = bc.filter(nulls);
    a[&#x27;class&#x27;] = ac.concat(bc).join(&#x27; &#x27;);
  }

  for (var key in b) {
    if (key != &#x27;class&#x27;) {
      a[key] = b[key];
    }
  }

  return a;
};

/**
 * Filter null &#x60;val&#x60;s.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function nulls(val) {
  return val != null;
}

/**
 * Render the given attributes object.
 *
 * @param {Object} obj
 * @param {Object} escaped
 * @return {String}
 * @api private
 */

exports.attrs = function attrs(obj, escaped){
  var buf = []
    , terse = obj.terse;

  delete obj.terse;
  var keys = Object.keys(obj)
    , len = keys.length;

  if (len) {
    buf.push(&#x27;&#x27;);
    for (var i = 0; i &lt; len; ++i) {
      var key = keys[i]
        , val = obj[key];

      if (&#x27;boolean&#x27; == typeof val || null == val) {
        if (val) {
          terse
            ? buf.push(key)
            : buf.push(key + &#x27;=&quot;&#x27; + key + &#x27;&quot;&#x27;);
        }
      } else if (0 == key.indexOf(&#x27;data&#x27;) &amp;&amp; &#x27;string&#x27; != typeof val) {
        buf.push(key + &quot;=&#x27;&quot; + JSON.stringify(val) + &quot;&#x27;&quot;);
      } else if (&#x27;class&#x27; == key &amp;&amp; Array.isArray(val)) {
        buf.push(key + &#x27;=&quot;&#x27; + exports.escape(val.join(&#x27; &#x27;)) + &#x27;&quot;&#x27;);
      } else if (escaped &amp;&amp; escaped[key]) {
        buf.push(key + &#x27;=&quot;&#x27; + exports.escape(val) + &#x27;&quot;&#x27;);
      } else {
        buf.push(key + &#x27;=&quot;&#x27; + val + &#x27;&quot;&#x27;);
      }
    }
  }

  return buf.join(&#x27; &#x27;);
};

/**
 * Escape the given string of &#x60;html&#x60;.
 *
 * @param {String} html
 * @return {String}
 * @api private
 */

exports.escape = function escape(html){
  return String(html)
    .replace(/&amp;(?!(\w+|\#\d+);)/g, &#x27;&amp;amp;&#x27;)
    .replace(/&lt;/g, &#x27;&amp;lt;&#x27;)
    .replace(/&gt;/g, &#x27;&amp;gt;&#x27;)
    .replace(/&quot;/g, &#x27;&amp;quot;&#x27;);
};

/**
 * Re-throw the given &#x60;err&#x60; in context to the
 * the jade in &#x60;filename&#x60; at the given &#x60;lineno&#x60;.
 *
 * @param {Error} err
 * @param {String} filename
 * @param {String} lineno
 * @api private
 */

exports.rethrow = function rethrow(err, filename, lineno){
  if (!filename) throw err;

  var context = 3
    , str = jadeRequire(&#x27;fs&#x27;).readFileSync(filename, &#x27;utf8&#x27;)
    , lines = str.split(&#x27;\n&#x27;)
    , start = Math.max(lineno - context, 0)
    , end = Math.min(lines.length, lineno + context);

  // Error context
  var context = lines.slice(start, end).map(function(line, i){
    var curr = i + start + 1;
    return (curr == lineno ? &#x27;  &gt; &#x27; : &#x27;    &#x27;)
      + curr
      + &#x27;| &#x27;
      + line;
  }).join(&#x27;\n&#x27;);

  // Alter exception message
  err.path = filename;
  err.message = (filename || &#x27;Jade&#x27;) + &#x27;:&#x27; + lineno
    + &#x27;\n&#x27; + context + &#x27;\n\n&#x27; + err.message;
  throw err;
};

}); // module: runtime.js

jadeRequire.register(&quot;self-closing.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - self closing tags
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

module.exports = [
    &#x27;meta&#x27;
  , &#x27;img&#x27;
  , &#x27;link&#x27;
  , &#x27;input&#x27;
  , &#x27;source&#x27;
  , &#x27;area&#x27;
  , &#x27;base&#x27;
  , &#x27;col&#x27;
  , &#x27;br&#x27;
  , &#x27;hr&#x27;
];
}); // module: self-closing.js

jadeRequire.register(&quot;utils.js&quot;, function(module, exports, jadeRequire){

/*!
 * Jade - utils
 * Copyright(c) 2010 TJ Holowaychuk &lt;tj@vision-media.ca&gt;
 * MIT Licensed
 */

/**
 * Convert interpolation in the given string to JavaScript.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

var interpolate = exports.interpolate = function(str){
  return str.replace(/(\\)?([#!]){(.*?)}/g, function(str, escape, flag, code){
    return escape
      ? str
      : &quot;&#x27; + &quot;
        + (&#x27;!&#x27; == flag ? &#x27;&#x27; : &#x27;escape&#x27;)
        + &quot;((interp = &quot; + code.replace(/\\&#x27;/g, &quot;&#x27;&quot;)
        + &quot;) == null ? &#x27;&#x27; : interp) + &#x27;&quot;;
  });
};

/**
 * Escape single quotes in &#x60;str&#x60;.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

var escape = exports.escape = function(str) {
  return str.replace(/&#x27;/g, &quot;\\&#x27;&quot;);
};

/**
 * Interpolate, and escape the given &#x60;str&#x60;.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.text = function(str){
  return interpolate(escape(str));
};
}); // module: utils.js

window.jade = jadeRequire(&quot;jade&quot;);
})();

    </pre>
</div>

                </div>
            </div>
        </div>
    </div>
<a id="gotoTop" class='well well-small' href='#'>
    Top
</a>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.min.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/config.js"></script>
<script src="../assets/js/doc.js"></script>
</body>
</html>
